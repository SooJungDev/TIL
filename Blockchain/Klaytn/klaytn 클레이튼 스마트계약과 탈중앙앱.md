# Klaytn 클레이튼 스마트계약과 탈중앙앱
- 인프런 강의듣고 정리
- [Klaytn 클레이튼 스마트계약과 탈중앙앱](https://www.inflearn.com/course/klaytn-%EC%8A%A4%EB%A7%88%ED%8A%B8%EA%B3%84%EC%95%BD%EA%B3%BC-%ED%83%88%EC%A4%91%EC%95%99%EC%95%B1/dashboard)

## 블록체인이란?
- 정보를 블록이라고 하는 단위로 저장하여 저장된 블록들을 체인형태로 묶은 저장기술

## 해시함수
- 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
Rules
- 하나의 데이터에서 오직 단 하나의 해시가 도출

해시함수 예제
- 같은 함수라도 다른데이터를 해시할 경우 결과값이 크게 다름
- 같은 데이터라도 다른 함수로 해시할 경우 결과 값이 크게 다른것 확인

## 블록
- 블록은 헤더와 바디로 구분
- 헤더는 블록을 설명하는 정보와 이전 블록의 해시를 포함
- 이전 블록의 해시를 가지기 떄문에 
  - 어떤 블록이 앞에 와야하는지 결정적으로 알수 있고
  - 이를 바탕으로 블록의 순서를 결정 할 수 있음

블록높이, 블록생성주기
- 블록들은 이전 블록이 아래에 최근 블록이 위로 오도록 정렬하면 블록이 생성됨에 따라 체인 높이가 늘어난다.
- 블록의 순서를 그 블록이 위치한 높이라고 부른다 첫번쨰 블록은 높이를 0

## 블록체인 네트워크 노드
- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리
- 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지

## 합의(Consensus)
- 자격이 있는 참여자는 블록을 제안(propose) 할 수 있음
- 블록 제안 자격은 네트워크마다 상이
- 블록이 체인에 추가됨 = 참여자들이 새 블록을 자신의 체인에 추가
- 노드들은 제안자가 올바른 자격을 취득했는지, 제안된 블록이 올바른지 검증뒤 블록을 자신의 체인에 추가
- 정족수 또는 정해진 기준을 만족하는 수의 노드가 블록을 자신의 체인에 추가하면 합의가 이뤄졌다고 판단

## 정리 브록체인의 불변성과 투명성
- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리
- 네트워크 참여자 전원은 모든 블록을 동일한 순서로 저장하여 모두 같은 블록체인을 유지
- 자격이 있는 참여자는 블록을 제안 할 수 있음: 블록 제안 자격은 네트워크마다 상이
- 블록이 체인에 추가됨 = 참여자들이 새 블록을 자신의 체인에 추가
- 따라서 새로운 블록이 체인에 추가되려면 네트워크의 합의가 필요 합의방법은 네트워크마다 상이
  - 어느 한 주체가 단독으로 결정하는 구조가 아닌, 여러 참여자가 합의를 통해 결정하기 때문에 블록체인은 탈중화되어 있다고 표현
- 참여자 전원은 이전 블록들을 저장하고 있으므로 새로운 블록의 무결성을 확인가능
- 새롭게 제안되는 블록은 참여자들이 검증 및 합의할 수 있는 형태여야함(투명성)
- 한번 쓰여진 블록은 이전의 합의를 번복 할 수 있지 않는 한 변경 될 수 없음(불변성)

## 합의 알고리즘 비교분석
- nonce : 해쉬값을 바꾸기 위해 넣는 가비지값
- PoW : 계산이 어려운 문제를 풀것, 합의에 필요한 연산량 높음, 갈수록 노드의 참여가 어려움
  - 위협 : 전체의 연산량을 51%를 한 참여자가 소유할 경우 중앙화됨
- PoS: 플랫폼 토큰을 보유한 양과 기간에 따라 결정적

## 암호
- 고전적인 암호 : 카이사르 암호
- 대칭키 암호/ 비대칭키 암호

## 비대칭키암호(공개키 암호)
- 누구든지 암호화 할 수 있지만 비밀키를 아는사람만 복호화 할 수 있어야 한다
    - 비밀키로부터 공개키를 도출하는것은 쉬움
    - 공개키로부터 비밀키를 찾는건 매우 어려움

## 전자서명
- 비대칭키암호는 지정된 사람만 정보를 확인할 수 있도록 도움(privacy)
- 전자서명은 누가 정보를 보냈는지 알기 위해 사용(non-repudiation)

## 블록체인과 공개키 암호
- 블록체인은 암호학적 기법을 토대로 만들어진 기술
- Bitcoin은 네트워크 참여자 모두가 같은 원장을 공유함으로써 투명한 거래가 가능
- 원장은 어느 주소에 BTC가 있는지 기록하지만 그 주소가 누구에게 속하는지 기록하지 않음(anonymity)
- Bitcoin은 공개키암호를 사용하여 명시적인 비밀교환과정 없이 BTC의 소유권 증명을 실

공개키 암호화를 사용한 소유권 증명
서명 + 공개키 

## 구현방법으로 나눠본 블록체인
UTXO (Unspent Transaction Output) 기반 블록체인
- 블록체인에 사용 가능한 토큰 - UTXO들과 사용 자격검증방법을 기록
- 일반적인 자격검증방법은 UTXO의 정보와 일치하는 공개키로 검증가능한 전자서명을 제출하는것
- Bitcoin이 대표적인 UTXO 기반 블록체인

어카운트 기반 블록체인(Account-based Blockchain)
- 어카운트는 블록체인을 구성하는 주제(entity)를 표현하며 상태를 기록
- 사용자는 어카운트를 사용 할때 마다 어카운트 공개키로 검증가능한 전자서명을 생성
- 상태를 기록 할 수 있기 때문에 스마트 컨트랙트를 구현하기에 용이
- Ethereum, Klaytn이 대표적인 어카운트 기반 블록체인

## 트랜잭션
- 블록은 트랜잭션들을 일정한 순서로 정렬하여 저장하는 컨테이너
- 트랜잭션은 어카운트의 행동
- 트랜잭션의 순서는 중요: TX_1 -> TX_2 와 TX_2 -> TX_1는 다름
- 블록체인 참여자들은 블록을 검증 할 떄 트랜잭션들이 올바른 순서대로 정렬되었는지를 확인 후 합의
- 각각의 트랜잭션들은 어카운트에 연결된 공개키로 검증가능한 서명을 포함

## Confirmation Vs Finality
- Confirmation 숫자는 블록에 포함된 이후 생성된 블록의 숫자
- PoW를 사용하는 블록체인들은 finality가 없기 때문에 confirmation 숫자가 중요
- Finality 란 블록의 완결성을 의미
  - 합의를 통해 생성된 블록이 번복되지 않을 경우 완결성이 존재
- PoW 기반 합의는 확률에 기반하기 떄문에 경우에 따라 블록이 사라질 수 있으므로 완결성이 부재함
  - PoW 블록체인은 수학적으로 복잡한 퍼즐을 풀어 블록을 제안할 자격을 얻는 구조
  - 만약 두명의 서로 다른 참여자가 동시에 퍼즐을 풀어 두개의 올바른 블록을 생성한다면 블록중 하나는 (eventually) 사라지게 됨
  - 이 떄문에 블록이 확률적 완결성을 갖기까지 일정 갯수 이상의 블록이 생성되기를 기다려야 함

## Understanding Bitcoin's 6 Confirmations Rule
- 네트워크 시차로 인해 생성된 우연한 복수의 블록들 가운데 하나가 선택되는데 필요한 블록은 두어개 정도 -> 2~3 confirmations
- 퍼즐을 빠르게 풀 수 있는 악의적인 참여자(공격자)가 있을 경우 그 참여자의 해시능력(hash power)에 따라 필요한 confirmation 숫자가 달라짐
  - 해시능력이 높을 수록 퍼즐을 푸는 속도도 빠르기 떄문에 주어진 문제를 먼저 풀 확률이 높아짐
  - 해시능력이 높은 참여자는 longest chain을 임의로 선택 또는 생성 할 수 있음
  - 따라서 해시능력을 감안하더라도 임의로 블록체인을 변경하지 못할 정도로로 충분히 많은 블록이 생성되기를 기다려야할 필요가 생김
  - Bitcoin의 6 confirmation 법칙은 공격자가 전체 해시능력의 약 25%를 가질 때를 가정한 숫자

## BFT 기반 블록체인
- BFT 기반의 블록체인은 블록의 완결성이 보장됨
  - 네트워크가 동기화되어 있기 때문
  - 블록 생성이 PoW에 비해 빠르고 경제적
- 하지만 네트워크 동기화의 필요로 인해 참여자의 숫자가 제한됨
  - 네트워크 참여자 구성이 고정되어 있어야 합의가 가능
  - 구성이 변경될 경우 모든 네트워크 참여자가 새로운 구성을 인지하기 까지 합의 불가능
  - 합의 알고리즘이 네트워크 동기화를 가정하고 짜여졌기 떄문에 네트워크 사용량이 높음
  - 참여자가 많아질 경우 네트워크 오버헤드로 인해 합의가 느림

## Blockchain State
- 블록체인은 트랜잭션으로 변화하는 생태기계 (State Machine)

## 상태기계
- 블록체인은 초기상태에서 변경사항을 적용하여 최종상태로 변화하는 상태기계
  - 이전 블록의 최종상태는 현재 블록의 초기상태
  - Gen block 의 경우 임의 초기값들이 설정되는데 이것이 gen block의 초기상태이자 최종상태
- (어카운트 기반) 블록체인의 상태
  - 블록체인의 상태 = 블록들에 저장된 트랜잭션(TX)들을 순차적으로 실행하여 나온 결과
  - TX 어카운트를 생성하거나 변경
  - 항상 같은 결과를 보장하기 위해 하나의 TX가 반영되는 과정에서 다른 TX 개입은 제한됨

## (Recall) Ethereum 어카운트 종료
- External Account : 사용자(end user)가 사용하는 어카운트(EOA)
- Contract Account : 스마트 컨트랙트를 표현하는 어카운트

- Ethereum 은 EOA 와 스마트 컨트랙트의 상태를 기록 및 유지
  - 스마트 컨트랙트는 특정주소에 존재하는 실행 가능한 프로그램
  - 프로그램은 상탤르 가지기 때문에 Ethereum/Klaytn은 스마트 컨트랙트를 어카운트로 표현
- EOA는 블록에 기록되는 TX를 생성
  - 블록에 기록되는 TX들은 명시적인 변경을 일으킴(e.g 토큰전송, 스마트 컨트랙트 배포/실행)

## 트랜잭션(TX)과 가스(Gas)
- TX의 목적은 블록체인의 상태를 변경하는것
  - TX는 보내는 사람(Sender, from)과 받는 사람(recipient, to)이 지정되어 있으며
  - to가 누구냐에 따라 TX 목적이 세분화
- Gas: TX를 처리하는데 발생하는 비용
  - TX를 처리하는데 필요한 자원을 비용으로 전환한것이 가스
  - Sender는 TX의 처리를 위해 필요한 가스의 총량과 같은 가치의 플랫폼 토큰을 제공해야함
  - 이떄 지출되는 플랫폼 토큰을 가스비라 정의 가스비는 블록을 생성한 노드가 수집
  - 이더리움은 sender가 임의로 per gas 가격을 설정 할 수 있도록 허용
  - 클레이튼은 sender가 임의로 per gas 가격을 설정할 수 없도록 gas price를 프로토콜에서 고정

## 트랜잭션과 서명
- 플랫폼은 sender가 TX가 처리되는데 필요한 가스비를 가지고 있는지 확인
- TX는 sender의 서명(v,r,s)이 필요
  - 어카운트의 balance 를 사용하기 때문
  - 서명의 증명은 구현마다 상이
    - 이더리움 : 서명 -> 공개키 도출 -> 어카운트주소 도출 -> 어카운트 존재유무 확인
    - 클레이튼 : from 주소확인 -> 저장된 공개키 불러오기 -> 서명 직접 검증


## Alice 와 Node 사이 통신
Alice -> Node
- Alice는 Tx를 생성 서명하여 노드에게 전달
- 이때 데이터 구조를 온전하게 전달하고자 RLP 알고리즘으로 TX를 직렬화
- Alice 와 Node가 같은 프로토콜로 통신하는것이 중요

Node-> Alice
- 올바른 TX 수신시 TX 해시를 반환
- TX 체결시 Receipt 를 반환; 소요된 Gas, Tx 해시, input, output등이 기록

## 스마트 컨트랙트
- 특정주소에 배포되어 있는 TX로 실행 가능한코드
  - 스마트 컨트랙트 소스코드는 함수와 상태를 표현
  - 컨트랙트는 어카운트로 취급; 컨트랙트 소스코드는 블록체인에 저장
  - 함수는 상태를 변경하는 함수, 상태를 변경하지 않는 함수로 분류
  - 스마트 컨트랙트는 어카운트이기 때문에 주소를 부여
  - 사용자가 스마트 컨트랙트 함수를 실행하거나 상태를 읽을때 주소가 필요
- 스마트 컨트랙트는 사용자가 실행
  - 상태를 변경하는 함수를 실행하려면 그에 맞는 TX를 생성하여 블록에 추가(TX체결 = 함수의 실행)
  - 상태를 변경하지 않는 함수, 상태를 읽는 행위는 TX가 필요 없음(노드에서 실행)

## Contract = Code + Data
- Solidity 컨트랙트 코드(함수)와 데이터(상태)로 구성
- Solidity 함수는 코드안에 변수로 선언된 상태를 변경하거나 불러옴

## ByteCode & ABI
- Solidity 소스코드(.sol파일)를 컴파일하면 Bytecode(.bin파일)와 ABI(.abi파일)가 생성

Bytecode
- 컨트랙트를 배포할때 블록체인에 저장하는 정보
- Bytecode는 Solidity 소스코드를 EVM이 이해할 수 있는 형태로 변환한것
- 컨트랙트 배포시 HEX로 표현된 Bytecode 를 TX에 담아 노드에 전달

ABI(Application BinaryInterface) a.k.a JSON interface
- ABI는 컨트랙트 함수를 JSON형태로 표현한 정보로 EVM이 컨트랙트함수를 실행할때 필요
- 컨트랙트 함수를 실행하려는 사람은 ABI정보를 노드에 제공

## Blockchain Application (BApp)
- 블록체인 어플리케이션(BApp)은 블록체인을 사용하는 어플리케이션
  - 기존의 기술로 풀기 어려운 문제들을 블록체인의 특성을 활용하여 풀어내는 것이 목적
- 불변성과 투명성이 대표적인 블록체인의 특성
  - 한번 기록된 정보는 변경 할 수 없으며
  - 정해진 규칙(e.g 블록생성등 프로토콜이 가진 규칙, 컨트랙트로 구현된 규칙)에 따 라 상태를 변경
  - 기록의 내역이 블록에 공개되어 있으므로 누구든지 정보의 진실여부를 확인 가능

## Fully Decentralized
- 장점 :
  - 높은 투명성
  - 신뢰형성에 필요한 비용 x
  - 경우에 따라 사용자의 익명성 보장 가능
  - 관리비용 낮음
- 단점 :
  - 사용자 책임증가 X, 어려운 UX
  - 로직변경 어려움
  - 경우에 따라 사용자가 블록체인에 상시 접속할 필요및 블록을 복제할 필요 있음

## Semi-Decentralized with Centralized Proxy
- 장점 :
  - 높은 수준의 UX
  - 사용자가 블록체인과 직접 통신할 필요 없음
  - 로직 변경 비교적 쉬움

- 단점:
  - 신뢰비용 발생
  - 서비스가 Single Point of Failure(SPoF) 가 됨
  - 관리비용 높음

## 지갑(Wallet)
- TX를 서명하려면 키가 필요
  - 키 -> 어카운트
  - 서로 다른키는 다른 어카운트에 매핑
  - 하나의 어카운트로 여러 BApp을 사용하려는 사용자의 니즈가 존재
- 지갑 = 키를 관리하는 프로그램
  - 키를 보관하고 BApp이 요청할대마다 보관중인 키로 TX를 서명
  - 여려 유형의 지갑이 존재
    - 브라우저 플러그인, Dapp 브라우저 내장 지갑, 클라우드 지갑, 디바이스 지갑

## Unique Electronic Assets
- 블록체인의 불변성을 사용하여 복제불가능한 디지털 데이터를 생성
- Non-Fungible Token(NFT)
  - NFT를 사용하여 중앙화된 관리 없이 각각이 유일한 한정수량 상품을 개발기능
  - 상품권,증명서,바우처,Collectibles 수량이 제한되어 있는 게임 아이템 제작등


## Error Handling
- assert(bool condition) : condition이 false일 경우 실행 중인 함수가 변경된 내역을 모두 이전 상태로 되돌림(로직체크에 사용)
- require(bool condition) : condition이 false일 경우 실행 중인 함수가 변경한 내역을 모두 이전 상태로 되돌림(외부 변수 검증에 사용)
- require(bool condition, string memory message): require(bool)과 동일. 추가로 메세지 전달

## Cryptographic Functions
- 가스비 많이먹는 3대장 가급적 안쓰는것이 좋음
- keccak256(bytes memory) returns (byte32): 주어진 값으로 Keccak-256 해시를 생성
- sha256(bytes memory) returns (byte32): 주어진 값으로 SHA-256 해시를 생성
- ecrecover(byte32 hash, uint8 v, byte32 r, byte32 s) returns (address) :
   서명(v,r,s)으로 부터 어카운트 주소를 도출(서명 => 공개키 => 주소)

## Expression and Control Structures
- 예외처리 기능이 없음 (try-catch)없음
- contract 간결하게 짜야됨

## Creating Contract
- 일반적인 컨트랙트 생성 => 배포
- 컨트랙트를 클래스처럼 사용
  - 컨트랙트를 객체지향 프로그래밍에서 사용하는 클래스로 취급 할 수 있음
  - new 키워드를 사용하여 컨트랙트를 생성하여 변수에 대입

## Visibility and Getters
- 함수의 공개정도를 목적에 맞게 썰정
- external
  - 다른 컨트랙트에서 & 트랜잭션을 ㅌ오해 호출가능
  - internal 호출 불가능 (i.e f()는 안되지만 this.f()는 허용됨)
- public
  - 트랜잭션을 통해 호출가능, internal 호출 가능
- internal
  - 외부에서 호출 불가능 internal 호출가능 상속받은 컨트랙트에서 호출 가능
- private
  - internal 호출 가능

## Function Declarations: pure vs view
- 함수 제약을 설정하여 정해진 scope에서 동작 할 수 있도록 설정
- pure
  - State Variable 접근불가 Read(X), Write(X)
- view
  - State Variable 변경불가 Read(O), Write(X)
- (none)
  - 제약 없음 Read(O), Write(O)

