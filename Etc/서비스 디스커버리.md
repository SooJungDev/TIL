## 서비스 디스커버리
- 클라우드에서 인스턴스는 동적으로 할당되기 때문에 ip주소나 포트 정보가 정해지지 않음
- 오토스케일링도 일어나고 중지되고 복구되면서 네트워크 위치가 계속해서 바뀌게 됨
- 따라서 **클라이언트나 API 게이트웨이가 호출할 서비스를 찾는 메커니즘이 필요하고 이를 서비스 디스커버리라고함**

두가지 방식으로 나눔
- 클라이언트 사이드 디스커버리 패턴
- 서버 사이드 디스커버리 패턴

## 클라이언트 사이드 디스커버리
- 서비스 인스턴스의 네트워크 위치를 찾고 로드밸런싱하는 역할을 클라이언트가 담당하는 방식
- 서비스 인스턴스는 시작될때 자신의 네트워크 주소를 서비스 레지스트리에 등록하고, 서비스 레지스트리는 각 서비스 인스턴스 상태를 계속해서 체크함
- 클라이언트는 서비스 레지스트리에 등록된 인스턴스 중 하나를 골라서 요청을 보내는 방식으로 로드밸런싱이 이루어짐
- 인스턴스가 종료되면 서비스 레지스트리에 등록된 정보는 삭제됨

- Netflix OSS 가 클라이언트 사이드 디스커버리 패턴의 좋은예
- Netflix Eureka 는 서비스 레지스트리로 서비스 인스턴스 등록과 가용한 인스턴스를 찾는 REST API 를 제공
- Netflix Ribbon 은 유레카같이 동작하는 IPC 클라이언트로 가능한 서비스 인스턴스 간 로드밸런싱을 해줌

잠점
- 디스커버 로직을 클라이언트가 가지고 있기 때문에 서비스에 맞는 로드밸런싱 방식을 각자 구현할 수 있다는 점

단점
- 각 서비스 마다 서비스 레지스트리를 구현해야 하는 종속성이 생김
- 만약 서비스마다 다른 언어를 사용 하고있다면 언어별 또는 프레임워크별로 구별

## 서버 사이드 디스커버리
- 서버쪽에서 디스커버리 로직을 구현한 방식입니다.
- 클라이언트는 로드밸런서로 요청을 보냄
- 로드밸런서는 서비스 레지스트리를 조회해서 가용한 인스턴스를 찾고 그중 선택해서 요청을 라우팅 하는 방식
- 서비스 레지스트리에 등록되는 방식은 클라이언트에 있을 때와 같음
- AWS Elastic Load Balancer 서버 사이드 서비스 디스커버리 패턴의 좋은 예
    - ELB 는 일반적으로 인터넷에서 들어오는 외부 트래픽을 로드밸런싱 하는데 사용되고 VPC 에서 내부 트래픽을 처리할때 사용되기도 함
- Kubernetes 와 Marathon 같은 환경에서는 클러스트 내 호스트 별로 프록시(proxy)를 실행 합니다. 이 프록시는 서버 쪽 서버 디스커버리의 역할을 함
 - 클러스트 내에 가용한 서비스 인스턴스로 요청을 포워딩
- 서버 사이드 서비스 디스커버리 방식은 디스커버리 로직을 클라이언트에서 분리 할 수 있음
- 반면에 이 서비스 디스커리가 죽으면 전체 시스템이 동작하지 않기 때문에 고가용성등 더 많은 관리가 필요

## 서비스 레지스트리
- 셔비스 레지스트리는 **각 서비스 인스턴스의 네트워크 위치 정보를 저장하는 데이터베이스**로 항상 최신 정보를 유지해야하며 고가용성이 필요함
- 앞서 이야기한 서비스 레지스트리인 Netflix Eureka 는 서비스 인스턴스를 등록하고 조회하는 API를 제공함
- 각 서비스 인스턴스는 POST 요청으로 자신의 네트워크 위치를 등록하고 30초마다 PUT 요청으로 자신의 정보를 갱신해야함
- 등록된 서비스 정보는 DELETE 요청이나 타임아웃으로 삭제됨
- 등록된 서비스 정보는 GET 요청으로 조회 할 수 있음
- Netflix Eureka 서비스를 여러개의 Amazon EC2위에 실행하고 가용영역에 배포한다
- 이렇게 여러개 인스턴스가 각자 격리된 위치에서 실행되도록 구성하면 고가용성을 유지 할 수있음
- Eureka 서버가 실행되는 EC2 인스턴스는 Elastic IP 주소를 가지고 있고 DNS 의 TEXT 레코드는 클러스터 정보를 저장합니다.
- Eureka 서버가 시작되면 DNS에 Eureka 클러스터 설정 정보를 조회하고 사용하지 않는 주소에 스스로 Elastic IP 를 할당함
- 따라서 Eureka 클라이언트는 DNS를 이용해 Eureka 서버의 네트워크 위치를 조회 할 수 있음
- 같은 가용영역에 있는 Eureka 서버에 먼저 접속하겠지만 가능한 인스턴스가 없으면 다른 가용영역의 인스턴스에 접속하게 됨

서비스 레지스트리를 사용하는 다른 예
- etcd
- consul
- Apache Zookeeper

## 서비스 등록
- 각 서비스는 서비스 레지스트리에 각자의 정보를 등록하 해제해야함 2가지 방식이 있다
 - 셀프 등록 패턴 (Self Registration Pattern) : 서비스 스스로 등록을 관리
 - 써드 파티 등록 패턴 (3rd Party Registration Pattern) : 제 3의 시스템에서 등록을 관리
 
## 셀프 등록 패턴
- 등록과 관리를 하는 주체가 서비스인 방식
- 각 서비스는 서비스 레지스트리에 자신의 정보를 등록
- 필요하다면 주기적으로 자신이 살아있다는 신호(heartbeat)를 계속 전송
- 만약 일정 시간이 지나도 오지 않는다면 서비스에 문제가 발생한것으로 보고 등록이 해제됨 
- 서비스가 종료될때 등록을 해제
- Eureka 클라이언트가 이에 해당 
- Spring Cloud project 에서 @EnableEurekaClient 어노테이션을 이용해 쉽게 구현
- 이 방식은 다른 컴포넌트 없이 간단하게 구성 할 수 있다는 장점이 있지만 각 서비스에서 서비스 등록 로직을 구현해하하는 단점이 있음

## 써드 파티 등록 패턴
- 외부에서 서비스 등록을 관리하는 방법
 - 서비스 등록을 관리하는 서비스 서비스 레지스트라를 따로 두는 방법
- 서비스 레지스트라는 각 서비스 인스턴스의 변화를 폴링(polling) 이나 이벤트 구독으로 감지해서 서비스 레지스트리에 계속 업데이트해야함

- 이런 방식의 예로는 Registrator 가 있음 Docker 컨테이너로 배포된 서비스 인스턴스의 등록을 관리하는 오픈 소스 프로젝트 
    - etcd 와 Consul 를 포함해 여러 서비스 레지스트리를 지원함
    
- 다른 예로는 NetflixOSS Prana가 있음 기본적으로 non-JVM 언어로 작성된 서비스를 위해서 만들어진 어플리케이션으로 어플리케이션과 함께 실행되는 방식
    - Eureka 서비스 인스턴스를 등록 및 해제하는 역할을 함. 이외에도 배포 환경에 내장된 서비스 레지스트라를 사용 할 수 있음
    
- 이러한 방식의 장점은 서비스에서 서비스 등록 및 관리 로직을 분리 할 수 있음
- 중앙에서 통제가 가능하는점
- 단점은 서비스 레지스트라가 멈추면 안되기 때문에 고가용성등 더많은 관리가 필요함
    


## 참고사이트
- [마이크로서비스 Microservices (4) 서비스 디스커버리](https://futurecreator.github.io/2018/10/18/service-discovery-in-microservices/)
