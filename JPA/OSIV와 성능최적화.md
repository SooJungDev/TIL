## OSIV와 성능최적화
- Open Session In View : 하이버네이트
- Open EntityManager in View : JPA

## OSIV ON
- spring.jpa.open-in-view: true 기본값
- 이 기본깂을 뿌리면서 애플리케이션 시작 시점에 warn 로그를 남기는것은 이유가 있다
- OSIV 전략은 트랜잭션 시작처럼 **최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날떄  까지 영속성 컨텍스트와 데이터 커넥션을 유지한다.**
- 그래서 지금까지 View Template이나 API 컨트롤러에서 지연로딩이 가능
- 지연로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다. 이것 자체가 큰 장점

단점
- 그런데 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 떄문에 실시간 트래픽이 중요한 어플리케이션에서는 커넥션이 모잘랄 수 있다
- 이것이 결국 장애로 이어진다.
- 예를 들어서 컨트롤러에서 외부 API를 호출하면 외부 API 대기시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야한다.

## OSIV OFF
- spring.jpa.open-in-view : false 
- OSIV를 끄면 트랜잭션을 종료할떄 영속성 컨텍스트를 달고, 데이터베이스 커넥션도 반환한다. 따라서 커넥션 리소스를 낭비하지 않는다
- OSIV 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야한다. 따라서 지금까지 작성한 많은 지연로딩 코드를 트랜잭션 안으로 넣어야 하는 단점이 있다.
- view template에서 지연로딩이 동작하지 않는다
- 결론적으로 트랜잭션이 끝나기전에 지연로딩을 강제로 호출해 두어야 한다.


## 커멘드와 쿼리 분리
- 실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법이 있다. 바로 Command와 Query를 분리하는 것이다.
- 보통 비지니스 로직은 특정 엔티티 몇개를 등록하거나 수정하는것이므로 성능이 크게 문제가 되지 않는다.
- 그런데 복잡한 화면을 출력하기위한 쿼리는 화면만 맞추어 성능을 최적화하는것이 중요하다
하지만 그 복잡성에 비해 핵심 비지니스에 큰 영향을 주는것은 아니다.
- 그래서 크고 복잡한 어플리케이션을 개발한다면 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분히 의미가 있다

ex)
- OrderService
  - OrderService : 핵심 비지니스 로직
  - OrderQueryService : 화면이나 API에 맞춘 서비스(주로 읽기 전용 트랜잭션 사용)
- 보통 서비스 계층에서 트랜잭션을 유지한다. 두 서비스 모두 트랜잭션을 유지하면서 지연로딩을 사용 할 수 있다.

참고
- 고객의 서비스 실시간 API는 OSIV를 끄고 ADMIN처럼 커넥션을 많이 사용하지 않는 곳에는 OSIV를 켠다


## 참고
- 실전!스프링 부트와 JPA활용2 강의자료