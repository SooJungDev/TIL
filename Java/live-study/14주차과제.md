# 14주차 과제
목표
- 자바의 제네릭에 대해 학습하세요.

학습할 것 (필수)
- 제네릭 사용법
- 제네릭 주요 개념 (바운디드 타입, 와일드 카드)
- 제네릭 메소드 만들기
- Erasure


## 제네릭 사용법
- 제네릭은 일반화 한다는 뜻을 담고있음
- 제네릭은 어떠한 자료형을 기반으로 인스턴스의 생성이 가능하도록, 자료형에 일반적인 클래스를 정의하는 문법
  
제내릭 클래스 정의
~~~java
class FruitBox<T>{
    T item;
    public void store(T item){
        this.item = item;
    }
    public T pullOut(){
        return item;
    }
}
~~~
- T 라는 이름은 type 의 약자를 대문자로 표현한것
- 이 클래스의 인스턴스를 생성하려면 자료형 정보를 인자로 전달해야하며 전달되는 인자는 클래스내에 존재하는 T를 대체해서 인스턴스 생성이됨

- 첫번째 문장은 T를 Orange로 대체하여 인스턴스를 생성하고, 두번째문장은 T를 Apple 로 대체하여 인스턴스를 생성한다.
- 참조변수 선언에서도 인스턴스 생성시 전달되는 자료형 정보를 동일하게 명시해줘야함
~~~java
 final FruitBox<Orange> orangeBox = new FruitBox<>();
 final FruitBox<Apple> appleBox = new FruitBox<>();
~~~

~~~java
class Orange {
    int sugarContent;

    public Orange(int sugar) {
        sugarContent = sugar;
    }

    public void showSugarContent() {
        System.out.println("당도 " + sugarContent);
    }
}

class Apple {
    int weight;

    public Apple(int weight) {
        this.weight = weight;
    }

    public void showAppleWeight() {
        System.out.println("무게 " + weight);
    }
}

class FruitBox<T>{
    T item;
    public void store(T item){
        this.item = item;
    }
    public T pullOut(){
        return item;
    }
}

class GenericBaseFruitBox {
    public static void main(String[] args) {
        final FruitBox<Orange> orangeBox = new FruitBox<>();
        orangeBox.store(new Orange(10));
        final Orange orange = orangeBox.pullOut();
        orange.showSugarContent();

        final FruitBox<Apple> appleBox = new FruitBox<>();
        appleBox.store(new Apple(20));
        final Apple apple = appleBox.pullOut();
        apple.showAppleWeight();
    }
}
~~~
- 하나의 클래스의 정의로 둘 이상의 클래스를 정의한 효과를 제너릭은 가져다주고있음


## 제네릭 주요 개념 (바운디드 타입, 와일드 카드)
- 제네릭은 컴파일 타임에 타입 정확성을 적용하고, 애플리케이션에 추가 오버헤드를 발생시키지 않고 제네릭 알고리즘을 구현 할 수 있도록 한다.

Bounded Generics
- 제네릭 매개변수의 자료형에 제한을 둘 수 있는 문법적인 요소를 제공함, 허용 할 수 있는 유형을 제한 할 수있다.

~~~java
interface SimpleInterface {
    void showYourName();
}

class UpperClass {
    public void showYourAncestor() {
        System.out.println("UpperClass");
    }
}

class AAA extends UpperClass implements SimpleInterface {

    @Override
    public void showYourName() {
        System.out.println("class AAA");
    }
}

class BBB extends UpperClass implements SimpleInterface {

    @Override
    public void showYourName() {
        System.out.println("class BBB");
    }
}

class BoundedTypeParam2 {

    // 제한하기전 코드 메소드 매개변수인 param 을 이용해서 강제로 형을 변환한다음에 호출해주었음
   /* public static <T> void oldShowInstanceAncestor(T param){
        ((SimpleInterface)param).showYourName();
    }

    public static <T> void oldShowInstanceName(T param){
        ((UpperClass)param).showYourAncestor();
    }*/

    // T를 대신하여  SimpleInterface를 구현하는 클래스 자료형이 되어야 함을 명시해줌 
    public static <T extends SimpleInterface> void showInstanceAncestor(T param) {
        param.showYourName(); // 해당 인터페이스에 있는 메소드를 바로 호출할수 있게됨
    }

    // T가 UpperClass 를 상속하는 클래스의 자료형이 되어야 함을 명시해줌
    public static <T extends UpperClass> void showInstanceName(T param) {
        param.showYourAncestor(); // 해당 클래스에 있는 메소드를 바로 호출 할 수 있게됨
    }

    public static void main(String[] args) {
        AAA aaa = new AAA();
        BBB bbb = new BBB();

        showInstanceAncestor(aaa);
        showInstanceName(aaa);
        showInstanceAncestor(bbb);
        showInstanceName(bbb);
    }
}
~~~

## 제네릭 메소드 만들기
## Erasure
제네릭은 유형의 안정성을 보장하고 제너릭이 런타임에 오버헤드를 일으키지 않도록하기 위해 java에 추가되었으며, 컴파일러는 컴파일타임에 제너릭에 Type Erasure 라는 프로세스를 적용함

Type Erasure는 모든 유형 매개변수를 제거하고 바운디드타입(제한되어있는 경우)일 경우 제한하고 있는 타입으로 변경하거나 ,타입파라미터가 제한되어 있지 않은경우 Object 로 대체한다.

Type Erasure 예시
~~~java
public <T> List<T> genericMethod(List<T> list){
    return list.stream().collect(Collectors.toList());
}
~~~

- Type Erasure이 적용되면 특정타입으로 제한되지 않은 T가 Object 로 대체됨
~~~java
// for illustration
public List<Object> withErasure(List<Object> list) {
    return list.stream().collect(Collectors.toList());
}

// which in practice results in
public List withErasure(List list) {
    return list.stream().collect(Collectors.toList());
}
~~~

- 바운디드타입일 경우 컴파일 타임에 제한 되어있는 타입으로 대체된다.
~~~java
public <T extends Building> void genericMethod(T t){
   ...
}
~~~
- 컴파일 후 아래와같이 변경됨
~~~java
public void genericMethod(Building t){
   ...
}
~~~

- java에서 제네릭 제한사항은 타입파라미터가 primitive type 으로 올 수 없다는것임
- 해당코드 컴파일 에러남
~~~java
List<int> list = new ArrayList<>();
list.add(17);
~~~

-  primitive type 으로 올 수 없다는것은 Type Erasure 때문이다
-  컴파일 타임에 타입파라미터가 지워지고 Object 로 변경되어야되는데 primitive type은 Object 를 상속하지 않으므로 Object로 변경될수 없기 때문이다.


## 참고
- 난정말 Java를 공부한적이 없다구요 책
- https://www.baeldung.com/java-generics