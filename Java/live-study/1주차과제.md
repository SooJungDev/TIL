# 1주차 과제
목표
- 자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.

학습할것
- JVM이란 무엇인가
- 컴파일 하는 방법
- 실행하는 방법
- 바이트코드란 무엇인가
- JIT 컴파일러란 무엇이며 어떻게 동작하는지
- JVM 구성 요소
- JDK와 JRE의 차이


## JVM이란 무엇인가
JVM(Java Virtual Machine)
- 자바 가상 머신의 약자를 따서 줄여 부르는 용어
- 자바 가상 머신으로 자바 바이트 코드 (.class 파일)을 OS 에 특화된 코드로 변환(인터프리터와 JIT 컴파일러) 하여 실행한다

JVM 특징
- JVM 은 스택기반의 가상머신
- 심볼릭 레퍼런스 기본 자료형(primitvie data type)을 제외한 모든 타입을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다
- 기본 자료형을 명확하게 정의하여 플랫폼 독립성을 보장
- 네트워크 바이트 오더: 자바 클래스 파일은 네트워크 바이트 오더를 사용한다

## 컴파일 하는 방법
- 명령어 입력 javac 자바파일이름.java
- ex)
~~~
cmd > javac Study.java
~~~

자바도 전처리, 컴파일, 링크 과정을 통해 최종 실행 파일 만들어진다
컴파일의 세부단계는 어휘분석, 구문분석, 의미분석, 중간코드생서으 중간코드 최적화로 구성됨

자바코드를 자바 언어 스펙에 따라 분석/검증하고 JVM 스펙의 class 파일 구조에 맞는 바이트 코드를 만들어 내는 과정
자바소스 코드 파일(.java) -> javac 컴파일러 -> JVM 바이트코드(.class)

## 실행하는 방법
- java.exe 파일을 사용하여 바이트코드로 컴파일된 .class 실행
- ex) Study.class 파일 실행
~~~
cmd > java Study
~~~


자바프로그램 실행 과정
1. 프로그램이 실행되면 JVM 은 OS 로 부터 이 프로그램이 필요로 하는 메모리를 할당 받음
   - JVM 은 이 메모리를 용도에 따라 여러 영억으로 나누어 관리
2. 자바 컴파일러(javac)가 자바 소스코드(.java) 를 읽어들여 자바 바이트코드(.class)로 변환 시킨다
3. class loader 를 통해 class 파일들을 JVM 으로 로딩한다
4. 로딩된 class 파일들은 Execution engine 을 통해 해석
5. 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행 이뤄진다
   - 이러한 실행 과정속에 JVM 은 필요에 따라 Thread Synchronization 과 GC 같은 관리 작업을 수행

## 바이트코드란 무엇인가
- WORA(Write Once Run Anywhere) 를 구현하기위해 JVM 은 사용자 언어인 자바와 기계어 사이의 중간 언어인 자바 바이트 코드를 사용한다
- 이 자바 바이트코드가 자바 코드를 배포하는 가장 작은 단위


## JIT 컴파일러란 무엇이며 어떻게 동작하는지
JIT(Just-In-Time) 컴파일러: 인터프리터의 단점을 보완하기 위해 도입된것이 JIT 컴파일러
인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 해당 메서드를 더이상 인프리팅 하지 않고 네이티브 코드로 직접 실행시키는 방식
네이티브 코드를 실행 하는 것이 하나씩 인터프리팅 하는것보다 빠르고, 네이티브 코드는 캐시에 보관하기 때문에 한번 컴파일된 코드는 계속 빠르게 수행됨

JIT 컴파일러가 컴파일하는 과정은 바이트코드를 하나씩 인터프리팅 하는것보다 훨씬 오래걸리므로
한번만 실행되는 코드라면 컴파일하지않고 인터프리팅 하는것이 유리하다
따라서 JIT 컴파일러를 사용하는 JVM 들은 해당 메서드가 얼마나 자주 수행되는지 체크하고 일정 정도를 넘을때만 컴파일을 수행한다

<img width="479" alt="스크린샷 2020-11-18 오후 10 06 57" src="https://user-images.githubusercontent.com/38197944/99534284-837c9c80-29ea-11eb-846e-278b86540170.png">
출처 : https://d2.naver.com/helloworld/1230 JVM구조 그림 8 JIT 컴파일러

JIT 컴파일러는 바이트 코드를 일단 중간 단계의 표현인 IR(Intermediate Representation) 로 변환하여 최적화를 수행하고 그다음에 네이티브 코드를 생성한다.


아래 설명을 돕기위해 추가함
** 인터프리터: 바이크코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나씩 해석하고 실행하기 때문에 바이트코드 하나하나의 해석은 빠른대신 인터프리팅 결과의 실행은 느리다는 단점
즉 바이트코드라는 언어는 기본적으로 인터프리터 방식으로 동작



## JVM 구성요소
<img width="540" alt="스크린샷 2020-11-18 오후 9 43 11" src="https://user-images.githubusercontent.com/38197944/99532174-35b26500-29e7-11eb-87f6-a3518faa03c4.png">
출처 : https://d2.naver.com/helloworld/1230 JVM구조 그림 1 자바 코드 수행 과정


클래스 로더 시스템
- .class 에서 바이트 코드를 읽고 메모리에 저장
- 로딩: 클래스를 읽어오는 과정
- 링크: 레퍼런스를 연결하는 과정
- 초기화: static 값들 초기화 및 변수에 할당

런타임 데이터 영역
런타임 데이터 영역 구성

<img width="385" alt="스크린샷 2020-11-18 오후 10 16 52" src="https://user-images.githubusercontent.com/38197944/99535321-1bc75100-29ec-11eb-97c5-adb18ed58c98.png">
출처 : https://d2.naver.com/helloworld/1230 그림 4 런타임 데이터 영역 구성

런타임 데이터 영역은 JVM 이란느 프로그램이 운영체제 위에서 실행되면서 할당받은 메모리영역
6개의 영억으로 나눌수 있다

- PC 레지스터(PC Register) : PC 레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작할때 생성된다. PC 레지스터는 현재 수행중인 JVM 명령의 주소를 갖는다
  
- JVM 스택(JVM Stack) : JVM 스택은 각 스레드마다 하나씩 존재하며 스레드가 시작될때 생성된다 스택프레임이라는 구조체를 저장하는 스택으로, JVM은 오직 JVM 스택에 스택 프레임을 추가(push)하고 제거(pop)하는 동작만 수행한다. 예외 발생시 printStackTrace() 등의 메서드로 보여주는 Stack Trace 는 하나의 스택프레임을 표현한다.
    - 스택 프레임: JVM 내에서 메서드가 수행될때마다 하나의 스택프레임이 생성되어 하나의 스레드의 JVM 스택에 추가되고 메서드가 종료되면 스텍 프레임이 제거된다
    각 스택프레임은 지역 변수 배열(Local Variable Array), 피연산자 스택(Operand Stack), 현재 실행중인 메서드가 속한 클래스의 런타임 상수 풀에대한 레퍼런스를 갖는다. 지역 변수 배열, 피연산자 스택의 크기는 컴파일시에 결정되기 때문에 스택프레임 크기도 메서드에 따라 크기가 고정된다
  
- 네이티브 메서드 스택(Native Method Stack): 자바외의 언어로 작성된 네이티브 코드를 위한 스택 즉 JNI(Java Native Interface)를 통해 호출하는 c/c++ 등의 코드를 수행하기 위한 스택으로 언어에 맞게 C, C++ 스택이 생성됨
  

  
- 메서드 영역(Method Area):메서드 영역은 모든 스레드가 공유하는 영역
  JVM 이 시작될때 생성된다. JVM 이 읽어들인 각각의 클래스와 인터페이스에 대한 런타임 상수풀, 필드와 메서드 정보 Static 변수, 메서드의 바이트코드등을 보관한다. 메서드 영역에 대한 가비지 컬렉션은 JVM 벤더의 선택사항
  
- 런타임 상수 풀(Runtime Constant Pool): 클래스파일 포맷에서 constant_pool 테이블에 해당하는 영역이다.
  메서드 영역에 포함되는 영역이지만 JVM 동작에서 핵심적인 역할을 수행하는곳이기 때문에 JVM 명세에서도 따로 중요하게 기술한다.
  각 클래스와 인터페이스 상수뿐만 아니라 메서드와 필드에 대한 모든 레퍼런스까지 담고있는 테이블이다.
  즉 어떤 메서드나 필드를 참조할때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조한다.
  
- 힙(Heap): 인스턴스 또는 객체를 저장하는 공간으로 가비지 컬렉션 대상이다. 
   JVM 성능등의 이슈에서 가장많이 언급되는 공간. 힙 구성 방식이나 가비지 컬렉션 방법등은 JVM 벤더의 재량이다

## JDK와 JRE의 차이
JDK(Java Development Kit): JRE + 게발툴
- JRE + 개발에 필요한 툴
- 소스코드를 작성할때 사용하는 자바언어는 플랫폼에 독립적
- 오라클은 자바 11부터 JDK 만 제공하며, JRE 를 따로 제공하지 않는다
  
JRE(Java RunTime Environment) : JVM + 라이브러리
- 자바 애플리케이션을 싱행 할 수 있도록 구성된 배포판
- JVM 과 핵심 라이브러리 및 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일을 가지고 있음
- 개발 관련 도구는 포함하지 않음

## 참고
- [백기선님의 더 자바, 코드를 조작하는 다양한 방법 강의 JVM 이해하기](https://www.inflearn.com/course/the-java-code-manipulation/dashboard)
- [자바가상머신, JVM(Java Virtual Machine) 이란 무엇인가](https://asfirstalways.tistory.com/158)
- [JVM Internal](https://d2.naver.com/helloworld/1230)
- [Back to the Essence - Java 컴파일에서 실행까지 - (1)](https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/)
- https://junior-datalist.tistory.com/26
