# 3주차 과제
목표
- 자바가 제공하는 다양한 연산자를 학습하세요.

학습할것
- 산술 연산자
- 비트 연산자
- 관계 연산자
- 논리 연산자
- instanceof
- assignment(=) operator
- 화살표(->) 연산자
- 3항 연산자
- 연산자 우선 순위
- (optional) Java 13. switch 연산자

##  산술 연산자
- 산술 연산자인 사칙 연산자(+,-.*,/), 나머지 연산자(%), 쉬프트 연산자(<<,>>,>>>) 는 모두 두개의 피연산자를 취하는 이항연산자
- 이항 연산자는 피연산자의 크기가 4byte 보다 작으면 4byte(int)형로 변환한 다음에 연산을 수행하는점을 명심

모든 이항 연산자는 연산을 수행하기전에
- 크기가 4Byte 이하인 자료형을 int형으로 변환 (byte, char,short -> int)
- 피연산자들의 타입을 서로 일치시킨다.
  
사칙연산자
- +,-,*,/,%
- *,/,% 가 +,- 연산자가 우선순위가 높다

1. int형 (4 byte)보다 크기가 작은 자료형은 int 형으로 형변환 후에 연산을 수행한다
   - ex) byte + short -> int + int -> int
2. 두 개의 피연산자 중 자료형의 표현범위가 큰 쪽에 맞춰서 형변환 된후 연산을 수행한다.
   - ex) int + float -> float + float -> float
3. 정수형 간의 나눗셈에서 0으로 나누는것은 금지되어 있다.


피연산자의 타입에 따른 이항연산 결과

| 피연산자 1                                              | 피연산자2             | 연산결과 |
|---------------------------------------------------------|-----------------------|----------|
| byte ,  short ,  char                                   | byte ,  short ,  char | ìnt      |
| byte ,  short ,  char ,  int                            | int                   | ìnt      |
| byte ,  short ,  char ,  int ,  long                    | long                  | long     |
| byte ,  short ,  char ,  int ,  long ,  float           | float                 | float    |
| byte ,  short ,  char ,  int ,  long ,  float ,  double | double                | double   |

~~~
  실제 연산         형변환        연산결과
byte + byte -> int +  int ->  int 
byte + short ->  int + int ->  int 
char + char ->  int + int -> int

float + int ->  float + float -> float 
long + float ->  float + float ->  float 
float + double -> double + double ->  double
~~~

~~~java
class Test {
    public static void main(String[] args){
        byte a =10;
        byte b =20;
        //byte c = a+b; // 컴파일 에러 발생 명시적으로 형변환이 필요함
        byte c = (byte)(a+b);
        System.out.println(c);
    }
}
~~~

~~~java
class Test {
    public static void main(String[] args){
        byte a =10;
        byte b =20;
        byte c = (byte)(a*b);
        System.out.println(c);
        // 실행결과 44 기대값은 300 형변환 캐스팅때문에 데이터 손실이 일어난다
    }
}
~~~
- 값 손실을 예방하기위해서는 계산할때 충분히 큰 자료형을 사용하는것이 좋음

~~~java
class Test {
    public static void main(String[] args){
        char c1 = 'a';
        // char c2 = c1+1;  // 컴파일에러 발생
        char c2= 'a'+1  // 컴파일 에러 없음, 리터럴 간의 연산 
        System.out.println(c2);
    }
}
~~~

![이름 없는 노트북-9](https://user-images.githubusercontent.com/38197944/100363374-fbc50c80-303f-11eb-98a8-c234d878d527.jpg)


##  비트 연산자
- | (OR 연산자) : 피연산자 중 한쪽 값이 1이면 1을 결과로 얻음 그외 0
- & (AND 연산자) : 피연산자 양쪽이 모두 1이여야 1을 결과로 얻음 그외 0
- ^ (XOR 연산자) : 피연산자 값이 서로 다를때만 1을 결과로 얻는다. 같을때는 0
- ~ (NOT 연산자) : 0 -> 1로 1-> 0 피연산자의 부호가 반대로 변경된다.

~~~
class Test{
     public static void main(String[] args){
        int x= 3; 
        int y= 5;
        System.out.println("x는 "+x+"이고, y는 "+ y +"일 때,");  
        System.out.println("x | y = " + (x|y)); // 7
        System.out.println("x & Y= " + (x&y));  // 1
        System.out.println("x ^ y = "+ (x^y));  // 6
    }
}
~~~

위의 코드를 계산해보면 아래와 같다.
![이름 없는 노트북-12](https://user-images.githubusercontent.com/38197944/100368664-37170980-3047-11eb-88a4-271fb378b956.jpg)



### NOT 연산자 (~)
- NOT 연산자 '~' 는 정수형과 char 형에만 사용
- 피연산자를 2진수로 표현했을때 0 -> 1로 1-> 0 으로 변환
- '~' 연산자에 의해 비트 전환 되고나면 피연산자의 부호가 반대로 변경된다.

![이름 없는 노트북-11](https://user-images.githubusercontent.com/38197944/100365202-8149bc00-3042-11eb-86fa-9f03c820a1ba.jpg)

~~~java
class Test{
     public static void main(String[] args){
         byte b = 10;
         // byte result = ~b; 
         // ~ 연산의 결과가 int 라서 byte 변수에 저장할수 없음
         byte result = (byte) ~b;

         System.out.println("b =" + b);
         System.out.println("~b =" + result);
     }
}
~~~
실행결과
~~~
b = 10
~b = -11
~~~

- '~' 피연산자의 타입이 int 형보다 작으면 int 형으로 변환한 다음에 연산하기 때문에 위에 코드 같은 경우 연산 결과가 int 형이 된다.

##  관계 연산자
##  논리 연산자
##  instanceof
##  assignment(=) operator
##  화살표(->) 연산자
##  3항 연산자
- 삼항 연산자는 세개의 피연산자를 필요로함 
- 조건식과 조건식이 참일때와 거짓일때 반환되는 값, 이 세가지가 삼항연산자의 피연산자이다
- 삼함 연산자의 조건식에는 연산결과가 true, flase 인 식이 사용되어야 됨
- 삼항 연산자는 if 문으로 바꿔 쓸 수 있으며 간단한 if 문대신 삼항연산자를 사용하면 코드를 보다 간단히 할수 있음

~~~
  (조건식) ? 식1: 식2
~~~

- 삼항연산자로 표현된식
~~~
 result = (x > 0) ? x : -x;
~~~

- if 문으로 위의 식을 바꿔봄
~~~
 if(x>0){
     result = x;
 }else {
     result = -x;
 }
~~~

~~~java
class Test{
     public static void main(String[] args){
       int x= 10;
       int y = -10;
       int absX = (x >= 0) ? x : -x;
       int absY = (y >= 0) ? Y : -y;

       System.out.println("x= 10일 때， x의 절대값은 "+absX); // 10
       System.out.println("y=-10일 때， y의 절대값은 "+absY) ;  // 10
     }
}
~~~

##  연산자 우선 순위
##  (optional) Java 13. switch 연산자


## 참고
- 자바의 정석 책
  