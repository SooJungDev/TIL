# 6주차 과제
목표
- 자바의 상속에 대해 학습하세요.

학습할것 필수
- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
- 추상 클래스
- final 키워드
- Object 클래스

## 자바 상속의 특징
- 상속이란 기존 클래스를 재사용하여 새로운 클래스를 작성하는것
- 상속을 통해서 클래스를 작성하면 보다 적응 야으이 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할수 있기 때문에 코드의 추가 및 변경에 용이
- 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다
- 자바에서는 단일 상속만을 허용하기 때문에 하나 이상의 클래스로 부터 상속을 받을 수 없다.

- 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자하는 클래스의 이름을 키워드 'extends' 와 함께 써주기만 하면됨
~~~java
class child extends Parent {
    // ...
}
~~~
- 이 두 클래스는 서로 상속관계 상속해주는 클래스 부모클래스, 상속받는 클래스를 자식클래스

~~~java
class Parent {
    int age;
}
class Child extends Parent{
    void play() {
       System.out.println("놀자");             
    }
}
~~~

## super 키워드
- super는 자식클래스에서 부모클래스로부터 상속받은 멤버를 사용되는 참조변수이다.
- 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을떄 super 를 사용해서 구별할 수있다
- 부모클래스로부터 상속받은 멤버조 자식클래스 자신의 멤버이므로 super 대신 this 를 사용 할수있다. 그래도 부모클래스 멤버와 자식클래스 멤버가 중복정의되어 서로 구별해야하는 경우에만 super 를 사용하는것이 좋다
- 조상의 멤버와 자신의 멤버를 구별하는데 사용된점 빼고는 super, this 는 같음
- 모든 인스턴스 메서드에는 자신이 속한 인스턴스 주소가 지역변수로 저장되는데 이것이 참조변수인 this, super 값이 된다.
- static 메서드는 인스턴스와 관련이 없다. 그래서 this와 마찬가지로 super에서 static 메서드에서는 사용할 수 없고 인스턴스 메소드에서만 사용할 수 있다.

~~~java
class SuperTest {
    public static void main(String[] args) {
        Child c = new Child();
        c.method();
    }
}

class Parent {
    int x = 10;
}

class Child extends Parent {
    int x = 20;
    void method() {
        System.out.println("x=" + x);// 자기자신의 멤버변수
        System.out.println("this.x=" + this.x); // 자기자신의 멤버변수
        System.out.println("super.x=" + super.x);// 부모클래스의 멤버변수
    }
}
~~~

~~~실행결과
x=20
this.x=20
super.x=10
~~~

- 메소드 역시 super를 써서 호출 할 수있다. 특히 부모 클래스의 메소드를 자식 클래스에서 오버라이딩 한 경우에 super 를 사용한다.
~~~
class Point {
    int x;
    int y;

    String getLocation() {
        return "x :" + x + ",y :" + y;
    }

    public static void main(String[] args) {
        Point3D point3D = new Point3D();
        point3D.x=5;
        point3D.y=5;
        point3D.z=5;
        String location = point3D.getLocation();
        System.out.println(location);
    }
}

class Point3D extends Point {
    int z;

    @Override
    String getLocation() { // 오버라이딩

        //return "x :" + x + ",y :" + y + ", z:" + z;
        return super.getLocation() + ", z:" + z; //부모 메소드 호출
    }

}

~~~

## 메소드 오버라이딩
- override 의 사전적 의미는 overwrite 위에 덮어쓰다.
- 부모클래스로 부터 상속받은 메소드 내용을 변경하는것을 오버라이딩이라고한다
- 상속받은 메소드를 그대로 사용하기도 하지만 자식 클래스에 맞게 변경해야되는 경우가 많다 이럴때 메소드를 오버라이딩한다.

~~~java
class Point {
    int x;
    int y;

    String getLocation() {
        return "x :" + x + ",y :" + y;
    }
}

class Point3D extends Point {
    int z;

    @Override
    String getLocation() { // 오버라이딩
        return "x :" + x + ",y :" + y + ", z:" + z;
    }
}
~~~

오버라이딩이 성립하기 위해서는 다음조건이 만족되어야함
- 자식클래스에서 오버라이딩 메서드는 부모클래스의 메소드와
    - 이름이 같아야한다
    - 매개변수가 같아야한다
    - 리턴타입이 같아야한다

- 선언부가 서로 일치해야함
- 접근제어자와 예외는 제한된 조간하에서만 다르게 변경할수 있다

1. 접근제어자는 부모클래스의 메소드보다 좁은 범위로 변경 할 수 없다
   - 부모클래스의 정의된 메소드 접근제어자가 protected 라면 오버라이딩하는 자식클래스의 메소드는 접근제어자가 protected 나 public 이어야 한다.

~~~java
class Point {
    int x;
    int y;

    String getLocation() throws IOException {
        return "x :" + x + ",y :" + y;
    }
}

class Point3D extends Point {
    int z;

    @Override
    String getLocation() throws Exception{ // 에러가남
        return "x :" + x + ",y :" + y + ", z:" + z;
    }
}
~~~

2. 부모클래스의 메소드보다 많은수의 예외를 선언할 수 없다.
   - 자식 클래스에서 Exception 은 모든 예외의 최고 조상, 가장많은 개수의 예외를 던질수 있도록 선언되어있다. 아래와 같이 에러가 난다
~~~
Error:(18, 12) java: getLocation() in main.java.example.Point3D cannot override getLocation() in main.java.example.Point
  overridden method does not throw java.lang.Exception
~~~


## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)

## 추상 클래스

## final 키워드

## Object 클래스
- Object 클래스는 모든 클래스의 상속계층도의 제일 위에 위치하는 부모클래스
- 다른 클래스로부터 상속받지 않는 모든클래스들은 자동적으로 Object 클래스로 부터 상속받게 함으로써 가능하게함
- 모든 상속계층도의 최상위에는 Object 클래스가 위치한다
- toString(), equals(Object o) 같은 메서드를 따로 정의하지 않고도 사용할수 있었던 이유는 이 메소드들이 Object 클래스에 정의된 것들이기 때문이다
