# 8주차 과제
목표
- 자바의 인터페이스에 대해 학습하세요.

학습할것 필수
- 인터페이스 정의하는 방법
- 인터페이스 구현하는 방법
- 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
- 인터페이스 상속
- 인터페이스의 기본 메소드 (Default Method), 자바 8
- 인터페이스의 static 메소드, 자바 8
- 인터페이스의 private 메소드, 자바 9


## 인터페이스 정의하는 방법
인터페이스란?
- 인터페이스는 일종의 추상클래스이다
- 인터페이스도 추상클래스처럼 완성되지 않은 불완전한 것이기 때문에 그자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움 줄 목적으로 작성된다
  
인터페이스를 정의하는 방법
- 키워드로 interface 를 사용해서 정의한다
- 멤버변수는 public static final 이어야 하며 이를 생략 할 수 있다
- 메소드는 public abstrac 이어야하며 이를 생략 할 수 있다.
~~~java
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메소드이름(매개변수목록);
}
~~~

- 인터페이스에서 정의된 모든 멤버에 예외없이 적용되는 사항이기때문에 제어자를 생략 할 수 있는 것이며, 편의상 생략하는 경우가 많다. 생략된 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다.
~~~java
public interface PlayingCard {
    public static final int SPADE = 4;
    final int DIAMOND = 3; //  public static final int DIAMOND = 3; 
    static int HEART = 2;//  public static final int HEART = 2;
    int CLOVER = 1;// public static final int CLOVER = 1;

    public abstract String getCardNumber();
    String getCardKind();// public abstract String getCardKind();
}
~~~

## 인터페이스 구현하는 방법
- 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성 할 수 없으며, 추상클래스가 상속을 통해 추상메서드를 완성하는 것 처럼, 인터페이스도 자신에 정의된 추상메소드의 몸통을 만들어주는 클래스를 작성해야한다.
~~~java
class 클래스이름 implements 인터페이스이름{
    // 인터페이스에 정의된 추상메소드를 구현해야한다.
}

class Fighter t implements Fightable {
    public void move(int x, int y) { /*내용생략*/ }
    public void attack(Unit u) { /*내용생략*/ }
}
~~~

- 만일 구현하는 인터페이스의 메서드 중 일부만 구현한다면 추상클래스로 선언되어야한다
~~~java
abstract class partFighter implements Fightable{
    public void attack(Unit u) { /*내용생략*/ }
}
~~~

~~~java
// 상속과 구현을 동시에 할 수 도 있다.
class Fighter extends Unit implements Fightable {
    public void move(int x, int y) {
        this.x += x;
        this.y += y;
        System.out.println("move!! x:" + x + "y :" + y);
    }

    public void attack(Unit u) {
        --currentHp;
        System.out.println("attact !! position:  x " + x + "y :" + y + " currentHp : " +currentHp);
    }
}

class Unit {
    int currentHp; //유닛의 체력
    int x; // 유닛의 위치(x좌표)
    int y; // 유닛의 위치(y좌표)
}

interface Fightable extends Movable, Attackable {}

interface Movable {
    //지정된 위치(x,y) 로 이동하는 기능의 메서드
    void move(int x, int y);
}

interface Attackable {
    // 지정된 대상(u) 를 공격하는 기능의 메서드
    void attack(Unit u);
}
~~~

## 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

## 인터페이스 상속
- 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중상속, 즉 여러개의 인터페이스로 부터 상속 받는것이 가능하다
- 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상은 없다.
  
~~~java
interface Movable {
    //지정된 위치(x,y) 로 이동하는 기능의 메서드
    void move(int x, int y);
}

interface Attackable {
    // 지정된 대상(u) 를 공격하는 기능의 메서드
    void attack(Unit u);
}

/* 클래스 상속과 마찬가지로 자식 인터페이스(Fightable) 은 조상인터페이스(Movable, Attackable) 에 정의된 멤버를 모두 상속 받는다
그래서 Fightable 자체에는 정의 된 멤버가 없지만 조상인터페이스로 부터 상속받은 두개의 추상메소드 move(int x, int y) , attack(Unit u) 를 멤버로 갖게된다.
*/
interface Fightable extends Movable, Attackable {}
~~~

## 인터페이스의 기본 메소드 (Default Method), 자바 8

## 인터페이스의 static 메소드, 자바 8

## 인터페이스의 private 메소드, 자바 9

## 참고
- 자바의 정석 책