## 5부. 애노테이션 프로세서
### Lombok(롬복)은 어떻게 동작하는걸까?
[Lombok](https://projectlombok.org/)
- @Getter , @Setter, @Builder 등의 애노테이션과 애노테이션 프로세서를 제공하여 표준적으로 작성해야 할 코드를 개발자 대신 생성해주는 라이브러

롬복 사용하기
- 의존성 추가
~~~
<dependency> 
     <groupId>org.projectlombok</groupId>
     <artifactId>lombok</artifactId>    
     <version>1.18.8</version> <scope>provided</scope>
</dependency>
~~~
- Intellij lombok 플러그인 설치
- Intellij Annotation Processing 옵션 활성화

롬복 동작원리
- 컴파일 시점에 [애노테이션 프로세서](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html)를 사용하여
**소스코드의 [AST](https://javaparser.org/inspecting-an-ast/) (abstarct syntax tree)를 조작**한다.

논란 거리
- 공개된 API가 아닌 컴파일러 내부 클래스를 사용하여 기존 소스 코드를 조작한다.
- 특히 이클립스의 경우엔 java agent를 사용하여 컴파일러 클래스까지 조작하여 사용한다.
  해당 클래스들 역시 공개된 API가 아니다보니 버전 호환성에 문제가 생길 수 있고 언제라도 그런 문제가 발생해도 이상하지 않다.
- 그럼에도 불구하고 엄청난 편리함 때문에 널리 쓰이고 있으며 대안이 몇가지 있지만 롬복의 모든 기능과 편의성을 대체하진 못하는 현실이다
    - [AutoValue](https://github.com/google/auto/blob/master/value/userguide/index.md)
    - [Immutables](https://immutables.github.io/)
    
참고
- [Interface Processor API](https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html)
- [Lombok Execution Path](https://projectlombok.org/contributing/lombok-execution-path)
- [Can I add a method to a class from a compile time annotation?](https://stackoverflow.com/questions/36563807/can-i-add-a-method-to-a-class-from-a-compile-time-annotation)
- [@Cleanup](http://jnb.ociweb.com/jnb/jnbJan2010.html#controversy)
- [Experiences with the New Java 5 Language Features](https://www.oracle.com/technetwork/articles/grid/java-5-features-083037.html)

### 애노테이션 프로세서 1부
[Processor 인터페이스](https://docs.oracle.com/en/java/javase/11/docs/api/java.compiler/javax/annotation/processing/Processor.html)
- 여러 라운드(rounds)에 거쳐 소스 및 컴파일 된 코드를 처리 할 수 있다.

유틸리티
- [AutoService](https://github.com/google/auto/tree/master/service): 서비스 프로바이더 레지스트리 생성기
~~~
<dependency> 
    <groupId>com.google.auto.service</groupId>
    <artifactId>auto-service</artifactId> 
    <version>1.0-rc6</version>
</dependency>
~~~
~~~java
@AutoService(Processor.class)
public class MagicMojaProcessor extends AbstractProcessor {
  ...
}
~~~
- 컴파일 시점에 애노테이션 프로세서를 사용하여 META-INF/services/javax.annotation.processor.Processor 파일 자동으로 생성해 줌 

ServiceProvider
- [Java Service Provider Interface (SPI)— understanding it via code](https://itnext.io/java-service-provider-interface-understanding-it-via-code-30e1dd45a091)

참고
- [ANNOTATION PROCESSING 101](http://hannesdorfmann.com/annotation-processing/annotationprocessing101)
- [Project Lombok: Creating Custom Transformations](http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html)
- [Annotation Processing in Java](https://medium.com/@jintin/annotation-processing-in-java-3621cb05343a)
- [Annotation Processing : Don’t Repeat Yourself, Generate Your Code.](https://medium.com/@iammert/annotation-processing-dont-repeat-yourself-generate-your-code-8425e60c6657)
- [ANNOTATION PROCESSING](https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#processing)

### 애노테이션 프로세서 2부
[Filer 인터페이스](https://docs.oracle.com/en/java/javase/11/docs/api/java.compiler/javax/annotation/processing/Filer.html) 
- 소스 코드, 클래스 코드 및 리소스를 생성 할 수 있는 인터페이스
~~~java
@Override
public boolean process(Set<? extends TypeElement> annotaions, RoundEnvironment roundEnv){
    Set<? etends Element> elements = roundEnv.getElementsAnnotatedWitd(Magic.class);
    for(Element element : elements){
         Name elementName = element.getSimpleName();
         if(element.getkind() != ElementKind.INTERFACE){
              processingEnv.getMessager().printMessage(Diagnostic.kind.ERROR, "Magic
                 annotation can not be used on" + elementName);
         }else{
            processingEnv.getMessager().printMessage(Diagnostic.kind.NOTE, "Processing "+ elementName);
         }

        TypeElement typeElement = (TypeElement) element;
        ClassName className = ClassName.get(typeElement);

        MethodSpec pullOut = MethodSpec.methodBuilder("pullOut")
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return $S", "Rabbit!")
                .build();

        Filer filer = processingEnv.getFiler();
        try {
            JavaFile.builder(className.packageName(), magicMoja)
                    .build()
                    .writeTo(filer);
        }catch (IOException e) {
             processingEnv.getMessage().printMessage(Diagnostic.kind.ERROR, "FATAL ERROR: "+ e);
        }
    }
    return true;
}
~~~
유틸리티
- [javapoet](https://github.com/square/javapoet) : 소스 코드 생성 유틸리티

### 애노테이션 프로세서 정리
애노테이션 프로세서 사용 예
- 롬복
- AutoService : java.util.ServiceLoader 용 파일 생성 유틸리티
- @Override
    - [How do annotations like @Override work internally in Java?](https://stackoverflow.com/questions/18189980/how-do-annotations-like-override-work-internally-in-java/18202623)
- [Dagger2](https://github.com/google/dagger) : 컴파일 타임 DI 제공
- 안드로이드 라이브러리
 - [Butterkinfe](http://jakewharton.github.io/butterknife/) : @BindView(뷰 아이디와 애노테이션을 붙인 필드 바인딩)
 - [DeepLinkDispatch](https://github.com/airbnb/DeepLinkDispatch) : 특정 URI 링크를 Activity 로 연결 할 때 사용
 
애노테이션 프로세서 장점
- 런타임 비용이 제로

애노테이션 프로세서 단점
- 기존 클래스 코드를 변경 할 떄는 약간의 hack이 필요하다.

### 마무리
이번 강의에서 다룬 내용
- JVM 구조
- 바이트 코드 조작 ASM 또는 javassist, ByteBuddy
- 리플렉션 API - 클래스 정보 참조(메소드, 필드, 생성자, ...)
- 다이나믹 프록시 기법  proxy, CGlib, ByteBuddy
- 애노테이션 프로세서 AbstractProcessor, Filer, ..., AutoService, Javapoet

