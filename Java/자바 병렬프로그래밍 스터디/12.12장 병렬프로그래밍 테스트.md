## 12장 내용
- 12.1 정확성 테스트
- 12.2 성능 테스트
- 12.3 성능 측정의 함정 피하기
- 12.4 보조적인 테스트 방법

## 12.1 정확성 테스트

### 가장 기본적인 단위 테스트

### 블로킹 메소드 테스트

### 안전성 테스트

### 자원관리 테스트

### 콜백 사용

### 스레드 교차 실행량 확대

## 12.2 성능 테스트

### PutTakeTest에 시간 측정 부분 추가

### 다양한 알고리즘 비교

### 응답성 측정

## 12.3 성능 측정의 함정 피하기
- 실제로 테스트 프로그램을 작성할때는 성능을 올바로 나타내지 못하는 수치를 뽑아내는 잘못된 코딩 방법으로 프로그램을 작성하지 않도록 주의해야 한다.

### 가비지 컬렉션
- 가비지 컬렉션이 언제 실행된것인지 미리 알고 있을수 없으며, 시간을 측정하는 테스트 프로그램이 동작하는 동안 가비지 컬렉션 작업이 진행될 가능성도 높다.
- 실행할때 가비지 컬렉션이 진행됬다면, 실행 횟수를 살짝 변경하기만 해도 테스트당 실행시간은 엉터리 값으로 바뀔수 있다

가비지 컬렉션때문에 테스트 결과가 올바르지 않게 나오는 경우를 막을 수 있는 두가지방법
- 테스트가 진행되는 동안 가비지 컬렉션이 작업이 실행되지 않도록 하는 방법이 있음
- 테스트가 진행되는 동안 가비지 컬렉션 여러번 실행된다는 사실을 명확히 하고 테스트 결과에 객체 생성 부분이나 가비지 컬렉션 부분을 적절하게 반영하도록 하는 방법
    - 후자를 많이 택함, 테스트 프로그램을 훨씬 긴 시간동안 실행 할 수 있으며 실제 상황에서 나타나는 성능을 좀더 가깝게 반영하기 때문이다.
  
- 프로듀서-컨슈머 패턴으로 구성된 어플리케이션은 상당한 양의 객체를 메모리에 할당하고 가비지 컬렉션 부하도 큰편이다. 
- 따라서 BoundedBuffer 클래스를 대상으로 테스트 프로그램을 적당히 오랜시간 동안 동작시키면 일정 횟수 이상 가비지 컬렉션이 동작할 것이며, 실제 적용할때와 유사한 성능 결괄르 얻을수 있다.

### 동적 컴파일
- 자바 언어와 같이 동적으로 컴파일하면서 실행되는 언어로 작성된 프로그램은 c,c++ 와 같이 정적으로 컴파일된 상태에서 실행되는 언어로 만들어진 프로그램보다 성능을 측정하기 어렵고 결과를 해석하는것도 어렵다.
- 핫스팟 JVM이나 기타 사용되는 JVM은 바이터 코드 인터프리트 방식과 동적 컴파일 방법을 혼용해 사용한다.
    - ex) 클래스의 바이트코드 읽어들인다음 -> 인터프리터를 통해 바이트 코드 실행 
    - 일정시점이 지난이후 메소드가 특정횟수 이상 자주 실행된다면 동적 컴파일러가 해당 메소드를 기계어 코드로 컴파일한다.
    - 컴파일이 완료되면 그 이후에는 인터프리트하는 대신 컴파일된 코드를 직접 실행시킨다.
- 테스트 프로그램이 시간을 측정하는 도중에 컴파일러가 동적으로 메소드 코드를 컴파일하도록 놔둔다면 두가지 측면에서 결과에 오류가 생길 가능성이있다.
    - 컴파일 하는 과정에서 CPU를 상당히 소모, 또한 인터프리트되는 코드와 컴파일된 코드, 컴파일하는 시간모두 테스트 결과에 포함시키면 일관성이 부족한 결과값을 얻을수 밖에 없다.

- A는 컴파일하지 않고 계속해서 인터프리터로 실행하는 모습
- B는 인터프리터로 실행하다 중간에 컴파일해 실행되는모습
- C는 B보다 먼저 컴파일을 진행하고 실행되는 모습
- 컴파일 작업이 언제 실행되는지가 전체 실행 시간에 큰 영향을 미치고, 그에 따라 단일 연산에 소모되는 시간역시 영향을 미친다.
  
- 컴파일된 프로그램 코드는 때에 따라 디컴파일하고 다시 재컴파일 하는 과정을 거치는 경우도 있다
    - ex) 이전 컴파일 과정에서 가정했던 사항이 변경됐거나, 아니면 실제로 실행해보면서 얻은 성능평가 결과를 놓고 다른 최적화 방법을 적용해 다시 컴파일 하도록 하기도 한다.
- 컴파일된 코드와 컴파일 되지 않는 코드때문에 성능 측정치가 올바르지 않게 나타나는 상황을 예방하는 가장 간단한 방법은 테스트 프로그램을 긴시간동안 실행시켜 컴파일될 부분은 모두 컴파일되고 추가로 컴파일하거나 인터프리터로 실행되는 코드를 최소화 하는 방법이다
- 다른 방법으로는 시간을 측정하지 않는 워밍업하는 테스트를 한번 미리 실행시켜 필요한 코드를 모두 컴파일시키고, 이후에 시간을 측정하는 실제 테스트 프로그램을 실행시켜 성능 측정치를 뽑아내는 방법도 있다.
- 핫스팟 JVM을 사용하는 경우라면 -XX:+PrintCompilation 옵션을 사용해 동적 컴파일 작업이 실행될때 메세지를 출력시킬 수 있다. 
- 초기에 실행했던 결과는 워밍업 과정이라고 보고 제외하고, 그이후 측정 결과를 봣을때 측정값의 변동이 크다면 똑같은 태스트를 실행하는데 걸리는 시간이 왜 일정하게 유지되지 않는지에 대한 원인을 찾아봐야 할것이다.
- JVM은 내부작업을 처리하기 위해 여러개의 백그라운드 스레드를 사용한다
- 테스트를 여러번 실행하는 사이마다 약간의 쉬는 시간을 두어 JVM이 일상 작업을 처리 할 수 있도록 배려하는것이 좋다
- 그래야 시간을 측정하는 테스트가 진행될때 꼭 해야하는 JVM 내부 작업을 처리하느라 CPU를 소모하고 그로인해 테스트 실행 시간 결과값에 오류가 발생하는일이 줄어든다.

### 비현실적인 코드 경로 샘플링
- 런타임 컴파일러는 컴파일할 코드에 대한 최적화 정보를 얻기 위해 실행 과정에서 여러가지 성능값을 추출한다.
- JVM은 더나은 코드를 생성할 수 있도록 프로그램 실행에 관련된 특정 정보를 사용하기도 한다.
- 어떤 경우에는 JVM이 코드를 컴파일 할때 일시적으로 효과를 발휘할수 있는 몇가지 가정을 설정하고 그에따라 컴파일하기도한다
- 그리고 만약 설정했던 가정이 어느 시점 이후에 올바르지 않은 가정이라고 판단한다면 컴파일한 코드를 무효로하고 새로 컴파일하기도한다.
- 따라서 특정 어플맄케이션에 사용하느 시나리오 패턴만을 묘사해 테스틑하는것보다는 유사한 다른 시나리오 패턴도 한데 묶어서 테스트하는일도 중요한 부분이다
- 이렇게 테스트 하지 않는다면 예를 들어 완전히 단일 스레드에서 동작했어야 할 테스트 프로그램에 동적 컴파일러가 일반적인 서버 어플리케이션처럼 최소한의 병렬성을 필요로하는 상황에 맞게 특별한 최적화 기법을 사용해 코드를 컴파일해 문제가 발생 할 수도 있다.
- 그래서 단일 스레드 프로그램 성능을 테스트하고자 할때도 단일 스레드 프로그램의 성능뿐만 아니라 멀티 스레드 어플리케이션의 성능도 함께 테스트하는것이 좋다.

### 비현실적인 경쟁 수준
- 병럴 어플리케이션은 두종류의 작업을 번갈아가며 실행하는 구조로 동작한다.
- 여러 스레드가 공유하는 큐에서 다음 처리할 작업을 뽑아내는것과 같이 공유된 데이터에 접근하는 종류의 작업이 있고, 큐에서 가져온 작업을 실행한느것과 같이 스레드 내부의 데이터만을 갖고 실행되는 작업이 있다.
- 전체작업을 두 종류의 작업으로 구분해 봤을때 각각 얼마만큼의 비율을 차지하는지에 따라 경쟁의 수준이 달라지고 성능과 확장성 측면에서 굉장히 다른 결과를 내놓게된다.
- 실행 성능은 CPU의 처리 속도에 굉장히 의존하게된다.
- 반대로 개별 작업이 아주 짧은 시간안에 빠르게 실행된다면 작업큐에서 서로 작업을 가져가려고 경쟁이 많이 발생할것이며 전체적인 실행 성능은 동기화 방법에 따라 좌지우지된다.
- 실제 어플리케이션의 작업 스레드가 처리하는 개별작업이 테스트 프로그램의 가상개별 작업과 다른 특성을 갖고 있다면 성능상의 병목이 어느지점인지 파악할때 전혀 엉뚱한 지점을 지목하게 될 수도 있다.
- 11.5에서 살펴본바가 있지만 synchronizedMap 메소드로 생성한 락 동기화 기반의 Map을 놓고 봤을때 락을 확보하려는 부분에서 스레드간의 경쟁이 많이 발생하느냐 별로 발생하지 않는냐의 차이가 성능 측정치에 영향을 미친다.
- 단 2개의 스레드만을 사용하는 경우에도 Map에 접근하려는 거의 모든 경우에 스레드 간의 경쟁이 발생했다.
- 애플리케이션의 작업 구조상 공유된 데이터에 접근해 사용하는 부분보다 스레드 내부 작업의 양이 상대적으로 많다고 하면 스레드 경쟁 정도가 크게 떨어지고, 경쟁이 적어지니 전반적으로 괜찮은 성능을 낼 수 있을 것이다.
- 이런 관점에서 보면 TimedPutTakeTest 테스트 프로그램에서 사용했던 모델은 일부 애플리케이션 구조를 묘사하기에는 그다지 훌륭하지 못하다고 볼수 있다.
- 스레드 내부에서 별다른 작업을 하지 않기 때문에 성능 측정치는 스레드 간의 경쟁 정도에 좌우되며, 프로듀서와 컨슈머 간에 큐를 사용해 데이터를 주고 받는 어플리케이션 모두가 이와 같이 스레드 내부의 작업이 적다고 볼 수는 없기 때문이다.

### 의미 없는 코드 제거 
- 최적화 컴파일러는 의미 없는 코드를 제거하는데 뛰어난 능력을 갖고 있으며, 따라서 훌륭한 성능 측정 프로그램을 작성하는 일이 그다지 쉬운일은 아니다. 일반적으로 성능 측정을 하는 동안에는 실제적인 계산 작업을 거의 하지 않기 때문에 최적화 컴파일러 입장에서는 1차 제거 대상이 될 수 도있다.
- 성능 측정 프로그램을 싱행하는 경우에는 최적화 된 이후 예상했던 것보다 훨씬 적은 코드마이 실행될 수 있기 때문에 큰 문제가 되기도 한다. 오류를 범할 수 있음
- 의미 없는 코드 제거 기능은 정적으로 컴파일하는 언어로 성능을 측정하는 경우에도 비슷한 문제점을 발생
    - 하지만 미리 컴파일괒어을 선행하기때문에 컴파일러가 최적화 과정에서 코드를 얼마만큼 제거해 버렸는지 파악할수 있다.
    - 동적인 컴파일 방법을 사용하는 경우에는 이와같이 컴파일된 기계어 코드를 살펴보기 어려워 이런 정보를 얻기 어렵다.
- 핫스팟 JVM의 클라이언트모드(-client)보다 서버모드(-server)로 실행할때의 결과가 훨씬좋다.
    - 서버모드의 동적컴파일러가 더 효율적인 코드를 생성 할 수 있는것 뿐만 아니라 의미 없는 코드를 최적화하는 능력도 더 나음
    - CPU가 여러개 장착된 시스템에서는 모두 -client 대신 -server 옵션을 지정하는것이 좋다
  
- **훌륭한 성능 측정 프로그램을 작성하려면 최적화 컴파일러가 의미 없는 코드를 제거하는 과정에 성능 측정상 필요한 부분까지 제거하지 않도록 약간의 편법을 써야 할 필요가 있다. 그러려면 프로그램 코드가 만들어 내는 모든 결과값을 프로그램 어디에선가 사용하도록 해야한다. 물론 그때문에 추가적으로 동기화를 해야하거나 더 많은 자원을 소모하도록 하지는 않는것이 좋다.**

ex) PutTakeTest 에서 큐에 추가하거나 큐에서 제거하는 항목마다 체크섬 값을 계산하고 나중에 모든 스레드 체크섬을 합산해 올바르게 동작했는지 확인하는 부분
- 체크섬 실제로 사용하는 부분이 없기때문에 없는 코드로 제거될 가능성이 있다
- 콘솔에 출력하는 기능을 넣어서 실제로 사용하는 값이라는 사실을 최적화 컴파일러에게 알려주자.
- I/O 기능을 호출하면 성능 측정 값에 영향을 줄 수 있으니 성능 테스트를 실행하는 동안에, 특히 시간을 측정하는 동안에는 I/O 기능을 사용하지 않는 편이 좋다.

~~~java
// 두값 일치할 확률 거의 없음
if(foo.x.hashCode() == System.nanoTime())
  System.out.print(" ");
~~~
- 비교문 안에 I/O 를 사용하는 출력문을 적어두면 성능 측정에 영향을 줄 만한 작업은 하지 않으면서 최적화 컴파일러가 의미 없는 코드로 판단해 제거해 버리는 일을 방지 할 수 있다.
- 비교구문 참일 가능 X, 참이되더라도 콘솔에 의미 없는 공백문자 하나만을 출력할 뿐
- 프로그램 내부에서 계산했던 모든 값을 어떤방법으로건 사용해야할 뿐만 아니라 그 사용처를 추측할수 업ㅂㅅ어야 한다
- 괜찮은 최적화 컴파일러가 동작하고 있을때 만약 결과값을 예측 할 수 있다면 최적화 컴파일러가 매번 계산 과정을 실행하는 대신 미리 계산된 값을 사용하기도 한다.
- PutTakeTest 프로그램을 작성할때는 이러한 가능성을 고려하고 작업했지만 정적인 입력값을 갖고 동작하는 테스트 프로그램은 항상 최적화 컴파일러가 미리 계산된 값을 사용 할 수 있다는 사실을 주의해야 한다.

## 12.4 보조적인 테스트 방법
- 테스팅의 목적은 오류를 찾는 일이 아니라 대상 프로그램이 처음 작성할대 설계 했던대로 동작한다는 즉 신뢰성을 높이는 작업이라고 봐야한다.
- 결국 모든 버그를 잡아내는것은 불가능하기 때문에 품질보증 QA 전략으로 항상 가능한 테스트 자원내에서 최대한 신뢰성을 끌어낼 수 있는도록 방향을 잡아야한다.
- 병렬프로그래밍 오류 발생할 확률이 높기때문에 훨씬 많이 테스트해야한다.
- QA 방법론에도 여러가지가 있음 방법을 적절하게 활용하면 오류의 유형에 따라 좀더 효율적으로 오류를 발견할 수 있다
- 코드 리뷰나 정적분석과 같이 상호보완적인 여러가지 테스트 방법을 사용하면 한두가지 방법만 사용했을때보다 프로그램에 대한 신뢰도를 크게 높일 수 있다.

### 코드리뷰
- 병렬 프로그램의 오류를 찾아내고자 할 때 단위테스트와 성능테스트 만큼이나 중요하고 효과적인 테스트 방법은 여려명이 모여서 코드를 살펴보는 코드 리뷰이다.
- 아주 사소한 경쟁조건을 찾아내는등의 일은 여러개의 테스트 프로그램을 작성하는것보다 병렬프로그래밍 전문가가 코드를 들여다 보는 것으로 더 쉽게 찾아내는 경우가 많다.
- 코드 리뷰를 하다보면 그 이외에도 이득을 볼 수 있다. 단순히 문제점을 찾아내는 것 뿐만 아니라 코드 리뷰와
  함께 소스코드의 주석문에 코드에 대한 더 자세한 설명을 추가하는 일을 함께 하면서 나중에 반드시 발생할 유지보수 비용을 낮출수도 있다.

### 정적 분석 도구
- 정적 코드 분석 방법은 코드를 실행하지 않고 그자체로 분석하며, 코드 감사 도구를 사용하면 클래스 파일 내부에 흔히 알려진 여러가지 버그패턴 가운데 해당하는 부분이 있는지를 확인해 준다.
- 오픈소스로 공개된 FindBugs 와 같은 정적 분석도구에는 버그패턴 감지기가 포함돼 있고, 단위테스트나 성능테스트, 코드리뷰등의 과정에서 빼먹기 쉬운 다양한 종류의 일반적인 코딩 오류를 발견할 수 있다.
- 정적 분석 도구를 실행시키면 경고할만한 부분을 목록으로 리포팅 해주며, 리포팅된 부분이 오류인지 아닌지는 반드시 사람이 직접 확인해야한다.

- **일반적이지 않은 동기화**
- **Thread.run 호출**
- **해제되지 않은 락**
- **빈 synchronized 블록**
- **더블 체크락**
- **생성 메소드에서 스레드 실행**
- **알림 오류**
- **조건부 대기 오류**
- **Lock과 Condition의 오용**
- **락을 확보하고 대기 상태 진입**
- **스핀 반복문**

### 관점 지향 테스트 방법
- 지금 시점까지는 관점 지향 프로그래밍 AOP 기법이 병렬프로그래밍 분야에 적용되는 사례는 굉장히 제한적이었다.
- AOP 도구가 아직은 동기화 관련 지점에서 포인트 컷을 지원하지 않고 있기 때문이다.
- AOP를 사용하면 상태변수의 값이 동기화 정책에 잘 맞는지 확인하는등의 작업을 하도록 적용 해 볼 수 있겠다
- AOP의 특성상 코드를 따로 변경할 필요가 없으니 이런 기법은 적용하기에도 간편하고, 사소한 변수공개상황이나 스레드 한정오류와 같은 부분을 찾아내기 좋다.

### 프로파일러와 모니터링 도구
- 대부분 상용 프로파일링 도구에는 스레드의 동작 상황을 살펴 볼 수 있는 모듈이 포함돼 있다.
- 각 제품마다 기능과 효율성등이 서로 다르지만 테스트 대상 프로그램이 도대체 무슨일을 하고있는지에 대한 내부적인 정보를 들여다 보는 좋은 방법이다.
- 대부분 각 스레드의 실행상태를 여러가지 색으로 구분해 시간이 지나감에 따라 어떻게 실행되는지를 표시하는 기능을 갖고있다.
- 이와같은 결과 그래프를 보면 프로그램이 CPU 를 얼마나 충분하게 활용하고있으며 충분히 사용하지 못한다면 어디에 그원인이 있는지도 대략적으로 알려준다.
- 자바에 내장된 JMX 에이전트를 사용하는것도 제한적이나마 스레드의 상태를 모니터링 할 수 있는 방법이다.

## 요약
- 병렬 프로그램이 올바르게 동작하는지 테스트하는 일은 어려운 작업이다.
- 병렬 프로그램에서 발생하는 오류는 대부분 발생 확률이 아주 작은 타이밍 문제, 부하문제, 아니면 기타 쉽게 발현되지 않는 여러원인에 의해 발생하기 때문이다.
- 성능을 테스트하는 일도 어렵다
- 성능을 측정할떄 실행 시간이 동적인 컴파일, 가비지 컬렉션, 그리고 각종 최적화 방법 때문에 크게 변경될 수 있으며, 따라서 의도했던 대로 시간을 측정하기 어렵기 떄문이다.
- 숨어있는 버그를 상용서비스 이전에 발견할수 있는 가장 좋은 방법은 전통적인 테스트방법과 함께 코드리뷰나 자동화된 분석 도구를 사용하는 방법이다.
- 각 방법은 모두 다른 방법이 잘 찾아내지 못하는 오류를 찾아낼수 있으니, 다양한 방법을 동원해 테스트해야 오류를 최대한 줄일 수 있다.


## 참고
책 자바 병렬 프로그래밍 12장