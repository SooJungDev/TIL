## 12장 내용
- 12.1 정확성 테스트
- 12.2 성능 테스트
- 12.3 성능 측정의 함정 피하기
- 12.4 보조적인 테스트 방법

## 12.1 정확성 테스트
- 병렬프로그램을 테스트한 결과는 전통적으로 사용해왔던 문제 상호아인 안전성과 활동성의 문제로 귀결된다.
- 이미 안좋은 일이 발생하지 않는 상황을 안전성이라가호 결국에는 좋은일이 발생하는 상황을 활동성이라고 정의한바 있다.
- 활동성liveness은 그 특성상 테스트하기에 어려운 점이 많다. 활동성 테스트를 하다가 보면 진행중인 상태와 진행이 멈춘 상태를 테스트하는 경우가 많다. 
- 활동성 문제를 테스트하는것은 성능 문제를 테스트하는것과 밀접한 관련이 있다.
  - 처리량(throughtput) : 병렬로 실행되는 여러개의 작업이 각자 할일을 끝내는 속도
  - 응답성(responsiveness) : 요청이 들어온 이후 작업을 마치고 결괄르 줄 때까지의 시간. 지연 시간이라고도 한다.
  - 확장성(scalability): 자원을 더 많이 확보할때마다 그에 따라 처리할 수 있는 작업량이 늘어나는 정도
~~~java
@ThreadSafe
public class BoundedBuffer<E> {
    private final Semaphore avaliableItems, avaliableSpaces;
    @GuardedBy("this")
    private final E[] items;
    @GuardedBy("this")
    private int putPosition = 0, takePosition = 0;

    public BoundedBuffer(int capacity) {
        avaliableItems = new Semaphore(0);
        avaliableSpaces = new Semaphore(capacity);
        items = (E[]) new Object[capacity];
    }

    public boolean isEmpty() {
        return avaliableItems.availablePermits() == 0;
    }

    public boolean isFull() {
        return avaliableSpaces.availablePermits() == 0;
    }

    public void put(E x) throws InterruptedException {
        avaliableSpaces.acquire();
        doInsert(x);
        avaliableItems.release();
    }

    public E take() throws InterruptedException {
        avaliableItems.acquire();
        E item = doExtract();
        avaliableSpaces.release();
        return item;
    }

    private synchronized void doInsert(E x) {
        int i = putPosition;
        items[i] = x;
        putPosition = (++i == items.length) ? 0 : i;
    }

    private synchronized E doExtract() {
        int i = takePosition;
        E x = items[i];
        items[i] = null;
        takePosition = (++i == items.length) ? 0 : i;
        return x;
    }
}
~~~

### 가장 기본적인 단위 테스트
~~~java
class BoundedBufferTest extends TestCase{
    void testIsEmptyWhenContructed() {
        BoundedBuffer<Integer> bb = new BoundedBuffer<>(10);
        assertTrue(bb.isEmpty());
        assertFalse(bb.isFull());
    }
    
    void testIsFullAfterPuts() throws InterruptedException{
        BoundedBuffer<Integer> bb = new BoundedBuffer<>(10);
        for(int i=0; i<10; i++)
            bb.put(i);
        assertTrue(bb.isFull());
        assertFalse(bb.isEmpty());
    }
}
~~~
- BoundedBuffer 클래스의 기능을 테스트를 하는 기본 테스트 케이스
- 본 테스트 메소드는 전적으로 순차적으로 동작하는 상황을 테스트한다.
- 이와 같이 순차적으로 동작하는 테스트 케이스를 작성해두면 데이터를 놓고 경쟁이 발생하는 상황을 테스트하기 이전에 테스트 케이스에서 발생한 오류가 멀티스레드 환경에서 발생한 오류가 아니라는 점을 확인 할 수 있다는 점에서 유용한 면이 있다.

### 블로킹 메소드 테스트
- java.util.concurrent 패키지에 대한 표준 부합 테스트를 진행 할 때 실패건이 발생하는 경우에 어떠 ㄴ테스트에서 실패했는지를 정확하게 파악하는 일이 굉장히 중요했다. 따라서 테스트 케이스에서 실패하는 상황이 발생했을대 해당건을 모아뒀다가 tearDown 메소드에서 모든 오류 상황을 표시하는 기능을 구현한 기반의 클리스를 하나 구현했다.
- 대기 상태에 들어가는 메소드를 테스트 할 때에는 여러가지 복잡한 사항이있다.
- 이런 테스트를 할 수 있는 가장 확실한 방법은 인터럽트를 거는 방법이다.
  
~~~java
    void testTakeBlocksWhenEmpty() {
        BoundedBuffer<Integer> bb = new BoundedBuffer<>(10);
        Thread taker = new Thread() {
            public void run() {
                try {
                    int unused = bb.take();
                    fail(); // 여기 들어오면 오류
                } catch (InterruptedException success) {}

            }
        };
        try {
            taker.start();
            Thread.sleep(LOCKUP_DETECT_TIMEOUT);
            taker.interrupt();
            taker.join(LOCKUP_DETECT_TIMEOUT);
            assertFalse(taker.isAlive());
        } catch (Exception unexpected) {
            fail();
        }
    }
~~~
- 대기 상태와 인터럽트에 대한 대응을 테스트하는 루틴
- 아무것도 없을때 take 메소드를 호출하면 대기 상태에 들어가야한다는것뿐만 아니라 대기중에 인터럽트가 걸리면 InterruptedException을 발생시켜야 한다는 기능도 테스트 할 수 있다.
- join 메소드를 사용해 정상적으로 종료되는지 확인하는 작업은 Runnable 인터페이스를 구현하는 대신 Thread 클래스를 직접 상속받아 사용하는 편이 더 나은 몇 안되는 방법중에 하나이다.
- 테스트 프로그램에서 버퍼에 항목을 직접 추가하면서 항목이 추가되는 시점에 대기 상태에 들어가 있던 taker 스레드가 정상적으로 대기상태에서 빠져나오는지 확인 할 수 있다.
- Thread.getState 메소드 사용하는 방법 X, 특정스레드가 대기상태에 들어갔다고해서 항상 WAITING, TIMED_WAITING 상태에 놓여 있다고 생각할 수 없다.
- 따라서 병렬성을 제어하는 용도로 Thread.getState 메소드를 사용하지 말아야하며 일반적인 테스트 프로그램에서도 그다지 유용하지 않다.

### 안전성 테스트
- **안전성을 테스트하는 프로그램을 효과적으로 작성하려면 뭔가 문제가 발생했을때 잘못 사용되는 속성을 높은 확률로 찾아내는 작업을 해야함과 동시에 오류를 확인하는코드가 테스트 대상의 병렬성을 인위적으로 제한해서는 안된다는 점을 고려해야한다. 테스트하는 대상속성의 값을 확인할때 추가적인 동기화 작업을 하지 않아도 된다면 가장 좋은상태라고 볼 수 있다.**

- 프로듀서-컨슈머 디자인 패턴을 사용해 동작하는 클래스가 가장 적합한 방법은 큐나 버퍼에 추가된 항목을 모두 그래도 뽑아 낼 수 있는지 확인하고, 그외에는 아무런 일도 하지 않는지를 확인하는 방법
- 2가지 방법이있는 체크섬 방법으로 테스트
- 큐에 들어가고 나오는 항목의 체크섬을 구한다음 순서를 유지하는 체크섬의 형태로 관리하고 쌓인 체크섬을 비교해 확인하는 방법이 있다. 만약 체크섬 비교시 양쪽동일하면 테스트 통과
- 이방법을 다수의 프로듀서 컨슈머가 연결돼 있는 구조에서 사용하려면 사용하려면 항목이 추가되는 순서와 상관없는 체크섬 방법을 사용해야하며, 마지막에 체크섬을 모두 합해 볼 수 있어야한다.
- 그렇지 않으면 체크섬 계산하는 부분을 동기화하느니라 확장성측면에서 병목이 나타날 수 있고, 그러다보면 테스트에 걸리는시간 제대로 체크하지 못한다.
- 작성된 테스트 프로그램이 원하는 내용을 테스트하는지 확인하려면 사용하고 있는 체크섬 연산을 컴파일러가 예측할 수 없는 연산인지도 확인해야한다.
- 컴파일러가 최적화를 충분히 할수 잇는 능력이 있다면 결괄르 미리 계산해 버릴 숟도 있다.
- 테스트에 사용할 일련번호 대신 임의의 숫자를 만들어 사용 , 너무 허술하면 테스트 결과가 잘못나올수 있다.
  
~~~java
   static int xorShift(int y) {
        y ^= (y << 6);
        y ^= (y >>> 21);
        y ^= (y << 7);
        return y;
 }
~~~
- 테스트 프로그램에서 적합한 중간 품질의 난수 발생기



~~~java
public class PutTaskTest {
    private static final ExecutorService pool = Executors.newCachedThreadPool();
    private final AtomicInteger putSum = new AtomicInteger(0);
    private final AtomicInteger takeSum = new AtomicInteger(0);
    private final CyclicBarrier barrier;
    private final BoundedBuffer<Integer> bb;
    private final int nTrials, nPairs;

    public static void main(String[] args) {
        new PutTaskTest(10, 10, 100000).test(); // 예제 인자 값
        pool.shutdown();
    }

    putTakeTest(int capacity, int npairs, int ntirals) {
        this.bb = new BoundedBuffer<>(capacity);
        this.nTrials = ntirals;
        this.nPairs = npairs;
        this.barrier = new CyclicBarrier(npairs * 2 + 1);
    }

    void test() {
        try {
            for (int i = 0; i < nPairs; i++) {
                pool.execute(new Producer());
                pool.execute(new Consummer());
            }
            barrier.await(); //모든 스레드가 준비될때까지 대기
            barrier.await(); //모든 스레드가 작업이 끝날까지 대기때
            assertEquals(putSum.get(), takeSum.get());
        } catch (Exception e) {
            throw RuntimeException(e);
        }
    }

    class Producer implements Runnable{/*예제 12.6*/}

    class Consummer implements Runnable{{/*예제 12.6*/}

}
~~~
- BoundedBuffer 테스트하는 프로듀서-컨슈머 구조의 테스트 프로그램


~~~java
    class Producer implements Runnable {
        @Override
        public void run() {
            try {
                int seed = (this.hashCode() ^ (int) System.nanoTime());
                int sum = 0;
                barrier.await();
                for (int i = nTrials; i > 0; i--) {
                    bb.put(seed);
                    sum += seed;
                    seed = xorShift(seed);
                }
                putSum.getAndAdd(sum);
                barrier.await();

            } catch (Exception e) {
                throw RuntimeException(e);
            }
        }
    }

    class Consummer implements Runnable {
        @Override
        public void run() {
            try {
                barrier.await();
                int sum = 0;
                for (int i = nTrials; i > 0; i--) {
                    sum += bb.take();
                }
                putSum.getAndAdd(sum);
                barrier.await();

            } catch (Exception e) {
                throw RuntimeException(e);
            }
        }
    }
~~~
- PutTakeTest 에서 사용한 프로듀서 클래스와 컨슈머 클래스

- 각 스레드는 큐에 항목을 추가하거나 제거할떄마다 각 스레드에마다 나눠져 있는 각자의 체크섬을 업데이트하고, 각자의 체크섬은 테스트가 끝나는 시점에 하나로 합해 결과가 올바른지 테스트한다.
- 각 스레드마다 체크섬을 따로 운영하면 따로 동기화할 피룡도 없고 경쟁이 발생하지 않으므로 실제 원하는 테스트에 집중할 수 있다.
- CountDownLatch 를 사용해 모든 스레드가 준비될때까지 대기하고 또다른 CountDownLatch를 사용해 모든 스레드가 완료할때까지 대기하는 방법을 사용한다.
- PutTaskTest와 같은 유형의 테스트 프로그램은 테스트의 안전성을 확인하기에는 좋다
  
- **테스트 프로그램은 스레드가 교차 실행되는 경우의 수를 최대한 많이 확보 할 수 있도록 CPU가 여러개 장착된 시스템에서 돌려보는게 좋다 그렇다고 CPU가 수십개 달렸다고 해서 서너개의 CPU가 장착된 시스템에 비해 테스트 효율이 좋아진다고 보기는 어렵다 절묘한 타이밍에 공유된 데이터를 사용하다 나타나는 오류를 찾으려면 CPU가 많이 있는것보다 스레드를 더 많이 돌리는 편이 낫다. 스레드가 많아지면 실행중인 스레드와 대기상태에 들어간 스레드가 서로교차하면서 스레드간의 상호작용이 발생하는 경우의 수가 많아지기 때문이다.**


- 미리 지정된 개수만큼 연산을 실행하고 테스트틀 마치는 프로그램은 테스트 도중에 예외가 발생하는등의 상황에 마주치면 테스트 프로그램이 종료되지 않고 계속해서 실행될 가능성이 있다.
- 이런 부분을 방지할 수 있는 간편한 방법은 테스트 프로그램이 동작하는 시간에 제한을 두고 제한된 시간이 넘어가도 프로그램이 종료되지 않으면 테스트를 중단하도록 하는 방법이다.
- 제한시간은 경험적인 시간으로 정하는 수 밖에 없고 만약 제한시간을 넘기는 문제가 발생한다면 실제로 프로그램에 오류가 있는건지 아니면 좀더 오래 기다렸어야 하는지를 분석해서 확인해야한다.


### 자원관리 테스트
- 테스트 프로그램으로 테스트하고자 하는 두번째 측면이있는떼 바로 하지 말아야할 일을 실제로 하지 않는지 테스트하는 일이다. ex) 자원 유출하는일
- 다른 객체를 사용하거나 관리하는 모든 객체는 더이상 필요하지 않은 객체에 대한 참조를 필요 이상으로 긴 시간동안 갖고 있어서는 안된다.
- 이처럼 데이터를 갖고 있는 객체의 참조를 해제하지 않고 유출되면 가비지 컬렉터가 메모리를 확보할 수 없다. 따라서 결국에는 자원이 모자라게 되고 프로그램에서는 오류가 발생한다.
- 메모리를 원하지 않음에도 불구하고 계속해서 잡고 있는 경우가 있는지 확인하려면 어플리케이션이 사용하는 메모리의 상황을 들여다 볼 수 있는 힙조사용도구를 사용해볼만 하다.
~~~java
class Big {
    double[] data = new double[100000];
}

void testLeak() throws InterruptedException{
    BoundedBuffer<Big> bb = new BoundedBuffer<Big>(CAPACITY);
    int heapSize1 = /*힙 스냅샷*/;
    for(int i=0; i< CAPACITY; i++)
        bb.put(new Big());
    for(int i=0; i< CAPACITY; i++) 
        bb.take();
    int heapSize2 = /*힙 스냅샷*/;
    assertTrue(Math.abs(heapSize1-heapSize2) < THRESHOLD);
}
~~~
- 자원 유츌 테스트
- 힙 조사 도구가 추가한 코드는 가비지 컬렉션을 강제로 실행하고 힙 사용량과 기타 메모리 사용 현황을 불러오는 기능을 담당한다.
- testLeak 메소드는 크기가 제한된 버퍼에 상당한 메모리를 차지하는 객체를 여러개 추가하고 추가된 객체를 제거한다.
- 1,2번 거의 차이가 없어야 된다. 그런데 예를들어 doExtract 메소드에서 뽑혀나간 객체를 담고있던 부분을 참조 null로 세팅하지 않았다면 양쪽지점에서 측정한 메모리가 다를것이다.

### 콜백 사용
- 클라이언트가 제공하는 코드에 콜백 구조를 적용하면 테스트 케이스를 구현하는데 도움이 된다./
~~~java
class TestingThreadFactory implements ThreadFactory{
    public final AtomicInteger numCreated = new AtomicInteger();
    private final ThreadFactory factory = Executors.defaultThreadFactory();

    public Thread newThread(Runnable r){
        numCreated.incrementAndGet();
        return factory.newThread(r);
    }
}
~~~
- ThreadPoolExecutor를 테스트하기 위한 TestingThreadFactory
- 생성된 스레드의 개수를 세는 기능을 갖고있음

~~~java
    public void testPoolExpansion() throws InterruptedException {
        int MAX_SIZE = 10;
        TestingThreadFactory threadFactory = new TestingThreadFactory();
        ExecutorService exec = Executors.newFixedThreadPool(MAX_SIZE, threadFactory);

        for (int i = 0; i < 10 * MAX_SIZE; i++) {
            exec.execute(new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep(Long.MAX_VALUE);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            });
        }
        for (int i = 0; i < 20 && threadFactory.numCreated.get() < MAX_SIZE; i++) 
            Thread.sleep(100);
        assertEquals(threadFactory.numCreated.get(), MAX_SIZE);
        exec.shutdownNow();
    }
~~~
- 스레드 풀의 스레드 개수가 제대로 늘어나는지 확인 할 수 있는 테스트 케이스
- 예를 들어 코어 풀 크기가 최대 풀 크기보다 작게 설정돼있다면 실행할 대상이 늘어날때마다 스레드의 개수가 함께 늘어나야한다.
- 스레드 풀에 오래 실행될 작업을 많이 추가해두면 스레드 개수가 올바르게 늘어나는지등의 수치를 확인하기에 충분할 만큼 어느 정도 시간을 벌어주는 역할을한다.

### 스레드 교차 실행량 확대
- CPU 프로세서가 장착된 하드웨어에서 CPU의 개수보다 많은 수의 스레드로 동작하는 프로그램이 단일 CPU 하드웨어에서 CPU의 개수가 많은 하드웨어에서 동작하는 프로그램보다 교차 실행 되는 양이 훨씬 많다는 점을 언급했다.
- 스레드의 교차 실행 정도를 크게 높이고 그와 동시에 테스트 할 공간을 크게 확대 시킬 수 있는 트릭이 있음
- 공유된 자원에서 Thread.yield 메소드를 호출해 컨텍스트 스위치가 많이 발생 할 수 있도록 유도 할 수 있다.
~~~java
    public synchronized void transferCredit(Account from, Account to, int amount){
        from.setBalance(from.getBalance() - amount);
        if(random.nextInt(1000) > THRESHOLD)
            Thread.yield();
        to.setBalance(to.getBalance() + amount);
    }
~~~
- Thread.yield 메소드를 사용해 교차 실행 가능성을 높이는 방법
- Thread.yield 메소드를 호출해주면 공유된 데이터를 사용할때 적절한 동기화 방법을 사용하지 않는 경우 특정한 타이밍에 발생 할 수 있는 버그가 실제로 노출되는 가능성을 높일 수 있다.
- Thread.yield 메소드를 호출하는 코드와 같이 테스트 할떄 사용하다가 상용으로 사용할때는 해당 코드를 제거해야하는 경우 AOP 기법을 활용해 간편하게 처리할 수 있다.

## 12.2 성능 테스트
- 성능 테스트 프로그램은 대부분 기능 테스트의 확장된 버전인 경우가 많다.
- 성능 테스트는 특정한 사용 환경 시나리오를 정해두고, 해당 시나리오를 통과하는데 얼마만큼의 시간이 걸리는지를 측정하고자 하는데 목적이있다.
- 성능 테스트의 두번째 목적은 바로 성능과 관련된 스레드의 개수, 버퍼의 크기등과 같은 각종 수치를 뽑아내고자 함이다.

### PutTakeTest에 시간 측정 부분 추가
- 실행하는데 걸린 시간을 측정하는 기능
- 배리어에서 시간을 측정하는 기능을 갖고있는 배리어 액션을 사용하도록 하면 CyclicBarrier를 초기화하는 부분에 다음과 같이 원하는 배리어 액션을 지정한다
~~~java
this.timer = new BarrierTimer();
this.barrier = new CyclicBarrier(npairs * 2 + 1, timer);
~~~

~~~java
public class BarrierTimer implements Runnable {
    private boolean started;
    private long startTime, endTime;

    @Override
    public synchronized void run() {
        long t = System.nanoTime();
        if (!started) {
            started = true;
            startTime = t;
        } else {
            endTime = t;
        }
    }

    public synchronized void clear(){
        started = false;
    }
    public synchronized long getTime(){
        return endTime - startTime;
    }
}
~~~
- 배리어 기반의 타이머
  
~~~java
    public void test(){
        try{
            timer.clear();
            for(int i=0; i<nPairs; i++){
                pool.execute(new Producer());
                pool.execute(new Consumer());
            }
            barrier.await();
            barrier.await();
            long nsPerItem = timer.geteTime() / (nPairs * (long)nTrials);
            System.out.print("Throughput:"+nsPerItem+" ns/item");
            assertEquals(putSum.get(), takeSum.get());
        }catch (Exception e){
            throw new RuntimeException(e);
        }
    }
~~~
- 배리어 기반 타이머를 사용한 테스트

~~~java
    public static void main(String[] args) throws Exception {
        int tpt = 10000; // 스레드별 실행 횟수
        for (int cap = 1; cap <= 1000; cap *= 10) {
            System.out.println("Capacity:"+ cap);
            for(int pairs = 1; pairs<=128; pairs *=2){
                TimedPutTaskTest t = new TimedPutTaskTest(cap, pairs, tpt);
                System.out.println("Pairs: "+ pairs+"\t");
                t.test();
                System.out.println("\t");
                Thread.sleep(1000);
                t.test();
                System.out.println();
                Thread.sleep(1000);
            }
        }
        pool.shutdown();
    }
~~~
- TimedPutTaskTest 실행 프로그램
- TimedPutTaskTest을 실행해보면 몇가지 결과를 얻을 수 있다. 먼저 여러가지를 설정을 사용했을때 프로듀서와 컨슈머가 데이터를 얼마나 빠르게 넘겨줄 수 있느냐 하는 수치를 얻을 수 있다.
- 그리고 스레드의 개수가 많아질때 크기가 제한된 버퍼가 얼마나 확장성을 받쳐주는지 알아 볼 수 있다.
- 또한 버퍼의 크기를 얼마로 제한해야 최고의 선능을 내는지도 알아 볼 수 있다.

- 그림 12.1을 보면 cpu4개가 장착된 하드웨어에서 버퍼의 크기를 1,10,100,1000 으로 변경하면서 실행한 결과가 그래프로 나타나져잇음
- 버퍼 크기가 1이면 성능이 크게 떨어진다는 사실을 알수 있음
- 버퍼 크기가 1인 경우 각 스레드가 대기상태에 들어가고 나오면서 아주 적은양의 작업밖에 할 수 가 없기때문에 성능이 떨어지는것은 당연하다.
- 여기에서 버퍼크기만 늘려주면 성능은빠르게 증가하자만 10을 넘는 크기를 지정하면 버퍼의 크기에 비해 성능이 향상되는 정도가 떨어지는것을 볼 수 있다.
- 하지만 이와 같은 결괄르 놓고 크기가 제한된 버퍼를 사용하는 프로듀서-컨슈머 패턴의 구조라면 언제든지 스레드를 추가해도 좋다는 방향으로 해석하는것은 조심해야한다. 실제어플리케이션이 동작하는 과정에서 무시할 수 없을만큼 상당한 작업이 이뤄지기 떄문이다.
- TimedPutTaskTest 주 목적은 프로듀서-컨슈머 패턴 프로그램에서 프로듀서와 컨슈머간에 값을 넘겨줄때 얼마만큼 성능을 낼수 있는지 병목이있다면 어디에있는지 알아내는 정도에 그친다는 사실을 알아둬야된다

### 다양한 알고리즘 비교
- BoundedBuffer 클래스 ArrayBlockingQueue나 LinkedBlockingQueue 등의 클래스에 비해서는 성능이 떨어진다. 
- java.util.concurrent 패키지에 포한돼 있는 클래스의 알고리즘은 주의깊게 선택하고 튜닝돼 있다.
- BoundedBuffer 클래스의 속도가 떨어지는 가장 큰 이유는 바로 put, take 연산 양쪽에서 모두 스레드 경쟁을 유발 할 수 있는 연산, 예를 들어 세마포어를 확보하거나 락을 확보하고 세마포어를 다시 해제하는 등의 연산을 사용하기 떄문이다. 고성능 클래스가 사용하는 알고리즘을 보면 스레드간의 경쟁을 유발 할 수 있는 부분이 훨씬 적다.
-  그림 12.2보면 TimedPutTakeTest 테스트 프로그램을 약간 변형시키고, 듀얼 하이퍼스레드 CPU가 장착된 하드웨어에서 버퍼크기가 256인 클래스 3개를 비교 실행한 결과이다. 이 테스트 결괄르 보면 LinkedBlockingQueue 클래스가 ArrayBlockingQueue 보다 확장성이 약간 더 좋다고 보이는데, 언뜻 생각하기에는 이상한 결과라고 의삼 할 수 있음
-  연결 큐 linked queue는 새로운 항목을 추가할때마다 버퍼 항목을 메모리에서 새로 할당받아야하며, 따라서 배열 기반의 큐보다 많은 일을 해야하기 때문이다.
-  그런데 객체를 할당하는 부하가 더 크고 가비지 컬렉션에 부하가 더 걸린다고 해도 잘 튜닝된 연결리스트 알고리즘을 사용하면 큐의 처음과 끝 부분에 서로 다른 스레드가 동시에 접근해 사용할 수 있다.
-  따라서 연결리스트 기반의 큐는 put과 take 연산에 대해서 배열 기반의 큐보다 병렬처리 환경에서 훨씬 안정적으로 동작한다.
-  그리고 메모리 할당작업은 일반적으로 스레드 내부에 한정돼 있기 때문에 메모리를 할당한다해도 스레드간의 경쟁을 줄일 수 있는 알고리즘의 확장성이 더 높을 수 밖에 없다
    -  전통적인 성능 튜닝 방법과 관련해 알고 있던 상식이 확장성의 측면에서는 오히려 성능이 떨어지는 결과를 가져올 수 있는 사례이다.

### 응답성 측정
- 일부 상황에서는 단일 작업을 처리하는데 얼마만큼의 시간이 걸리는지 측정하는지 더 중요한 경우도 있다.
- 그리고 단일 작업을 처리하는데 얼마만큼의 시간이 걸리는지를 측정하는 일이 더 중요한 경우도 있다.
- 그리고 단일 작업처리 시간을 측정할때는 보통 측정값의 분산을 중요한 수치로 생각한다.
- 예측성 역시 중요한 성능지표 가운데 하나임 처리시간에 대한 분산을 구해보면 100밀리초 안에 작업을 끝내는 비율이 몇 %정도인가? 와 같은 서비스 품질에 대한 수치를 결과로 제시할 수 있다.
- 서비스 시간에 대한 분산을 시각적으로 표현 할 수 있는 가장 효과적인 방법은 바로 작업을 처리하는데 걸리는시간을 히스토그램으로 그려보는 방법이다.
- 분산은 작업 처리 시간을 모두 더할 뿐만 아니라 각 처리 시간을 목록으로 관리하고 있어야한다.
- 그런데 개별 작업을 처리하는 속도가 아주 빠르다면 통계값에 오류가 생기기 쉽다
- 이런 오류를 방지 할 수 있도록 put과 take등의 연산을 일정 개수로 묶어 일괄처리하고, 일괄처리하는데 걸린 시간을 하나의 작업 시간으로 묶어서 생각하도록 하자.

- 그림 12.3 보면 한쪽은 공정한 세마포어를 사용하고 다른한쪽은 불공정 세마포어를 사용해 테스트 결과가 나타났다.
- 최소시간과 최대시간의 차이는 최대 80배가 넘는다.
- 최소시간과 최대 시간의 차이를 줄이려면 동기화 코드에서 공정성을 높이면 된다. BoundedBuffer 의 경우 세마포어를 생성할때 공정한 모드로 초기화 시켜 공정성을 높일 수 있다.
- 동기화 부분의 공정성을 높이고 나면 처리시간의 분사값을 엄청나게 줄여주는 효과를 볼 수 있지만 처리 속도가 크게 떨어진다는 역효과를 가져온다.
- 버퍼 크기를 굉장히 작게 잡고 사용한다면 매번 연산마다 모두 컨텍스트 스위칭이 발생하고, 따라서 컨텍스트 스위칭 부하가 엄청나게 늘어나서 결국 불공정 동기화 방법을 사용한다해도 실행속도가 크게 느려진다는 사실을 살펴본바 있다.
- 공정하기 때문에 속도가 느려지는 상황은 스레드가 대기상태에 들어가기 때문이라고 생각할 수 있다.
- 따라서 이번테스트에서 버퍼 크기를 1로 지정하고 다시 실행해보면 불공정한 세마포어를 사용해도 공정한 세마포어를 사용한 경우와 거의 비슷한 속도로 느려진다는 결과를 얻는다.
- 그림 12.4 를 보면 이 경우 공정함의 문제가 평균 실행시간을 크게 늦추거나 실행 시간의 분산을 훨씬 낮게 바꿔주지 못한다는 사실이 나타나 있다.
- 결국 스레드가 대기상태에 들어가는 상황이 아니라면 불공정한 세마포어를 사용해 처리 속도를 크게 높일 수 있고 반대로 공정한 세마포어를 사용해 처리 시간의 분산을 낮출 수 있다. 공정성 문제로 속도가 빨라지거나 분산값이 줄어드는 정도가 굉장히 심한편이기 떄문에 세마포어를 사용할때는 항상 어느방법을 사용할껀지 결정해야한다.

## 12.3 성능 측정의 함정 피하기
- 실제로 테스트 프로그램을 작성할때는 성능을 올바로 나타내지 못하는 수치를 뽑아내는 잘못된 코딩 방법으로 프로그램을 작성하지 않도록 주의해야 한다.

### 가비지 컬렉션
- 가비지 컬렉션이 언제 실행된것인지 미리 알고 있을수 없으며, 시간을 측정하는 테스트 프로그램이 동작하는 동안 가비지 컬렉션 작업이 진행될 가능성도 높다.
- 실행할때 가비지 컬렉션이 진행됬다면, 실행 횟수를 살짝 변경하기만 해도 테스트당 실행시간은 엉터리 값으로 바뀔수 있다

가비지 컬렉션때문에 테스트 결과가 올바르지 않게 나오는 경우를 막을 수 있는 두가지방법
- 테스트가 진행되는 동안 가비지 컬렉션이 작업이 실행되지 않도록 하는 방법이 있음
- 테스트가 진행되는 동안 가비지 컬렉션 여러번 실행된다는 사실을 명확히 하고 테스트 결과에 객체 생성 부분이나 가비지 컬렉션 부분을 적절하게 반영하도록 하는 방법
    - 후자를 많이 택함, 테스트 프로그램을 훨씬 긴 시간동안 실행 할 수 있으며 실제 상황에서 나타나는 성능을 좀더 가깝게 반영하기 때문이다.
  
- 프로듀서-컨슈머 패턴으로 구성된 어플리케이션은 상당한 양의 객체를 메모리에 할당하고 가비지 컬렉션 부하도 큰편이다. 
- 따라서 BoundedBuffer 클래스를 대상으로 테스트 프로그램을 적당히 오랜시간 동안 동작시키면 일정 횟수 이상 가비지 컬렉션이 동작할 것이며, 실제 적용할때와 유사한 성능 결괄르 얻을수 있다.

### 동적 컴파일
- 자바 언어와 같이 동적으로 컴파일하면서 실행되는 언어로 작성된 프로그램은 c,c++ 와 같이 정적으로 컴파일된 상태에서 실행되는 언어로 만들어진 프로그램보다 성능을 측정하기 어렵고 결과를 해석하는것도 어렵다.
- 핫스팟 JVM이나 기타 사용되는 JVM은 바이터 코드 인터프리트 방식과 동적 컴파일 방법을 혼용해 사용한다.
    - ex) 클래스의 바이트코드 읽어들인다음 -> 인터프리터를 통해 바이트 코드 실행 
    - 일정시점이 지난이후 메소드가 특정횟수 이상 자주 실행된다면 동적 컴파일러가 해당 메소드를 기계어 코드로 컴파일한다.
    - 컴파일이 완료되면 그 이후에는 인터프리트하는 대신 컴파일된 코드를 직접 실행시킨다.
- 테스트 프로그램이 시간을 측정하는 도중에 컴파일러가 동적으로 메소드 코드를 컴파일하도록 놔둔다면 두가지 측면에서 결과에 오류가 생길 가능성이있다.
    - 컴파일 하는 과정에서 CPU를 상당히 소모, 또한 인터프리트되는 코드와 컴파일된 코드, 컴파일하는 시간모두 테스트 결과에 포함시키면 일관성이 부족한 결과값을 얻을수 밖에 없다.

- A는 컴파일하지 않고 계속해서 인터프리터로 실행하는 모습
- B는 인터프리터로 실행하다 중간에 컴파일해 실행되는모습
- C는 B보다 먼저 컴파일을 진행하고 실행되는 모습
- 컴파일 작업이 언제 실행되는지가 전체 실행 시간에 큰 영향을 미치고, 그에 따라 단일 연산에 소모되는 시간역시 영향을 미친다.
  
- 컴파일된 프로그램 코드는 때에 따라 디컴파일하고 다시 재컴파일 하는 과정을 거치는 경우도 있다
    - ex) 이전 컴파일 과정에서 가정했던 사항이 변경됐거나, 아니면 실제로 실행해보면서 얻은 성능평가 결과를 놓고 다른 최적화 방법을 적용해 다시 컴파일 하도록 하기도 한다.
- 컴파일된 코드와 컴파일 되지 않는 코드때문에 성능 측정치가 올바르지 않게 나타나는 상황을 예방하는 가장 간단한 방법은 테스트 프로그램을 긴시간동안 실행시켜 컴파일될 부분은 모두 컴파일되고 추가로 컴파일하거나 인터프리터로 실행되는 코드를 최소화 하는 방법이다
- 다른 방법으로는 시간을 측정하지 않는 워밍업하는 테스트를 한번 미리 실행시켜 필요한 코드를 모두 컴파일시키고, 이후에 시간을 측정하는 실제 테스트 프로그램을 실행시켜 성능 측정치를 뽑아내는 방법도 있다.
- 핫스팟 JVM을 사용하는 경우라면 -XX:+PrintCompilation 옵션을 사용해 동적 컴파일 작업이 실행될때 메세지를 출력시킬 수 있다. 
- 초기에 실행했던 결과는 워밍업 과정이라고 보고 제외하고, 그이후 측정 결과를 봣을때 측정값의 변동이 크다면 똑같은 태스트를 실행하는데 걸리는 시간이 왜 일정하게 유지되지 않는지에 대한 원인을 찾아봐야 할것이다.
- JVM은 내부작업을 처리하기 위해 여러개의 백그라운드 스레드를 사용한다
- 테스트를 여러번 실행하는 사이마다 약간의 쉬는 시간을 두어 JVM이 일상 작업을 처리 할 수 있도록 배려하는것이 좋다
- 그래야 시간을 측정하는 테스트가 진행될때 꼭 해야하는 JVM 내부 작업을 처리하느라 CPU를 소모하고 그로인해 테스트 실행 시간 결과값에 오류가 발생하는일이 줄어든다.

### 비현실적인 코드 경로 샘플링
- 런타임 컴파일러는 컴파일할 코드에 대한 최적화 정보를 얻기 위해 실행 과정에서 여러가지 성능값을 추출한다.
- JVM은 더나은 코드를 생성할 수 있도록 프로그램 실행에 관련된 특정 정보를 사용하기도 한다.
- 어떤 경우에는 JVM이 코드를 컴파일 할때 일시적으로 효과를 발휘할수 있는 몇가지 가정을 설정하고 그에따라 컴파일하기도한다
- 그리고 만약 설정했던 가정이 어느 시점 이후에 올바르지 않은 가정이라고 판단한다면 컴파일한 코드를 무효로하고 새로 컴파일하기도한다.
- 따라서 특정 어플맄케이션에 사용하느 시나리오 패턴만을 묘사해 테스틑하는것보다는 유사한 다른 시나리오 패턴도 한데 묶어서 테스트하는일도 중요한 부분이다
- 이렇게 테스트 하지 않는다면 예를 들어 완전히 단일 스레드에서 동작했어야 할 테스트 프로그램에 동적 컴파일러가 일반적인 서버 어플리케이션처럼 최소한의 병렬성을 필요로하는 상황에 맞게 특별한 최적화 기법을 사용해 코드를 컴파일해 문제가 발생 할 수도 있다.
- 그래서 단일 스레드 프로그램 성능을 테스트하고자 할때도 단일 스레드 프로그램의 성능뿐만 아니라 멀티 스레드 어플리케이션의 성능도 함께 테스트하는것이 좋다.

### 비현실적인 경쟁 수준
- 병럴 어플리케이션은 두종류의 작업을 번갈아가며 실행하는 구조로 동작한다.
- 여러 스레드가 공유하는 큐에서 다음 처리할 작업을 뽑아내는것과 같이 공유된 데이터에 접근하는 종류의 작업이 있고, 큐에서 가져온 작업을 실행한느것과 같이 스레드 내부의 데이터만을 갖고 실행되는 작업이 있다.
- 전체작업을 두 종류의 작업으로 구분해 봤을때 각각 얼마만큼의 비율을 차지하는지에 따라 경쟁의 수준이 달라지고 성능과 확장성 측면에서 굉장히 다른 결과를 내놓게된다.
- 실행 성능은 CPU의 처리 속도에 굉장히 의존하게된다.
- 반대로 개별 작업이 아주 짧은 시간안에 빠르게 실행된다면 작업큐에서 서로 작업을 가져가려고 경쟁이 많이 발생할것이며 전체적인 실행 성능은 동기화 방법에 따라 좌지우지된다.
- 실제 어플리케이션의 작업 스레드가 처리하는 개별작업이 테스트 프로그램의 가상개별 작업과 다른 특성을 갖고 있다면 성능상의 병목이 어느지점인지 파악할때 전혀 엉뚱한 지점을 지목하게 될 수도 있다.
- 11.5에서 살펴본바가 있지만 synchronizedMap 메소드로 생성한 락 동기화 기반의 Map을 놓고 봤을때 락을 확보하려는 부분에서 스레드간의 경쟁이 많이 발생하느냐 별로 발생하지 않는냐의 차이가 성능 측정치에 영향을 미친다.
- 단 2개의 스레드만을 사용하는 경우에도 Map에 접근하려는 거의 모든 경우에 스레드 간의 경쟁이 발생했다.
- 애플리케이션의 작업 구조상 공유된 데이터에 접근해 사용하는 부분보다 스레드 내부 작업의 양이 상대적으로 많다고 하면 스레드 경쟁 정도가 크게 떨어지고, 경쟁이 적어지니 전반적으로 괜찮은 성능을 낼 수 있을 것이다.
- 이런 관점에서 보면 TimedPutTakeTest 테스트 프로그램에서 사용했던 모델은 일부 애플리케이션 구조를 묘사하기에는 그다지 훌륭하지 못하다고 볼수 있다.
- 스레드 내부에서 별다른 작업을 하지 않기 때문에 성능 측정치는 스레드 간의 경쟁 정도에 좌우되며, 프로듀서와 컨슈머 간에 큐를 사용해 데이터를 주고 받는 어플리케이션 모두가 이와 같이 스레드 내부의 작업이 적다고 볼 수는 없기 때문이다.

### 의미 없는 코드 제거 
- 최적화 컴파일러는 의미 없는 코드를 제거하는데 뛰어난 능력을 갖고 있으며, 따라서 훌륭한 성능 측정 프로그램을 작성하는 일이 그다지 쉬운일은 아니다. 일반적으로 성능 측정을 하는 동안에는 실제적인 계산 작업을 거의 하지 않기 때문에 최적화 컴파일러 입장에서는 1차 제거 대상이 될 수 도있다.
- 성능 측정 프로그램을 싱행하는 경우에는 최적화 된 이후 예상했던 것보다 훨씬 적은 코드마이 실행될 수 있기 때문에 큰 문제가 되기도 한다. 오류를 범할 수 있음
- 의미 없는 코드 제거 기능은 정적으로 컴파일하는 언어로 성능을 측정하는 경우에도 비슷한 문제점을 발생
    - 하지만 미리 컴파일괒어을 선행하기때문에 컴파일러가 최적화 과정에서 코드를 얼마만큼 제거해 버렸는지 파악할수 있다.
    - 동적인 컴파일 방법을 사용하는 경우에는 이와같이 컴파일된 기계어 코드를 살펴보기 어려워 이런 정보를 얻기 어렵다.
- 핫스팟 JVM의 클라이언트모드(-client)보다 서버모드(-server)로 실행할때의 결과가 훨씬좋다.
    - 서버모드의 동적컴파일러가 더 효율적인 코드를 생성 할 수 있는것 뿐만 아니라 의미 없는 코드를 최적화하는 능력도 더 나음
    - CPU가 여러개 장착된 시스템에서는 모두 -client 대신 -server 옵션을 지정하는것이 좋다
  
- **훌륭한 성능 측정 프로그램을 작성하려면 최적화 컴파일러가 의미 없는 코드를 제거하는 과정에 성능 측정상 필요한 부분까지 제거하지 않도록 약간의 편법을 써야 할 필요가 있다. 그러려면 프로그램 코드가 만들어 내는 모든 결과값을 프로그램 어디에선가 사용하도록 해야한다. 물론 그때문에 추가적으로 동기화를 해야하거나 더 많은 자원을 소모하도록 하지는 않는것이 좋다.**

ex) PutTakeTest 에서 큐에 추가하거나 큐에서 제거하는 항목마다 체크섬 값을 계산하고 나중에 모든 스레드 체크섬을 합산해 올바르게 동작했는지 확인하는 부분
- 체크섬 실제로 사용하는 부분이 없기때문에 없는 코드로 제거될 가능성이 있다
- 콘솔에 출력하는 기능을 넣어서 실제로 사용하는 값이라는 사실을 최적화 컴파일러에게 알려주자.
- I/O 기능을 호출하면 성능 측정 값에 영향을 줄 수 있으니 성능 테스트를 실행하는 동안에, 특히 시간을 측정하는 동안에는 I/O 기능을 사용하지 않는 편이 좋다.

~~~java
// 두값 일치할 확률 거의 없음
if(foo.x.hashCode() == System.nanoTime())
  System.out.print(" ");
~~~
- 비교문 안에 I/O 를 사용하는 출력문을 적어두면 성능 측정에 영향을 줄 만한 작업은 하지 않으면서 최적화 컴파일러가 의미 없는 코드로 판단해 제거해 버리는 일을 방지 할 수 있다.
- 비교구문 참일 가능 X, 참이되더라도 콘솔에 의미 없는 공백문자 하나만을 출력할 뿐
- 프로그램 내부에서 계산했던 모든 값을 어떤방법으로건 사용해야할 뿐만 아니라 그 사용처를 추측할수 업ㅂㅅ어야 한다
- 괜찮은 최적화 컴파일러가 동작하고 있을때 만약 결과값을 예측 할 수 있다면 최적화 컴파일러가 매번 계산 과정을 실행하는 대신 미리 계산된 값을 사용하기도 한다.
- PutTakeTest 프로그램을 작성할때는 이러한 가능성을 고려하고 작업했지만 정적인 입력값을 갖고 동작하는 테스트 프로그램은 항상 최적화 컴파일러가 미리 계산된 값을 사용 할 수 있다는 사실을 주의해야 한다.

## 12.4 보조적인 테스트 방법
- 테스팅의 목적은 오류를 찾는 일이 아니라 대상 프로그램이 처음 작성할대 설계 했던대로 동작한다는 즉 신뢰성을 높이는 작업이라고 봐야한다.
- 결국 모든 버그를 잡아내는것은 불가능하기 때문에 품질보증 QA 전략으로 항상 가능한 테스트 자원내에서 최대한 신뢰성을 끌어낼 수 있는도록 방향을 잡아야한다.
- 병렬프로그래밍 오류 발생할 확률이 높기때문에 훨씬 많이 테스트해야한다.
- QA 방법론에도 여러가지가 있음 방법을 적절하게 활용하면 오류의 유형에 따라 좀더 효율적으로 오류를 발견할 수 있다
- 코드 리뷰나 정적분석과 같이 상호보완적인 여러가지 테스트 방법을 사용하면 한두가지 방법만 사용했을때보다 프로그램에 대한 신뢰도를 크게 높일 수 있다.

### 코드리뷰
- 병렬 프로그램의 오류를 찾아내고자 할 때 단위테스트와 성능테스트 만큼이나 중요하고 효과적인 테스트 방법은 여려명이 모여서 코드를 살펴보는 코드 리뷰이다.
- 아주 사소한 경쟁조건을 찾아내는등의 일은 여러개의 테스트 프로그램을 작성하는것보다 병렬프로그래밍 전문가가 코드를 들여다 보는 것으로 더 쉽게 찾아내는 경우가 많다.
- 코드 리뷰를 하다보면 그 이외에도 이득을 볼 수 있다. 단순히 문제점을 찾아내는 것 뿐만 아니라 코드 리뷰와
  함께 소스코드의 주석문에 코드에 대한 더 자세한 설명을 추가하는 일을 함께 하면서 나중에 반드시 발생할 유지보수 비용을 낮출수도 있다.

### 정적 분석 도구
- 정적 코드 분석 방법은 코드를 실행하지 않고 그자체로 분석하며, 코드 감사 도구를 사용하면 클래스 파일 내부에 흔히 알려진 여러가지 버그패턴 가운데 해당하는 부분이 있는지를 확인해 준다.
- 오픈소스로 공개된 FindBugs 와 같은 정적 분석도구에는 버그패턴 감지기가 포함돼 있고, 단위테스트나 성능테스트, 코드리뷰등의 과정에서 빼먹기 쉬운 다양한 종류의 일반적인 코딩 오류를 발견할 수 있다.
- 정적 분석 도구를 실행시키면 경고할만한 부분을 목록으로 리포팅 해주며, 리포팅된 부분이 오류인지 아닌지는 반드시 사람이 직접 확인해야한다.

- **일반적이지 않은 동기화**
- **Thread.run 호출**
- **해제되지 않은 락**
- **빈 synchronized 블록**
- **더블 체크락**
- **생성 메소드에서 스레드 실행**
- **알림 오류**
- **조건부 대기 오류**
- **Lock과 Condition의 오용**
- **락을 확보하고 대기 상태 진입**
- **스핀 반복문**

### 관점 지향 테스트 방법
- 지금 시점까지는 관점 지향 프로그래밍 AOP 기법이 병렬프로그래밍 분야에 적용되는 사례는 굉장히 제한적이었다.
- AOP 도구가 아직은 동기화 관련 지점에서 포인트 컷을 지원하지 않고 있기 때문이다.
- AOP를 사용하면 상태변수의 값이 동기화 정책에 잘 맞는지 확인하는등의 작업을 하도록 적용 해 볼 수 있겠다
- AOP의 특성상 코드를 따로 변경할 필요가 없으니 이런 기법은 적용하기에도 간편하고, 사소한 변수공개상황이나 스레드 한정오류와 같은 부분을 찾아내기 좋다.

### 프로파일러와 모니터링 도구
- 대부분 상용 프로파일링 도구에는 스레드의 동작 상황을 살펴 볼 수 있는 모듈이 포함돼 있다.
- 각 제품마다 기능과 효율성등이 서로 다르지만 테스트 대상 프로그램이 도대체 무슨일을 하고있는지에 대한 내부적인 정보를 들여다 보는 좋은 방법이다.
- 대부분 각 스레드의 실행상태를 여러가지 색으로 구분해 시간이 지나감에 따라 어떻게 실행되는지를 표시하는 기능을 갖고있다.
- 이와같은 결과 그래프를 보면 프로그램이 CPU 를 얼마나 충분하게 활용하고있으며 충분히 사용하지 못한다면 어디에 그원인이 있는지도 대략적으로 알려준다.
- 자바에 내장된 JMX 에이전트를 사용하는것도 제한적이나마 스레드의 상태를 모니터링 할 수 있는 방법이다.

## 요약
- 병렬 프로그램이 올바르게 동작하는지 테스트하는 일은 어려운 작업이다.
- 병렬 프로그램에서 발생하는 오류는 대부분 발생 확률이 아주 작은 타이밍 문제, 부하문제, 아니면 기타 쉽게 발현되지 않는 여러원인에 의해 발생하기 때문이다.
- 성능을 테스트하는 일도 어렵다
- 성능을 측정할떄 실행 시간이 동적인 컴파일, 가비지 컬렉션, 그리고 각종 최적화 방법 때문에 크게 변경될 수 있으며, 따라서 의도했던 대로 시간을 측정하기 어렵기 떄문이다.
- 숨어있는 버그를 상용서비스 이전에 발견할수 있는 가장 좋은 방법은 전통적인 테스트방법과 함께 코드리뷰나 자동화된 분석 도구를 사용하는 방법이다.
- 각 방법은 모두 다른 방법이 잘 찾아내지 못하는 오류를 찾아낼수 있으니, 다양한 방법을 동원해 테스트해야 오류를 최대한 줄일 수 있다.


## 참고
책 자바 병렬 프로그래밍 12장