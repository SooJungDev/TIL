## 13장 내용
13.1 Lock 과 ReentrantLock
13.2 성능에 대한 고려 사항
13.3 공정성
13.4 synchronized 또는 ReentrantLock 선택
13.5 읽기-쓰기 락

## 13.1 Lock 과 ReentrantLock
- 자바 5.0에는 또다른 방법 추가됐음 ReentrantLock이다
- 암묵적인 락으로 할 수 없는 일도 처리 할 수 있도록 여라가지 고급 기능을 갖고있다.

~~~java
public interface Lock{
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
~~~
- Lock 인터페이스 
- Lock 인터페이스는 여러가지 락 관련 기능에 대한 추상 메소드 abstract method 를 정의하고 있다.
- Lock 인터페이스는 암묵적인 락과 달리 조건 없는 unconditional 락, 폴링락, 타임아웃이 있는락, 락 확보 대기 상태에 인터럽트를 걸 수 있는 방법등이 포함돼 있으며, 락을 확보하고 해제하는 모든 작업이 명시적이다.
- Lock을 구현하는 클래스는 항상 암묵적인 락과 비교해서 동일한 메모리 가시성 memory visibility 을 제공해야 하지만, 락을 거는 의미나 스케줄링 알고리즘, 순서를 지켜주는 기능, 성능등의 측면에서 다른 면모를 갖고 있다.
- ReentrantLock 클래스 역시 Lock 인터페이스를 구현하며, synchronized 구문과 동일한 메모리 가시성과 상호 배제 기능을 제공한다.
- ReentrantLock을 확보한다는것은 synchronized 블록에 진입하는것과 동일한 효과를 갖고 있고, ReentrantLock을 해제한다는것은 synchronized 블록에서 빠져나가는것과 동일한 효과를 갖는다. 
- 그리고 ReentrantLock 역시 synchronized 키워드와 동일하게 재진입이 가능하도록 허용하고 있다.
- ReentrantLock 은 Lock에 정의돼 있는 락 확보 방법을 모두 지원한다. 따라서 락을 제대로 확보하기 어려운 시점에 synchronized 블록을 사용할 때 보다 훨씬 능동적으로 대처 할 수 있다.

~~~java
Lock lock = new ReetrantLock();
...
lock.lock();
try{
    // 객체 내부 값을 사용
    //예외가 발생한 경우, 적절하게 내부값을 복원해야 할 수도 있음
}finally{
    lock.unlock();
}
~~~
- ReentrantLock을 사용한 객체 동기화
- finally 블록에서 반드시 락을 해제해야 한다는점
- 해제하지 않으면 try 구문 내부에서 예외가 발생 했을때 락이 해제되지 않는 경우가 발생한다.
- 이처럼 락을 사용할때는 try 블록 내부에서 예외가 발생했을때 어떤일이 발생 할 수 있는지에 대해 반드시 고민해봐야 한다.
- 만약 예외 때문에 해당 객체가 불안정한 상태가 될수 있다면 try-catch 구문이나 try-finally 구문을 추가로 지정해야 안정적인 상태를 유지 하도록 해야한다.
- 락을 해제하는 기능을 finally 구문에 넣어두지 않은 코드는 언제 터질지 모르는 시한폭탄과 같다.
    - synchronized 구문을 제거하는 대신에 기계적으로 ReentrantLock을 대치하는 작업을 하지 말아야 하는 이유
- 즉 ReentrantLock을 사용하면 해당하는 블록의 실행이 끝나고 통제권이 해당블록을 떠나는 순간 락을 자동으로 해제하지 않기 때문에 굉장히 위험한 코드가 될 가능성이 높다
  
### 폴링과 시간 제한이 있는 락 확보 방법
- tryLock 메소드가 지원하는 폴링 락 확보 방법이나 시간제한이 있는 락 확보 방법은 오류가 발생했을떄 무조건적으로 락을 확보하는 방법보다 오류를 잡아내기에 훨씬 깔끔한 방법이라고 볼수 있다.
- 암묵적으로 락을 사용할때는 데드락이 발생하면 프로그램이 멈춰버리는 치명적인 상황에 이른다.
- 락을 확보할때 시간 제한을 두거나 폴링하도록하면 다른방법, 즉 확률적으로 데드락을 회피 할 수 있는 방법을 사용 할 수 있다.
- 락을 확보할때 시간 제한을 두거나 폴링방법(tryLock)을 사용하면 락을 확보하지 못하는 상황에도 통제권을 다시 얻을 수 있으며, 그러면 미리 확보하고 있던 락을 해제하는등의 작업을 처리한 이후 락을 다시 확보하도록 재시도 할 수 있다.
~~~java
~~~

### 인터럽트 걸 수 있는 락 확보 방법


~~~java
~~~

~~~java
~~~


### 블록을 벗어나는 구조의 락

## 13.2 성능에 대한 고려 사항

## 13.3 공정성

## 13.4 synchronized 또는 ReentrantLock 선택

## 13.5 읽기-쓰기 락
~~~java
~~~

## 요약
- 명시적으로 Lock 클래스를 사용해 스레드를 동기화 하면 암묵적인 락보다 더 많은 기능을 활용할 수 있다.
- 예를 들어 락을 확보할 수 없는 상황에 유연하게 대처하는 방법이나 대기 큐에서 기다리는 방법과 규칙도 원하는대로 정할 수 있다
- 그렇다고 해서 synchronized 구문 대신 기계적으로 ReentrantLock 을 사용해야 할 필요는 없고, 단지 ReentrantLock 에서만 제공되고 synchronized 구문은 제공하지 않는 동기화 관련 기능이 꼭 필요한 경우에만 ReentrantLock 을 사용하도록 하자
- 읽기-쓰기 락을 사용하면 읽기 작업만 처리하는 다수의 스레드는 동기화 된 값을 얼마든지 동시에 읽어갈 수 있다
- 따라서 읽기 작업이 대부분인 데이터 구조에 읽기-쓰기 락을 사용하면 확장성을 높여주는 훌륭한 도구가 된다.

## 참고
책 자바 병렬 프로그래밍 13장