## 14장 내용

- 14.1 상태 종속성 관리
- 14.2 조건 큐 활용
- 14.3 명시적인 조건 객체
- 14.4 동기화 클래스의 내부 구조
- 14.5 AbstractQueuedSynchronizer
- 14.6 java.util.concurrent 패키지와 동기화 클래스에서 AQS 활용 모습

## 14.1 상태 종속성 관리

- FutureTask, Semaphore, BlockingQueue 등과 같이 JDK 라이브러리에 상태의존적으로 움직이는, 즉 상태기반 선행 조건을 갖고 있는 클래스가 여럿있다.
- 예를 들어 비어있는 큐에서는 항목을 끄집어 낼수 없으며, 아직 실행이 끝나지 않은 작업의 결과는 얻어갈수 없다.
원하는 작업을 하려면 큐에 값이 들어오는 상태나 작업이 완료 됏다는 상태에 들어갈때까지 기다려야한다.
- 상태 의존적인 클래스를 새로 구현하는 가장 간단한 방법은 이미 만들어져 있는 상태 의존적인 클래스를 활용해 필요한 기능을 구현하는것이다.
- 14장에서는 상태 종속성을 만들어 낼 수 있는 다양한 방법에 대해서 알아보고, 자바 플랫폼에서 제공하는 상태 종속성에 적용되는 여러가지 규칙에 대해서도 살펴본다.

- 단일 스레드로 동작하는 프로그램에서는 메소드를 호출 햇을때 상태기반의 조건이 만족되지 않는다면, 해당 조건은 앞으로도 절대로 만족될 가능성이 없다.
- 따라서 순차적으로 실행되는 프로그램은 원하는 상태를 만족시키지 못하는 부부니 있다면 반드시 오류가 발생하게 된다.
- 하지만 병렬 프로그램에서는 상태 기반의 조건은 다른 스레드를 통해서 언제든지 마음대로 변경될수 있다.
- 바로 직전에 실행할때는 비어있던 풀에 다른 스레드가 사용하고 남은 객체가 반한돼 풀에 항목이 들어오기도한다.
- 상태 종속적인 기능을 구현할떄 원하는 선행 조건이 만족할 때까지 작업을 멈추고 대기하도록 하면 조건이 맞지 않았을떄 프로그램이 멈춰버리는 방법보다 훨씬 간편하고 오류도 적게발생한다.
- 자바에 내장된 조건 큐 메커니즘은 실행중인 스레드가 특정 객체가 원하는 상태에 진입할때까지 대기할 수 있도록 도와주며, 원하는 상태에 도달해서 스레드가 계속해서 실행 할 수 있게 되면 대기상태에 들어가 있던 스레드를 깨워주는 역할도 담당한다.

~~~java
void blockingAction() throws InterruptedException{
    상태변수에 대한 락 확보
    while(선행조건이 만족하지 않음){
        확보했던 락을 풀어줌
        선행조건이 만족할만한 시간만큼 대기
        인터럽트에 걸리거나 타임아웃이 걸리면 멈춤
        락을 다시확보
    }
    작업 실행
    락 해제
}
~~~
- 상태 종속적인 작업의 동기화 구조
- 상태 종속적인 블로킹 작업은 위와 같은 모양을 갖고있다.
- 선행 조건에 해당하는 클래스 내부의 상태 변수값을 확인하는 동안에도 적절한 락으로 반드시 동기화해야 올바른 값을 확인 할 수 있다.
- 하지만 일단 선행조건을 만족하지 않았다면 락을 다시 풀어줘야 다른스레드에서 상태변수를 변경할수 있다.
- 만약 락을 풀어주지 않고 계속 잡고있다면 다른 스레드에서 상태 변수의 값을 변경 할수 없기 떄문에 선행조건을 영원히 만족시키지 못한다
- 물론 다음번 선행조건을 확인하기 직전에는 락을 다시 확보해야만 한다.
- 프로듀서 - 컨슈머 패턴으로 구현된 어플리케이션에서는 ArrayBlockingQueue와 같이 크기가 제한된 큐를 많이 사용한다.
- 크게가 제한된 큐는 put과 take 메소드를 제공하며 put, take 메소드에는 다음과 같은 선행조건이 있다
  - 버퍼 내부가 비어있다면 값을 take 할수 없고 버퍼가 가득 차있다면 값을 put 할수 없다.
- 상태 종속적인 메소드에서 선행조건과 관련한 오류가 발생하면 예외를 발생시키거나 오류값을 리턴하기도하고 아니면 선행조건이 원하는 상태에 도달할때까지 대기하기도 한다.
  
~~~java
@ThreadSafe
public abstract class BaseBoundedBuffer<V> {
    @GuardedBy("this")
    private final V[] buf;
    @GuardedBy("this")
    private int tail;
    @GuardedBy("this")
    private int head;
    @GuardedBy("this")
    private int count;

    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[]) new Object[capacity];
    }

    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length)
            tail = 0;
        ++count;
    }

    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if (++head == buf.length)
            head = 0;
        --count;
        return v;
    }

    public synchronized final boolean isFull() {
        return count == buf.length;
    }

    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}

~~~
- 크기가 제한된 버퍼의 기반 클래스
- BaseBoundedBuffer 클래스를 상속받는다
- BaseBoundedBuffer 클래스는 전통적인 배열 기반의 원형 버퍼로 구성돼 있으며, 버퍼 내부의 상태 변수는 synchronized 키워드를 사용해 동기화 하고 있다.
- BaseBoundedBuffer는 하위 클래스에서 put 메소드와 take 메소드를 구현할떄 사용할 수 있도록 doPut 메소드와 doTake 메소드를 제공하고, 내부적으로 갖고 있는 상태 변수는 외부에 공개하지 않는다.

### 예제: 선행조건 오류를 호출자에게 그대로 전달
~~~java
~~~
- 선행 조건이 맞지 않으면 그냥 멈춰버리는 버퍼클래스

~~~java
~~~
- GrumpyBoundedBuffer를 호출하기 위한 호출자 측의 코드 

### 예제: 폴링과 대기를 반복하는 세련되지 못한 대기상태

### 조건 큐 - 문제해결사

## 14.2 조건 큐 활용

### 조건 서술어

### 너무 일찍 깨어나기

### 놓친 신호

### 알림

### 예제: 게이트 클래스

### 하위 클래스 안정성 문제

### 조건 큐 캡슐화

### 진입 규칙과 완료 규칙

## 14.3 명시적인 조건 객체

## 14.4 동기화 클래스의 내부 구조

## 14.5 AbstractQueuedSynchronizer

### 간단한 래치

## 14.6 java.util.concurrent 패키지와 동기화 클래스에서 AQS 활용 모습

### ReentrantLock

### Semaphore 와 CountDownLatch

### FutureTask

### ReentrantReadWriteLock

### 요약

- 상태 기반으로 동작하는 클래스, 즉 메소드 가운데 하나라도 상태 갑셍 따라 대기상태에 들어갈 가능성이 있는 클래스를 작성해야할때 가장 좋은 방법은 ValueLatch 예제에서 본것처럼 기존에 만들어져 있는 Semaphore, BlockingQueue , CountDownLatch 등을 활용해 구현하는 방법이다.
- 이미 많은 종류의 동기화 클래스가 제공되고 있음에도 불구하고 적절한 기능을 찾을수 없다면, 암묵적인 조건 큐나 명시적인 Condition 클래스 또는 AbstractQueuedSynchronizer 클래스등을 활용해 직접 원하는 기능의 동기화 클래스를 작성 할 수도 잇겠다.
- 상태 의존성을 관리하는 작업은 상태의 일관성을 유지하는 방법과 맞물려 있기 때문에 암묵적이 조건 큐 역시 암묵적인 락과 굉장히 밀접하게 관련돼 있다.
- 이와 비슷하게 명시적인 조건 큐인 condition 클래스도 명시적인 Lcok 클래스와 밀접하게 관련돼 있으며, 락 하나에서 다수의 대기 큐를 활용하거나 대기 상태에서 인터럽트에 어떻게 반응하는지를 지정하는 기능, 스레드 대기 큐의 관리 방법에 대한 공정성 여부를 지정하는 기능, 대기상태에서 머무르는 시간을 제한할 수 있는 기능등과 같이 암묵적인 버전의 조건 큐나 락보다 훨씬 다양한 기능을 제공한다.

## 참고

책 자바 병렬 프로그래밍 14장
