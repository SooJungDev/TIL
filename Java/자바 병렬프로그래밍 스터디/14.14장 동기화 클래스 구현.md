## 14장 내용

- 14.1 상태 종속성 관리
- 14.2 조건 큐 활용
- 14.3 명시적인 조건 객체
- 14.4 동기화 클래스의 내부 구조
- 14.5 AbstractQueuedSynchronizer
- 14.6 java.util.concurrent 패키지와 동기화 클래스에서 AQS 활용 모습

## 14.1 상태 종속성 관리

- FutureTask, Semaphore, BlockingQueue 등과 같이 JDK 라이브러리에 상태의존적으로 움직이는, 즉 상태기반 선행 조건을 갖고 있는 클래스가 여럿있다.
- 예를 들어 비어있는 큐에서는 항목을 끄집어 낼수 없으며, 아직 실행이 끝나지 않은 작업의 결과는 얻어갈수 없다.
원하는 작업을 하려면 큐에 값이 들어오는 상태나 작업이 완료 됏다는 상태에 들어갈때까지 기다려야한다.
- 상태 의존적인 클래스를 새로 구현하는 가장 간단한 방법은 이미 만들어져 있는 상태 의존적인 클래스를 활용해 필요한 기능을 구현하는것이다.
- 14장에서는 상태 종속성을 만들어 낼 수 있는 다양한 방법에 대해서 알아보고, 자바 플랫폼에서 제공하는 상태 종속성에 적용되는 여러가지 규칙에 대해서도 살펴본다.

- 단일 스레드로 동작하는 프로그램에서는 메소드를 호출 햇을때 상태기반의 조건이 만족되지 않는다면, 해당 조건은 앞으로도 절대로 만족될 가능성이 없다.
- 따라서 순차적으로 실행되는 프로그램은 원하는 상태를 만족시키지 못하는 부부니 있다면 반드시 오류가 발생하게 된다.
- 하지만 병렬 프로그램에서는 상태 기반의 조건은 다른 스레드를 통해서 언제든지 마음대로 변경될수 있다.
- 바로 직전에 실행할때는 비어있던 풀에 다른 스레드가 사용하고 남은 객체가 반한돼 풀에 항목이 들어오기도한다.
- 상태 종속적인 기능을 구현할떄 원하는 선행 조건이 만족할 때까지 작업을 멈추고 대기하도록 하면 조건이 맞지 않았을떄 프로그램이 멈춰버리는 방법보다 훨씬 간편하고 오류도 적게발생한다.
- 자바에 내장된 조건 큐 메커니즘은 실행중인 스레드가 특정 객체가 원하는 상태에 진입할때까지 대기할 수 있도록 도와주며, 원하는 상태에 도달해서 스레드가 계속해서 실행 할 수 있게 되면 대기상태에 들어가 있던 스레드를 깨워주는 역할도 담당한다.

~~~java
void blockingAction() throws InterruptedException{
    상태변수에 대한 락 확보
    while(선행조건이 만족하지 않음){
        확보했던 락을 풀어줌
        선행조건이 만족할만한 시간만큼 대기
        인터럽트에 걸리거나 타임아웃이 걸리면 멈춤
        락을 다시확보
    }
    작업 실행
    락 해제
}
~~~
- 상태 종속적인 작업의 동기화 구조
- 상태 종속적인 블로킹 작업은 위와 같은 모양을 갖고있다.
- 선행 조건에 해당하는 클래스 내부의 상태 변수값을 확인하는 동안에도 적절한 락으로 반드시 동기화해야 올바른 값을 확인 할 수 있다.
- 하지만 일단 선행조건을 만족하지 않았다면 락을 다시 풀어줘야 다른스레드에서 상태변수를 변경할수 있다.
- 만약 락을 풀어주지 않고 계속 잡고있다면 다른 스레드에서 상태 변수의 값을 변경 할수 없기 떄문에 선행조건을 영원히 만족시키지 못한다
- 물론 다음번 선행조건을 확인하기 직전에는 락을 다시 확보해야만 한다.
- 프로듀서 - 컨슈머 패턴으로 구현된 어플리케이션에서는 ArrayBlockingQueue와 같이 크기가 제한된 큐를 많이 사용한다.
- 크게가 제한된 큐는 put과 take 메소드를 제공하며 put, take 메소드에는 다음과 같은 선행조건이 있다
  - 버퍼 내부가 비어있다면 값을 take 할수 없고 버퍼가 가득 차있다면 값을 put 할수 없다.
- 상태 종속적인 메소드에서 선행조건과 관련한 오류가 발생하면 예외를 발생시키거나 오류값을 리턴하기도하고 아니면 선행조건이 원하는 상태에 도달할때까지 대기하기도 한다.
  
~~~java
@ThreadSafe
public abstract class BaseBoundedBuffer<V> {
    @GuardedBy("this")
    private final V[] buf;
    @GuardedBy("this")
    private int tail;
    @GuardedBy("this")
    private int head;
    @GuardedBy("this")
    private int count;

    protected BaseBoundedBuffer(int capacity) {
        this.buf = (V[]) new Object[capacity];
    }

    protected synchronized final void doPut(V v) {
        buf[tail] = v;
        if (++tail == buf.length)
            tail = 0;
        ++count;
    }

    protected synchronized final V doTake() {
        V v = buf[head];
        buf[head] = null;
        if (++head == buf.length)
            head = 0;
        --count;
        return v;
    }

    public synchronized final boolean isFull() {
        return count == buf.length;
    }

    public synchronized final boolean isEmpty() {
        return count == 0;
    }
}

~~~
- 크기가 제한된 버퍼의 기반 클래스
- BaseBoundedBuffer 클래스를 상속받는다
- BaseBoundedBuffer 클래스는 전통적인 배열 기반의 원형 버퍼로 구성돼 있으며, 버퍼 내부의 상태 변수는 synchronized 키워드를 사용해 동기화 하고 있다.
- BaseBoundedBuffer는 하위 클래스에서 put 메소드와 take 메소드를 구현할떄 사용할 수 있도록 doPut 메소드와 doTake 메소드를 제공하고, 내부적으로 갖고 있는 상태 변수는 외부에 공개하지 않는다.

### 예제: 선행조건 오류를 호출자에게 그대로 전달
~~~java
@ThreadSafe
public class GrumpyBoundedBuffer<V> extends BaseBoundedBuffer<V> {
    public GrumpyBoundedBuffer(int size){
        super(size);
    }

    public synchronized void put(V v)throws BufferFullException{
        if(isFull())
            throw new BufferFullException();
        doPut(v);
    }

    public synchronized V take() throws BufferEmptyException{
        if(isEmpty())
            throw new BufferFullException();
        return doTake();
    }
}
~~~
- 선행 조건이 맞지 않으면 그냥 멈춰버리는 버퍼클래스
- GrumpyBoundedBuffer 는 원하는 버퍼를 구현하고자 하는 첫 단계이며 섬세하지 못하고 굉장히 거친 모습을 갖고있다. put 메소드와 take 메소드는 확인하고 동작하는(check-then-act) 구조로 구현했기 떄문에
  synchronized 키워드를 적용해 버퍼 내부의 상태 변수에 동기화된 상태로 접근하게 돼 있다.
- 예외는 예외적인 상황에서만 사용하는게 정상이다.
- 버퍼가 가득찼다는건 크기가 제한된 버퍼에서는 당연히 발생할 수 있는 일이기 때문에 그다지 예외적인 상황이라고 볼수 없다.
- 버퍼를 구현할때 아주 간단하게 구현하긴 했지만 그걸 사용할때는 그다지 간단하지 않다.
- 즉 GrumpyBoundedBuffer 를 사용하는 외부의 클래스는 put이나 take 메소드를 호출할때마다 발생할 가능성이 있는 예외 상황을 매번 처리해줘야 한다


~~~java
    while (true){
            try{
                V item = buffer.take();
                // 값을 사용한다
                break;
            }catch (BufferEmptyException e){
                Thread.sleep(SLEEP_GRANULARITY);
            }
        }
~~~
- GrumpyBoundedBuffer를 호출하기 위한 호출자 측의 코드 
- GrumpyBoundedBuffer 클래스의 take 메소드를 호출하는 일반적인 구조
- 프로그램 여기저기에서 put 메소드와 take 메소드를 사용한다면 그다지 깔끔하지 않을게 분명하다.
- 이와 유사한 또 다른방법으로는 원하는 상태가 아닐때 오류값을 리턴하는 방법이 있다.
- 하지만 선행조건이 맞지 않다고 해서 호출자가 오류를 맡아서 처리해야 하는 원론적인 방법상의 문제를 해결하지 못한다.
- 재시도 하는 논리를 구현하는 방법에있어서는 다른방법도 있다
- 호출자가 잠자는 대기 시간 없이 take 메소드를 즉시 다시 호출하는 방법인데, 흔히 스핀대기 spin waiting, busy waiting 방법이라고한다.
- 이 방법을 사용했는데 버퍼의 상태가 원하는 값으로 얼른 돌아오지 않는다면 상당한 양의 CPU 자원을 소모하게 된다.
- 반대로 CPU 자원을 덜 소모하도록 하고자 일정 시간 동안 대기하게 할 수 있는데 이렇게 하면 버퍼의 상태가 원하는 값으로 돌아왔음에도 불구하고 계속해서 대기 상태에 빠져있는 과다대기 문제가 생기기도 한다.
- 따라서 호출자는 CPU를 덜 사용하되 응답성에서 손해를 보거나, 응답성은 좋지만 CPU 를 엄청나게 소모하는 두가지 방법 가운데 어느것을 사용해야 할지 선택해야한다.
  
### 예제: 폴링과 대기를 반복하는 세련되지 못한 대기상태
~~~java

@ThreadSafe
public class SleepyBoundedBuffer<V> extends BaseBoundedBuffer<V> {
    public SleepyBoundedBuffer(int size) {
        super(size);
    }

    public void put(V v) throws InterruptedException{
        while (true){
            synchronized (this){
                if(!isFull()){
                    doPut(v);
                    return;
                }
            }
        }
        Thread.sleep(SLEEP_GRANULARITY);
    }
    
    public V take()throws InterruptedException{
        while (true){
            synchronized (this){
                if(!isEmpty())
                    return doTake();
            }
            Thread.sleep(SLEEP_GRANULARITY);
        }
    }
}

~~~
- 세련되지 못한 대기 방법을 사용하는 SleepyBoundedBuffer
- 폴링하고 대기하는 재시도 반복문을 put 메소드와 take 메소드 내부에 내장시켜서 외부의 호출 클래스가 매번 직접 재시도 반복문을 만들어 사용해야하는 불편함을 줄여주고자하고 있다.
- 만약 버퍼가 비어 있다면 take 메소드는 다른 스레드가 버퍼에 값을 집어 넣을떄까지만 대기하고, 버퍼가 가득 차 있다면 put 메소드는 다른 스레드가 값을 꺼내 버퍼에 빈 공간이 생길때까지 대기한다
- 이방법은 선행 조건 관리하는 부분을 버퍼 내부에 내장했기 때문에 외부에서 버퍼를 훨씬 간편하게 사용할 수 있다.
- 외부에서 간단하게 사용할 수 있다는건 버퍼를 구현하는 입장에서 굉장히 중요하고 그래야만 하는 요건이다
- SleepyBoundedBuffer 클래스 구현 내용을 보면 이전에 구현했던 방법보다 약간 더 복잡한 모양을 갖추고 있다
- 버퍼 내부를 보면 상태 조건을 나타내는 변수가 버퍼락으로 동기화돼 있기 때문에 버퍼의 락을 확보한 상태에서 상태 조건이 적절한지 먼저 확인한다
- 만약 상태조건이 적절하지 않다면 실행중이던 스레드가 잠시 대기 상태에 들어가고, 대기상태에 들어가기 직전에 락을 풀어서 다른 스레드가 버퍼의 상태 변수를 사용 할 수 있도록 한다.
- 대기 상태에 있던 스레드가 깨어나면 락을 다시 확보한 다음에 상태 조건을 다시 확인한다.
- 이렇게 잠시 대기하고 상태조건을 확인한느 반복문을 계속해서 실행하다가 조건이 적절해지면 반복문을 빠져나와 작업을 처리한다
- 만약 상태 조건이 이미 적절하게 갖춰져 있다면 작업 역시 즉시 실행할수 있고, 그렇지 않다면 대기상태에 들어간다.
- 잠자기 대기 상태에 들어간느 시간을 길게 잡거나 짧게 잡으면 응답속도와 CPU 사용량 간의  트레이드오프가 발생한다
- 대기시간을 길게 잡으면 CPU 사용량은 줄어들지만 응답 속도가 떨어진다.
- 그림 14.1 을 보면 대기시간에 따라 응답속도가 어떻게 변하는지를 그래프로 보여주고 있다.
- 버퍼에 공간이 생긴 이후에 스레드가 대기상태에서 빠져나와 상태조건을 확인하기까지 약간의 시간 차이가 발생하기도 한다는 점을 주의하자.
- SleepyBoundedBuffer 를 사용하는 호출자는 InterruptedException 발생하는 경우를 처리해야한다
- 메소드 내부에서 원하는 조건을 만족할때까지 대기해야 한다면 작업을 취소 할 수 있는 기능을 제공하는 편이 좋다
- InterruptedException 을 던지는 작업 취소 방법을 적용하고 있다
- 폴링하고 대기하는 반복 작업을 통해 블로킹 연산을 구현하는 일은 상당히 고생스러운 일이다. 조건이 맞지 않으면 스레드를 멈추지만 원하는 조건에 도달하면 그 즉시 실행시킬 수 있는 방법 -> 조건 큐

### 조건 큐 - 문제해결사
- 조건 큐 주방에 놓여있는 토스트 기계에서 토스트가 다됐습니다라고 울리는 벨과 같음
- 조건 큐는 여러 스레드를 한 덩어리(wait set)로 묶어 특정 조건이 만족 할 때까지 한꺼번에 대기할 수 있는 방법을 제공하기 때문에 '조건 큐' 라는 이름으로 불린다.
- 데이터 값으로 일반적인 객체를 담아두는 보통의 큐와 달리 조건 큐에는 특정 조건이 만족할때까지 대기해야 하는 스레드가 값으로 들어간다
- 자바 언어에서 사용하는 모든 객체를 락으로 활용할 수 있는 것 처럼 모든 객체는 스스로를  조건 큐로 사용 할 수 있으며, 모든 객체가 갖고있는 wait, notify. notifyAll 메소드는 조건큐의 암묵적인 API 라고 봐도 좋다.
- 자바의 암묵적인 락과 암묵적인 조건큐는 서로 관련돼 있는 부분이 있는데, 이를 테면 X라는 객체의 조건 큐 API 를 호출하고자 하면 반드시 객체 X의 암묵적인 락을 확보하고 있어야만 한다.
- Object.wait 메소드는 현재 확보하고 있는 락을 자동으로 해제하면서 운영체제에게 현재 스레드를 멈춰달라고 요청하고, 따라서 다른 스레드가 락을 확보해 객체 내부의 상태를 변경 할 수 있도록 해준다.
- 대기 상태에서 깨어나는 순간에는 해제했던 락을 다시 확보한다.
- wait 메소드 깨워주길 바란다! 라는 의미 notify, notifyAll 메소드 일이 발생했다고 알려주는 셈
  
~~~java

@ThreadSafe
public class BoundedBuffer<V> extends BaseBoundedBuffer<V> {
    // 조건서술어: not-full (!isFull())
    // 조건서술어: not-empty (!isEmpty())

    public BoundedBuffer(int size) {
        super(size);
    }

    // 만족할 때까지 대기 : not-full
    public synchronized void put(V v) throws InterruptedException {
        while (isFull())
            wait();
        doPut(v);
        notifyAll();
    }

    public synchronized V take() throws InterruptedException {
        while (isEmpty())
            wait();
        V v = doTake();
        notifyAll();
        return v;
    }
}

~~~
- 조건큐를 사용해 구현한 BoundedBuffer
- wait 과 notifyAll 메소드를 사용해 크기가 제한된 버퍼를 구현하고 있다. 
- 이전에 sleep 메소드로 대기 상태에 들어가던 메소드보다 구현하기 훨씬 간편하고, 훨씬 효율적이면서 응답성도 훨씬 좋다.
- 조건 큐를 사용했다고 해서 잠자기 대기 상태에 들어가던 버전과 비교해봤을때 그 작동하는 모습에는 변화가 없다는 점을 알아두자.
- 여러가지 측면 즉 CPU 사용의 효율성, 컨텍스트 스위치 관련 부하, 응답 속도 등의 측면에서 봤을때 그저 잠자기 대기상태에 들어가던 버전에 비해 몇가지 최적화 작업을 한 것 뿐이다.
- 조건 큐를 사용한다고해서 폴링과 대기 상태를 반복하던 버전에서 할 수 없던 일을 할수 있게 되는 경우는 없다.
- 하지만 조건 큐를 사용하면 상태 종속성을 관리하거 나 표현하는데 있어서 훨씬 효율적이면서 간편한 방법이긴 하다.
- BoundedBuffer는 이제 쓸만하게 구현됐다. 사용하기도 편리하고 상태 종속성도 깔끔하게 관리한다
- 상용으로 활용할 버전에는 put 메소드와 take 메소드에 타임아웃을 걸수 있는 기능도 추가해서 일정 시간 동안 작업을 처리하지 못할 경우 대기중이던 작업을 자동으로 멈출 수 있도록 준비하는 것도 좋다
- 오버로드된 object.wait 메소드 가운데 타임아웃을 지정 할 수 있는 메소드도 있는데, 이 메소드를 사용하면 put 과 take 메소드에 타임아웃을 쉽게 추가 할 수 있다.

## 14.2 조건 큐 활용
- 조건 큐를 사용하면 효율적이면서 응답 속도도 빠른 상태 종속적인 클래스를 구현 할 수 있지마 올바르지 않은 방법으로 사용할 가능성도 높다
- 컴파일러나 자바 플랫폼에서 정의하고 있지는 않지만, 조건큐를 제대로 활용하려면 꼭 지켜야만 하는 몇가지 규칙이 있다.
   - LinkedBlockingQueue, CountDownLatch, Semaphore, FutureTask 등 원하는 클래스를 기반으로 원하는 기능을 구현하라고 하는데 바로 이런원인
   - 만약 이런 클래스만으로 원하는 기능을 구현할 수 있다면 프로그래밍 작업이 간편해진다.

### 조건 서술어
- 조건 큐를 올바로 사용하기 위한 가장 핵심적인 요소는 바로 해당 객체가 대기하게 될 조건 서술어를 명확하게 구분해내는 일이다.
- wait, notify 를 사용함에 있어서 가장 많은 혼란을 줄 수 있는 요소가 바로 조건 서술어인데 자바 언어 명세나 API 문서에 조건 서술어라는 단어가 전혀 명시되어있지 않음
- 하지만 조건 서술어가 없으면 조건부 대기 기능이 동작 할 수 없다.
- 조건 서술어는 애초에 특정기능이 상태 종속적이 되도록 만드는 선행 조건을 의미한다.
- 크기가 제한된 버퍼를 예 take 메소드 입장에서 작업을 진행하기전에 확인해야만하는 버퍼에 값이 있어야 한다는것이 조건 서술어이다
- put 메소드 입장에서는 조건서술어는 버퍼에 빈 공간이 있다는 것이다
- 조건 서술어는 클래스 내부의 상태변수에서 유추 할 수 있는 표현식이다
- BaseBoundedBuffer 클래스는 버퍼에 값이 있어야한다는 조건 서술어에 대해 count 변수가 0보다 큰지 비교하고, 버퍼에 빈공간이 있어야 한다는 조건 서술어에 대해서는 count 변수의 값이 버퍼의 크기보다 작은지를 확인하다
- **조건 큐와 연결된 조건 서술어를 항상 문서로 남겨야 하며, 그 조건 서술어에 영향을 받는 메소드가 어느것인지도 명시해야 한다.**

- 조건부 대기와 관련된 락과 wait 메소드와 조건 서술어는 중요한 삼각관계를 유지하고 있다
- 조건 서술어는 상태변수를 기반으로 하고 있고, 상태변수는 락으로 동기화돼 있으나 조건서술어를 만족하는지 확인하려면 반드시 락을 확보해야만 한다
- 또한 락 객체와 조건큐 객체(wait, notify 메소드를 호출하는 대상객체)는 반드시 동일한 객체여야만 한다.
- BoundedBuffer 클래스는 버퍼락으로 버퍼의 상태를 동기화 하고 있으며 버퍼 락 자체를 조건 큐로 사용하고 있다.
- **wait 메소드를 호출하는 모든 경우에는 항상 조건 서술어가 연결돼 있다. 특정 조건 서술어를 놓고 wait 메소드를 호출 할때 호출자는 항상 해당하는 조건 큐에 대한 락을 이미 확보한 상태여야 한다. 또한 확보한 락은 조건 서술어를 확인하는데 필요한 모든 상태 변수를 동기화 하고 있어야한다.**
### 너무 일찍 깨어나기

### 놓친 신호

### 알림

### 예제: 게이트 클래스

### 하위 클래스 안정성 문제

### 조건 큐 캡슐화

### 진입 규칙과 완료 규칙

## 14.3 명시적인 조건 객체

## 14.4 동기화 클래스의 내부 구조

## 14.5 AbstractQueuedSynchronizer

### 간단한 래치

## 14.6 java.util.concurrent 패키지와 동기화 클래스에서 AQS 활용 모습

### ReentrantLock

### Semaphore 와 CountDownLatch

### FutureTask

### ReentrantReadWriteLock

### 요약

- 상태 기반으로 동작하는 클래스, 즉 메소드 가운데 하나라도 상태 갑셍 따라 대기상태에 들어갈 가능성이 있는 클래스를 작성해야할때 가장 좋은 방법은 ValueLatch 예제에서 본것처럼 기존에 만들어져 있는 Semaphore, BlockingQueue , CountDownLatch 등을 활용해 구현하는 방법이다.
- 이미 많은 종류의 동기화 클래스가 제공되고 있음에도 불구하고 적절한 기능을 찾을수 없다면, 암묵적인 조건 큐나 명시적인 Condition 클래스 또는 AbstractQueuedSynchronizer 클래스등을 활용해 직접 원하는 기능의 동기화 클래스를 작성 할 수도 잇겠다.
- 상태 의존성을 관리하는 작업은 상태의 일관성을 유지하는 방법과 맞물려 있기 때문에 암묵적이 조건 큐 역시 암묵적인 락과 굉장히 밀접하게 관련돼 있다.
- 이와 비슷하게 명시적인 조건 큐인 condition 클래스도 명시적인 Lcok 클래스와 밀접하게 관련돼 있으며, 락 하나에서 다수의 대기 큐를 활용하거나 대기 상태에서 인터럽트에 어떻게 반응하는지를 지정하는 기능, 스레드 대기 큐의 관리 방법에 대한 공정성 여부를 지정하는 기능, 대기상태에서 머무르는 시간을 제한할 수 있는 기능등과 같이 암묵적인 버전의 조건 큐나 락보다 훨씬 다양한 기능을 제공한다.

## 참고

책 자바 병렬 프로그래밍 14장
