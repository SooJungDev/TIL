## 16장 내용
- 16.1 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가
- 16.2 안전한 공개
- 16.3 초기화 안전성

## 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가
- 특정 스레드에서 aVariable 이라는 변수에 값을 할당한다고 해보자
~~~java
aVariable = 3;
~~~
- 동기화 기법을 사용하지 않는 상태라면 특정 스레드가 값이 할당되는 즉시, 심지어 영원히 3이라는 값을 읽어가지 못하는 여러가지 상황이 발생할 수 있다.
- 적절한 동기화 방법을 사용하지 않았다면 특정스레드에서 변수에 할당된 최신값을 읽어가지 못할 수 있으며 따라서 다른 스레드의 시각으로 보기에는 이상한 방향으로 실행될 가능성이 있다.
- 자바 언어 명세에서는 JVM 이 단일 스레드 내부에서 순차적으로 동작하는것과 동일하게 실행되도록 명시하고 있다.
- 멀티스레드로 실행되는 환경에서는 성능을 크게 제한하지 ㅇ낳는 한 순차성이 주는 안정성과 높은 성능은 찾아보기 어렵다.
- 병렬 프로그램이라 하더라도 대부분의 시간은 스레드 내부에서 각자의 작업을 처리하기 때문에 스레드 간의 작업 조율 기능에 자원을 많이 낭비하는 일은 별 이득도 없으면서 프로그램의 성능만 떨어뜨리는 결과를 낳기 십상이다.
- 스레드간의 작업을 조융하는데 꼭 필요한 데이터만을 공유해 사용하는것이 올바른 방법이고 JVM 은 동기화 기능을 사용하는 부분에 한해서 프로그램이 스레드간의 조율을 하고자 한다는 점을 파악 할 수 있다.
- JMM은 변수에 저장된 값이 어느 시점부터 다른 스레드의 가시권에 들어가는지에 대해 JVM 이 해야하는 최소한의 보장만 할 뿐이다.
- JMM은 예측성에 대한 필요와 함께 높은 성능의 JVM을 다양한 종류의 프로세서 구조에서 동작하도록 해야한다는 실제적인 요구 사항을 쉽게 구현할 수 있어야 한다는점을 균형을 맞출 목적으로 설계 됐다.
  
### 플랫폼 메모리 모델
- 메모리를 공유하는 멀티프로세서 시스템은 보통 각자의 프로세서 안에 캐시 메모리를 갖고 있으며, 캐시메모리의 내용은 주기적으로 메인 메모리와 동기화 된다.
- 하드웨어 프로세스 아키텍처는 저마다 다른 캐시 일관성을 지원한다.
- 멀티 프로세서 시스템에서 각 프로세서가 서로 다른 프로세서가 하는일을 모두 알 수 있도록 하려면 굉장한 부하를 안고가야한다.
- 프로세스는 대부분 성능을 높이고자 캐시 메모리의 일관성을 약간씩 희생하곤한다.
- 자바 개발자가 서로 다른 하드웨어가 갖고있는 각자의 메모리 모델을 직접 신겨ㅓㅇ쓰지 않도록 자바는 스스로의 메모리 모델인 JMM을 구성하고 있으며, JMM과 그 기반이 되는 하드웨어 메모리 모델의 차이점은 메모리 배리어를 적절히 활용하는 방법등으로 JVM 에서 담당해 처리한다.
- 프로그램이 실행되는 과정에서 변수에 마지막으로 설정한 값을 어떤 프로세서건 간에 정확하게 읽어 낼 수 있다고 가정하는 방법을 순차적 일관성이라고 부른다.
- 소프트웨어 개발자는 무의식적으로 순차적 일관성이 존재한다고 가정해버리는 경우가 많은데 현재 사용중인 어떤 프로세서도 순차적 일관성을 지원하지 않으며 JMM 역시 지원하지 않는다.
- 메모리를 공유해 사용하는 멀티프로세서 시스템에서는 여러 스레드에서 데이터를 공유하는 상황에서 메모리 배리어를 사용하지 않도록 일부러 지정한다면 놀랄만한 문제점이 쏟아질 것이다.
- 자바로 프로그램을 작성하는 과정에서 메모리 배리어를 어디에 어떻게 배치해야하는지 고민할 필요는 없다
- 단지 프로그램 내부에서 동기화 기법을 적절히 활용해 어느 시점에서 공유된 정보를 사용하는지만 알려주면 된다.

### 재배치
- JMM 은 서로 다른 스레드가 각자의 상황에 맞는 순서로 명령어를 실행할 수 있도록 허용하고 있기 때문에 동기화가 돼 있지 않은 부분을 놓고 실행 순서를 예측하는 일이 훨씬 더 복잡해 졌다.
- 특정 작업이 지연되거나 다른 순서로 실행되는 것처럼 보이는 문제는 재배치라는 용어로 통이해서 표현한다.
  
~~~java
public class PossibleReordering {
    static int x = 0, y = 0;
    static int a = 0, b = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread one = new Thread(new Runnable() {
            @Override
            public void run() {
                a = 1;
                x = b;
            }
        });

        Thread other = new Thread(new Runnable() {
            @Override
            public void run() {
                b = 1;
                y = 0;

            }
        });

        one.start();
        other.start();
        one.join();
        other.join();
        System.out.println("(" + x + "," + y + ")");
    }
}
~~~
- 제대로 동기화 되지 않아 어이없는 결과를 출력하기도 하는 프로그램, 이런 코드는 금물!
- 각 스레드 내부에서 일어나는 작업은 다른 스레드와의 연결 관계가 없으며, 따라서 순서가 재배치된 상태로 실행될 가능성이 있다
- PossibleReordering 간단한 프로그램이지만 가능한 모든 결과를 예측해보는 일은 이처럼 간단한 프로그램인 경우에도 쉽지 않다
- 메모리 수준에서의 재배치 현상은 프로그램이 오작동하게 만들기 십상이다.
- 동기화가 제대로 되지 않은 상태에서 재배치될 가능성을 예측하는 일은 너무나 어려우며, 반때로 동기화 방법을 적절하게 사용해 재배치 가능성을 없애는 편이 더 쉽다.
- 동기화가 잘된 상태에서는 컴파일러, 런타임, 하드웨어 모두 JMM이 보장하는 가시성 수준을 위반하는 쪽으로 메모리 관련 작업을 재배치하지 못하게 된다.

### 자바 메모리 모델을 간략하게 설명한다면
- 변수를 읽거나 쓰는 작업, 모니터를 잠그거나 해제하는 작업, 스레드를 시작하거나 끝나기를 기다리는 작업과 같이 여러가지 작업에 대해 자바 메모리 모델 JMM을 정의한다.
- JMM에서는 프로그램 내부의 모든 작업을 대상으로 미리 발생하느 부분 재배치 연산을 정의하고 있다.
- 하나의 변수를 두개 이상의 스레드에서 읽어가려고 하면서 최소한 하나 이상의 스레드에서 쓰기 작업을 하지만 쓰기 작업과 읽기 작업간에 미리 발생 관계가 갖춰져 있지 않은 경우에 데이터 경쟁 현상이 발생한다. - 이와 같은 데이터 현상이 발생하지 않는 프로그램을 올바르게 동기화된 프로그램이라고 말한다.
- 올바르게 동기화된 프로그램은 순차적 일관성을 갖고 있으며, 다시 말해 프로그램 내부의 모든 작업이 고정된 전역 순서에 global order 에 따라 실행된다는 것을 의미한다.

미리 발생 현상에 대한 규칙은 다음과 같다.
- 프로그램 순서 규칙: 특정 스레드를 놓고 봤을때 프로그램된 순서에서 앞서있는 작업은 동일 스레드에서 뒤에 실행되도록 프로그램된 작업보다 미리 발생한다
- 모니터 잠금 규칙: 특정 모니터 잠금 작업이 뒤이어 오는 모든 모니터 잠금 작업보다 미리 발생한다
- volatile 변수의 규칙: volatile 변수에 대한 쓰기 작업은 이후에 따라오는 해당 변수에 대한 모든 읽기 작업보다 미리 발생한다
- 스레드 시작 규칙: 특정 스레드에 대한 Thread.start 작업은 시작된 스레드가 갖고 잇는 모든 작업보다 미리 발생한다.
- 스레드 완료규칙: 스레드 내부의 모든작업은 다른 스레드에서 해당 스레드가 완료됐다는 점을 파악하는 시점보다 미리 발생한다. 특정 스레드가 완료됐는지 판단하는 것은 Thread.join 메소드가 리턴되거나 ThreadisAlive 메소드가 false 리턴하는지 확인하는 방법을 말한다
- 인터럽트 규칙: 다른 스레드를 대상으로 interrupt 메소드를 호출하는 작업은 인터럽트 당한 스레드에서 인터럽트 당했다는 사실을 파악하는 일보다 미리 발생한다.
- 인터럽트를 당했다는 사실을 파악하려면 interruptedException을 받거나 isInterrupted 메소드 또는 interrpeted 메소드를 호출하는 방법을 사용 할 수 잇다
- 완료 메소드 규칙: 특정 객체에 대한 생성메소드가 완료되는 시점은 완료 메소드가 시작하는 시점보다 미리 발생한다
- 전이성 : A가 B보다 미리 발생하고, B가 C보다 미리 발생한다면, A는 C보다 미리 발생한다.

- 작업이 부분적으로만 순서가 정해져 있다고 해도, 동기화 작업은 항상 완전하게 순서가 정해진 상태이다.
따라서 락을 확보한 이후에 연달아 일어나는 volatile 변수의 값을 읽는 작업에 대해 미리 발생 규칙을 적용하는 일도 충분히 가능한다.

### 동기화 피기백
- 락으로 보호돼 있지 않ㅇ는 변수에 접근해 사용하는 순서를 정의할때 모니터 락이나 volatile 변수의 규칙과 같은 여러가지 순서의 규칙에 미리 발생 규칙을 함께 적용해 순서를 정의하는 방법을 말한다.
- 이런 기법은 명령이 나열된 순서에 굉장히 민감하며 따라서 오류가 발생하기 쉽다.
- ReentrantLock 과 같이 성능에 중요한 영향을 미치는 클래스에서 성능을 떨어뜨릴 수 있는 아주작은 요인까지 완벽하게 제거해야 하는 상황이 오기전까지는 사용하지 않는 편이 좋다.
~~~java
// FutureTask의 내부 클래스
public final class Sync extends AbstractQueuedSynchronizer {
    private static final int RUNNING = 1, RAN = 2, CANCELLED = 4;
    private V result;
    private Exception exception;

    void innerSet(V v) {
        while (true) {
            int s = getState();
            if (ranOrCacelled(s)) { return; }
            if (compareAndSetState(s, RAN)) { break; }
        }
        result = v;
        releaseShared(0);
        done();
    }

    V innerGet() throws InterruptedException, ExecutionException {
        acquireInterruptibly(0);
        if (getState() == CANCELLED) { throw new CancellationException(); }
        if (exception != null) { throw new ExecutionException(exception); }
        return result;
    }

}
~~~  
- 동기화 피기백방법을 사용하고 있는 FutureTask의 내부 클래스 
- FutureTask는 미리 발생 규칙에 따라 tryReleaseShared 메소드 작업이 tryAcquireShared 메소드보다 항상 먼저 실행되도록 즉 tryReleaseShared 메소드에서 항상 tryAcquireShared 메소드가 읽어가는 변수에 쓰는 방법으로 세심하게 구현돼 있다.
- innerSet 메소드는 releaseShared 메소드를 호출하기 전에 result 변수에 값을 보관하고 innerGet 메소드는 aquireShared 메소드를 호출한 이후에 result 값을 읽어 간다.
- 이처럼 volatile 변수 규칙에 프로그램 순서 규칙을 적용함으로써 innerSet 메소드에서 result 변수에 값을 쓰는일이 innerGet 메소드에서 result 변수를 읽는 작업보다 반드시 먼저 발생하도록 조절하고 있다.
- 이와 같은 방법은 X 라는 객체의 값을 공개할때 미리 발생규칙을 따로 적용하기 보다는 다른 목적으로 만들어 사용하고 있는 미리 발생 순서 규칙을 X라는 객체의 가시성을 확보하는데도 함께 사용하기 때문에 피기백 piggybacking 이라고 부른다.
- FutureTask 클래스에서 사용하는 피기백방법은 오류가 발생할 가능성이 크기 때문에 대충사용해서는 안된다.
- BlockingQueue 를 사용하는 안전한 공개 기법 역시 피기백의 한 형태라고 볼 수 있다.

JDK 라이브러리에 들어있는 클래스 가운데 미리 발생 관계를 보장하고 있는 클래스는 다음과 같은것들이 있다.
- 스레드 안전한 컬렉션 클래스에 값을 넣는 일은 해당 컬렉션 클래스에서 값을 뽑아내는 일보다 반드시 미리 발생한다.
- CountDownLatch 클래스는 카운트를 빼는 작업은 await에서 대기하던 메소드가 리턴되는 작업보다 반드시 미리 발생한다
- Semaphore 에서 퍼밋을 해제하는 작업은 동일한 Semaphore 에서 퍼밋을 확보하는 작업보다 반드시 미리 발생한다
- Future 인스턴스에서 실행하는 작업은 해당하는 Future 인스턴스의 get 메소드가 리턴되기 전에 반드시 미리 발생한다
- Executor 인스턴스에서 Runnable 이나 callable 을 등록하는 작업은 해당 Runnable이나 Callable의 작업이 시작하기전에 미리 발생한다.
- CyclicBarrier 나 Exchange 클래스에 스레드가 도작하는 일은 동일한 배리어나 교환 포인트에서 다른 스레드가 풀려나는 일보다 미리 발생한다. CyclicBarrier 에서 배리어 동작을 사용하고 있엇다면, 배러어에 도착하는 일이 배리어 동작보다 반드시 미리 발생하고, 배리어 동작은 또한 해당 배리어에서 다른 스레드가 풀려나기전에 반드시 미리 발생한다.

### 안전한 공개
### 안전하지 못한 공개
- 프로그램상에서 공유된 참조를 공개하는 일이 다른 스레드에서 해당 참조를 읽어가는 일 보다 미리 발생하도록 확실하게 해두지 않으면 새로운 객체에 대한 참조에 값을 쓰는 작업과 객체 내부의 변수에 값을 쓰는 과정에서 재배치가 일어날 수 있다.
- 이와 같이 재배치가 일어나면 다른 스레드에서 객체 참조는 올바른 최신 참조 값을 사용하지만, 객체 내부의 변수 전체 또는 일부에 대해서는 아직 쓰기 작업이 끝나지 않은 상태의 예전값을 사용할 가능성이 있다.
~~~java
@NotThreadSafe
public class UnsafeLazyInitialization {
    private static Resource resource;

    public static Resource getInstance(){
        if(resource == null)
            resource = new Resource(); //안전하지 않은 공개
        return resource;
    }
}
~~~  
- 안전하지 않은 늦은 초기화 이런코드는 금물!
- 늦은 초기화 방법을 올바르게 사용하지 못하면 안전하지 않은 공개 상태에 다다르게 된다
- 경쟁조건이 있다고 판단
- 모든 Resource 인스턴스가 동일하다는 등의 특정상황에서는 이런 문제점을 정확하게 파악하지 못하고 그냥 지나칠 수 있다.
- 다른 스레드에서는 부분 구성된 인스턴스를 볼수 있기 때문에 UnsafeLazyInitialization 클래스는 여전히 위험성을 안고 있다.
- 스레드 A 에서 Resource 변수에 새로운 참조를 설정하는 작업과 스레드 B에서 resource 변수의 값을 확인하는 작업의 사이에 미리 발생 규칙이 전혀 적용되지 않았다는 문제점이있다.
- 객체를 공개할때 데이터 경쟁을 하도록돼 있으며, 따라서 Resource 클래스가 올바른 상태에 있을때 스레드 B가 사용하리라는 보장이 없다.
- 스레드 A,B 모두 전혀 동기화 작업이 돼 있지 않기 때문에 스레드 B 에서는 스레드 A가 실제로 실행하는 순서대신 A' 라는 다른 순서로 실행되는 모습을 보게 될 수 도있다.
- **불변 객체가 아닌 이상 , 특정 객체를 공개하는 일이 그 객체를 사용하려는 작업보다 미리 발생하도록 구성 돼 있지 않다면 다른 스레드에서 생성한 객체를 사용하는 작업은 안전하지 않다.**

### 안전한 공개
- 객체를 공개하는 작업이 다른 스레드에서 해당 객체에 대한 참조를 가져다 사용하는 작업보다 미리 발생하도록 만들어져 있기 때문에 공개된 객체가 다른 스레드에게 올바른 상태로 보인다는것을 뜻한다.
- BlockingQueue 클래스는 내부적으로 put 작업이 take 작업보다 항상 미리 발생하도록 충분히 동기화돼잇기 때문이다.
- 이와 비슷하게 락으로 보호돼 있는 공유 변수나 공유된 volatile 변수를 사용할때는 읽기 작업과 쓰기 작업에 대한 미리 발생 관계가 항상 보장돼 있다.
- 이와 같이 미리 발생 관계가 보장된다는 사실은 안전한 공개에 의해 보장되는 가시성과 실행순서보다 더 강력한 힘을 갖고있다.
- JMM은 이미 강력한 미리 발생 규칙에 따라 동작하고 있음에도 불구하고 왜 지금까지 안전한 공개기법에 초점을  맞춰왔을가?
- 일반적으로 프로그램을 작성할떄는 개별적으로 메모리에 쓰기 작업이 일어난 이후의 가시성을 놓고 안전성을 논하기보다는 객체의 소유권을 넘겨주고 공개하는 작업이 훨씬 적합하기 때문이다.
- 즉 미리 발생 규칙은 개별적인 메모리 작업의 수준에서 일어나는 순서의 문제를 다룬다.
- 말하자면 동기화 기법에 대하 어셈블리 언어에 해당하는 셈이다.
- 반대로 안전한 공개 기법은 일반적인 코드를 작성할때와 비슷한 수준에서 동작하는 동기화 기법이다.
  
### 안전한 초기화를 위한 구문
- UnsafeLazyInitialization 클래스의 문제점을 synchronized 키워드를 추가하는 것으로 해결할 수 있다.
- getInstance 메소드를 줄기차게 호출하지 않는 이상 클래스에 대한 락에 대해서는 경쟁이 그다지 많이 발생하지 않을 것이고 따라서 괜찮은 성능을 내줄것이라고 예상할 수 있다.

~~~java
@ThreadSafe
public class SafeLazyInitialization {
    private static Resource resource;
    
    public synchronized static Resource getInstance(){
        if(resource == null)
            resource = new Resource(); //안전하지 않은 공개
        return resource;
    }
}
~~~  
- 스레드 안전한 초기화 방법


- static 으로 선언된 변수에 초기화 문장을 함께 기술하는 밥법을 사용하면 스레드의 안전성을 추가적으로 보장받을 수 있다
- static 으로 선언된 초기화 문장은 JVM에서 해당 클래스를 읽어 들이고 실제 해당 클래스를 사용하기 전에 실행된다.
- 이런 초기화 과정에서 JVM이 락을 확보하며 각 스레드에서 해당 클래스가 읽혀져 있는지를 확인하기위해 락을 다시 확보하게 돼 있다.
- 결국 static 구문에서 초기화하는 객체는 생성될때나 참조될때 언제든지 따로 동기화를 맞출 필요가 없다.
- 초기화 된 객체의 내용이 그대로인 상태를 가정할때만 성립되며, 변경할수 잇다면 읽기,쓰기 스레드가  연달아 객체 내용을 변경할때마다 동기화를 맞춰야 변경된 내용을 다른 스레드에서 올바르게 볼수 있고 데이터에 오류가 발생하는 일도 막을 수 잇다.
  
~~~java
@ThreadSafe
public class EagerInitialization {
    private static Resource resource = new Resource();
    
    public static Resource getResource() {
        return resource;
    }
}
~~~
- 성질 급한 초기화   
- SafeLazyInitialization 클래스에서 getInstance를 호출할때마다 매번 처리했던 synchronized 구문을 제거할 수있다.
- 이 방법은 JVM이 사용하는 늦은 클래스 로딩기법과 함께 사용할 수 있으며, 자주 사용하는 코드에 대해서 동기화를 맞춰야할 필요를 줄일 수 잇다.
  

~~~java
@ThreadSafe
public class ResourceFactory {
    private static class ResourceHolder{
        public static Resource resource = new Resource();
    }
    
    public static Resource getResource(){
        return ResourceHolder.resource;
    }
}
~~~  
- 늦은 초기화 홀더 클래스 구문
- JVM 은 ResourceHolder 클래스를 실제로 사용하기 전까지는 해당 클래스가 초기화 하지 않으며 Resource 클래스 역시 static 초기화 구문에서 초기화하기 대문에 추가적인 동기화 기법을 적용할 필요 없다.
- 어느 스레드던간에 처음 getResource 메소드를 호출하면 JVM에서 ResourceHolder 클래스를 읽어들여 초기화하고 ResourceHolder 클래스를 초기화하는 도중에 Resource 클래스 역시 초기화하게 돼 있다. 

### 더블체크락
- 초기에 사용하던 JVM 은 경쟁이 별로 없는 상태라고 해도 동기화를 맞추려면 성능에 엄청난 영향을 주었다.
- 그 결과 동기화 기법이 주는 영향을 최소화하고자하는 여러가지 기발한 방법이 나타나기 시작했다. DCL 은 정말 문제 많은 방법에 속하는 방법이다.
- DCL은 자주 사용되는 클래스에 대해 늦은 초기화 작업을 하면서도 동기화 관련된 자원의 손실을 막을수잇는 방법으로 알려져왓다
- DCL은 먼저 동기화 구문이 없는 상태로 초기화 작업이 필요한지 확인하고 resource 변수의 값이 null 이 아니라면 resource변수에 참조된 객체를 사용한다.
- 만약 초기화 작업이 필요하다면 동기화 구문을 사용해 락을 걸고 Resource 객체가 초기화 됫는지 다시한번 확인하는데 이렇게 하면 Resource객체를 초기화하는 작업이 한번에 하나의 스레드만 가능하긴하다.
- 이미 만들어진 Resource 인스턴스에 대한 참조를 가져오는 부분은 동기화 돼있지 않았다.
- 부분 구성된 Resource 인스턴스를 사용하게 될 가능성이 있다.
- DCL가 갖고있는 더큰 문제는 동기화 돼 있지않은 상태에서 발생할수 있는 가장 심각한 문제가 스테일 값을 사용할 가능성이 있는 정도에 불과하다고 추정하고 있는 점이다.
- 현재 객체에 대한 참조를 제대로 본다 하더라도 객체의 상태를 볼때 스테일 값을 보게되는 경우, 즉 참조된 객체 내부의 상태가 올바르지 않은 상태인 경우가 생길 수 있다.
- 수정된 JMM 내용을 보면 resource변수를 volatile 로 선언햇을때 DCL마저 정상적으로 동작한다
- 또한 volatile 변수에 대한 읽기 연산은 volatile 아닌 변수의 읽기 연산보다 자원을 아주 조금더 사용할 뿐이기 떄문에 성능에 미치는 영향도 미미하다.
- DCL 이 해결해고자 했던 경쟁이 없을때도 느린 동기화 구문 시동하는데 시간이 많이 걸리는 문제는 이미 시대가 지나면서 대부분 사라졋으며 최적화의 이미를 찾기가 어려워 졌다
- 하지만 늦은 초기화 홀도 클래스 구문은 DCL보다 훨씬 이해하기 쉬우면서 동일한 기능을 제공한다. 

~~~java
@NotThreadSafe
public class DoubleCheckedLocking {
    private static Resource resource;

    public static Resource getInstance() {
        if (resource == null) {
            synchronized (DoubleCheckedLocking.class) {
                if (resource == null)
                    return new Resource();
            }
        }
        return resource;
    }
}
~~~  
- 더블 체크 락 패턴, 이런코드는 금물!

## 초기화 안전성   
- 초기화 안전성을 보장한다는 의미는 올바르게 생성된 불변 객체를 어떤 방법으로건 심지어 데이터 경쟁이 발생하는 방법으로 공개하더라도 여러 스레드에서 별다른 동기화 구문없이 안전하게 사용할수 있다는 의미이다.
- String 객체의 불변성을 기반으로 설계된 보안 아키텍처가 있다고 하면 초기화 안전성을 확보하지 못하는 경우 악의적인 프로그램이 보안 검증 과정을 통과하도록 하는 보안상의 허점이 되기도 한다.
- 초기화 안전성이 확보돼 있다면 완전하게 구성된 객체를 대상으로 해당 객체가 어떻게 공개됐던 간에 생성메소드가 지정하는 모든 final 변수의 값을 어떤 스레드건 간에 올바르게 읽어갈수 있다는 점을 보장한다
- 또한 완전하게 구성된 객체 내부에 final 로 선언된 객체를 거쳐 사용할수 있는 모든 변수역시 다른 스레드에서 안전하게 볼수 있다는 점도 보장된다.
- final 로 선언된 변수를 갖고 있는 클래스는 초기화 안전성 조건 때문에 해당 인스턴스에 대한 참조를 최초로 생성하는 과정에서 재배치 작업이 일어나지 않는다.
- 해당객체에 대한 참조를 가져간 모든 스레드는 최소한 고정된 상태에 있는 변수의 값은 볼 수 있다
- final 변수를 통해 접근 가능한 변수에 초기화를 위해 쓰기 작업을 하는 경우 생성메소드에서 고정되는 시점 이후에 쓰기 작업이 동작한다 해도 역시 재배치 현상이 발생하지 않는다. 
     
~~~java
@ThreadSafe
public class SafeStates {
    private final Map<String, String> states;

    public SafeStates() {
        states = new HashMap<>();
        states.put("alaska", "AK");
        states.put("alabama", "AL");
        states.put("wyoming", "WY");

    }

    public String getAbbreviation(String s) {
        return states.get(s);
    }
}
~~~   
- 불변 객체의 초기화 안전성
- 별다른 동기화 하지 않고 스레드에 안전하지 않은 HashSet 을 사용한다해도 이를 대상으로 안전하지 않은 늦은 초기화 작업을 진행하거나 동기화 구문없이 SafeStates 에 대한 참조를 public static 으로 선언된 변수에 선언하는 것만으로 안전하게 공개 할 수 있다는 뜻이다.
- 예를 들어 states 변수가 final 로 선언되지 않았거나, 생성 메소드가 아닌 다른 메소드에서 states 변수의 내용을 변경 할 수 있도록 돼있다면 초기화 안전성이 힘을 잃으면서 동기화 구문을 추가로 사용하지 않는 한 SafeStates 클래스를 안전하게 사용 할 수 없게 된다.
- 그리고 SafeStates클래스에 final로 선언되지 않은 다른 변수가 더있다면 final 이 아닌 변수에 대해서는 다른 스레드에서 올바르지 않은 값을 보게 될 수도 있다.
- 또한 생성 메소드가 완료되기 전에 해당 객체를 외부에서 사용 할 수 있도록 유출 시키는 작업 역시 초기화 안전성을 무너뜨리는 일이다
- **초기 안전성은 생성 메소드가 완료되는 시점에 final로 선언된 변수와 해당 변수를 거쳐 접근 할 수 잇는 값에 대해서만 가시성을 보장한다 final 로 선언되지 않은 변수나 생성 메소드가 종료된 이후에 변경되는 값에 대해서는 별도의 동기화 구문을 적용해야 가시성을 확보 할 수 있다.**                                                                                                                           

## 요약
- 자바 메모리 모델은 특정 스레드에서 메모리를 대상으로 취하는 작업이 다른 스레드에게 어떠헥 보이는지 여부를 명시하고 있다
- 가시성을 보장해주는 연산은 미리 발생이라는 규칙을 토앻 부분적으로 실행 순서가 정렬된 상태를 유지하며, 미리 발생 규칙은 개별적인 메모리 작업이나 동기화 작업의 수준에서 정의하는 규칙이다.
- 충분히 동기화되지 않은 상태에서는 공유된 데이터를 여러 스레드에서 사용할때는 굉장히 이상한 현상이 발생할 수있다.
- 어쨌거나 2장과 3장에서 소개했던 @GuardedBy 나 안전한 공개등 고수준의 방법을 적용하면 미리 발생 규칙과 같은 저수준의 세밀한 부분까지 신경쓰지 않는다해도 스레드 안전성을 보장 할 수 있다.

## 참고
책 자바 병렬 프로그래밍 16장