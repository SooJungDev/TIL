## 3장 내용
- 3.1 가시성
- 3.2 공개와 유출
- 3.3 스레드 한정
- 3.4 불변성
- 3.5 안전 공개

## 3.1 가시성
- **변수를 공유하지만 동기화 되지 않은 예제 이런 코드 금물**
~~~java
public class NoVisibility {
    // 변수 공유 사용
    private static boolean ready;
    private static int number;

    // 0 출력 , 영원히 값 출력하지 못하고 ready 변수의 값이 true 로 바뀌기를 계속해서 기다릴수 있음
    private static class ReaderThread extends Thread {
        public void run(){
            while (!ready)
              Thread.yield();
            System.out.println(number);
        }
    }

   public static void main(String[] args) {
       // 메인 스레드는 일기 스레드를 실행시킨다음 number 42, ready true 로 변경
       new ReaderThread().start();
       number = 42;
       ready = true;
   }
}
~~~
- ready 변수의 값을 읽기 쓰레드에서 영영 읽지 못할 수 도 있기 때문에 무한 반복에 빠질 수 있다.
- 더이상하게는 읽기 쓰레드가 메인 스레드에서 number 변수에 지정한 값보다 ready 변수의 값을 먼저 읽어가는 상황도 가능하다
- 흔히 말하는 재배치라고 하는 현상
- 재배치 현상은 특정 메소드 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장 할 수 없다는 점에 기인하는 문제 여러 스레드가 동시에 동작하는 경우에 확연하게 나타남
- **동기화 기능을 지정하지 않으면 컴파일러나 프로세서, JVM 등이 프로그램 코드가 실행되는 순서를 임의로 바꿔 실행하는 이상한 경우가 발생하기도 한다 다시말하자면 동기화 되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 반드시 이런순서로 동작 할 것이다라고 단정 지을 수 없다.**
- 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용한다.

스테일 데이터
- 읽기 쓰레드가 ready 변수의 값을 일으려 할 때, 이미 최신 값이 아니었기 때문이다.
- 변수를 사용하는 모든 경우에 동기화를 시켜두지 않으면 해당 변수에 대한 최신값이 아닌 다른 값을 사용하게 되는 경우가 발생할 수 있다.
- 더 큰문제는 스테일 데이터를 사용 할 때도 있고 정상적으로 동작하는 경우도 있다는점
- 특정 스레드가 어떤 변수를 사용할때 정상적인 최신값을 사용 할 수도 잇고 올바르지 않은 값을 사용 할 수도 있다는말
- **스테일 데이터일 경우 사용할 경우 심하면 안전에 심각한 문제를 유발하거나 프로그램이 멈추는 지경에 이를수 있음**


~~~java
@NotThreadSafe
public class MutableInteger{
    private int value;

    public int get() { return value; }
    public void set(int value) { this.value = value; }
}
~~~
- value 라는 변수의 값을 get,set 메소드에서 동시에 사용함에도 불구하고 동기화가 되어 있지 않기 떄문에 여러 스레드에서 동시에 사용하면 문제가 발생할 소지가 많다. 문제점 가운데 가장 큰 문제 스테일 현상
- 다중 스레드에서 값을 제대로 읽어 가지 못할 가능성이 있다.

~~~java
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() { return value; }
    public synchronized void set(int value) { this.value = value; }
}
~~~
- get, set 에 동기화시켜 MutableInteger 클래스의 문제점 제거
- set 만 동기화 시켰다면 어차피 get 메소드가 여전히 스테일 상황을 초래 할 수 있기 때문에 효과 X


단일하지 않은 64비트 연산
- 64비트를 사용하는 숫자형 double, log에 volatile 키워드를 사용하지 않은 경우에는 난데없는 값마저 생길 가능성있음
- volatile 로 지정되지 않은 long dlfkd double 형의 64비트 값에 대해서는 메모리에 쓰거나 읽을때 두번의 32비트 연산을 사용 할 수 있도록 허용하고 있다.
- 따라서 voliatile 을 지정하지 않은 long 변수의 값을 쓰는 기능과 읽는 기능이 서로 다른 스레드에서 동작한다면 이전값과 최신값에서 각각 32 비트를 읽어올 가능성이 생김
- **volatile 로 지정하지 않고 락을 사용해 동기화하지 않은 상태로 long 이나 double 값을 동시에 여러 스레드에서 사용 할 수 있다면 항상 이상한 문제를 만날 가능성이 있다.**

락과 가시성
- 값을 변경 할 수 있는 변수를 여러개의 스레드에서 동시에 사용한다면 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드에서 사용 할 수 있게 하기 위해 동일한 락을 사용하는 synchronized 블록으로 막아줄 필요가 있다. 바꿔 말하자면 여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않는다면 스테일 상태에 쉽게 빠질 수 있다.
- **락은 상호 배제뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용한다. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화 시켜야 한다.**

volatile 변수
- volatile로 선언된 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어 갈 수 있도록 해준다.
- 특정 변수를 선언 할 때 volatile 키워드를 지정하면 컴파일러와 런타임 모두 이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치 해서는 안된다 하고 이해한다.
- volatile 변수는 프로세서의 레지스터에 캐시되지 않고 프로세서 외부의 캐시에도 들어가지 않기 때문에 volatile 변수의 값을 읽으면 항상 다른 스레드가 보관해둔 최신 값을 읽어 갈 수 있다.
- volatile 변수를 사용 할 때에는 아무런 락이나 동기화 기능이 동작하지 않기 때문에 synchronized 를 사용한 동기화 보다는 아무래도 강도가 약할 수 밖에 없다.

**동기화하고자 하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용하자
반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋다. volatile 변수를 사용하는 적절한 경우는 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우등이 해당된다.**

~~~java
volatile boolean asleep;
...
  while(!asleep)
    countSomeSheep();
~~~
- 락을 사용하면 가시성과 연산의 단일성을 모두 보장 받을 수 있다. 하지만 volatile 변수는 연산의 단일성은 보장하지 못하고 가시성만 보장한다.

volatile 변수는 다음과 같은 상황에서 사용
- 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재
- 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어 있지 않다.
- 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우

## 3.2 공개와 유출
- 특정 객체를 현재 코드의 스코프 범위 밖에서 사용 할 수 있도록 만들면 공개되었다고한다.
    - ex) 스코프 밖의 코드에서 볼 수 있는 변수에 스코프 내부의 객체에 대한 참조를 저장
    - ex) private 이 아닌 메소드에서 호출한 메소드가 내부에서 생성한 객체를 리턴
    - ex) 다른 클래스의 메소드로 객체를 넘겨주는 경우
- 객체가 안정적이지 않은 상태에서 공개하면 스레드 안전성에 문제가 생길 수 있다.
- 의도적으로 공개시키지 않았지만 외부에서 사용 할 수 있게 공개된 경우를 유출 상태(escaped)라고 한다.

객체 공개
~~~java
public static Set<Scret> knownSecrets;

public void initialize(){
    knownSecrets = new HashSet<Scret>();
}
~~~

~~~java
class UnsageStates {
    private String[] states = new String[] {
        "AK", "AL" ...
    };
    public String[] getStates() { return states; }
}
~~~
- private 키워드를 지정해 숨겨져 있는 states 변수를 위와 같이 공개하면 getStates 메소드를 호출하는 곳에서 숨겨진 states 변수의 값을 직접 변경 할 수 있기 때문에 권장할 만한 방법 아님
- getStates 메소드를 통해 외부에 공개, states 변수 유출 상태에 놓임

~~~java
public class ThisEscape{
    public ThisEscape(EventSource source) {
        source.registerListener(
            new EventListener() {
                public void onEvent(Event e) {
                    dosomething(e);
                }
            }
        )
    }
}
~~~
- this 클래스에 대한 참조를 외부에 공개해야되는 상황 이런코드 금물
- 내부 클래스의 인스턴스를 외부에 공개하는 경우
  - 내부 클래스는 항상 부모 클래스에 대한 참조를 갖고있기 때문에 ThisEscape 클래스가 EventListener 객체를 외부에 공개하면 EventListener 클래스가 포함하고 있는 ThisEscape 클래스도 외부에 노출 된다.

~~~java
public class SafeListener {
    private final EventListener listener;

    // 생성자는 private 으로 지정하는것이 좋음
    private SafeListener(){
        listener = new EventListener() {
            public void onEvent(Event e){
                doSomething(e);
            }
        };
    }

    // public 으로 지정된 팩토리 메소드 사용하는 방법이 좋음
    public static SafeListener newInstance(EventSource source){
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
~~~
- 생성 메소드에서 this  변수가 외부로 유출되지 않도록 팩토리 메소드를 사용하는 모습
- 스레드를 생성하면서 바로 시작시키기보다는 스레드를 시작시키는 기능을 start 나 initialize 등의 메소드로 만들어 사용하는 편이 좋다.
- 생성 메소드에서 오버라이드 가능한 메소드를 호출하는 경우가 있다면 this 참조가 외부에 유출될 가능성이 있다.
  

## 3.3 스레드 한정
- 특정 객체를 단일 스레드에서만 활용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없다.
- 이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안정성을 확보 할 수 있다.
- 객체 인스턴스를 특정 스레드에 한정 시켜두면 해당하는 객체가 아니라 해도 자동으로 스레드 안전성으 확보하게 된다.
- ex) Swing 이벤트 처리 스레드에 컴포넌트와 모델을 한정시켜 스레드 안정성을 확보
- ex) JDBC 의 Connection 객체를 풀링해 사용하는 경우
- 개발자는 스레드에 한정된 객체가 외부로 유출되지 않도록 항상 신경써야 한다.
  
스레드 한정 주먹구구식
- 특정 스레드에 한정하려는 객체가 volatile 로 선언되어있다면 약간 특별한 경우
- 일기와 쓰기가 모두 가능한 volatile 변수를 공유해 사용할 떄에는 특정 단일 스레드에서만 쓰기 작업을 하도록 구현해야 안전하다.
- 이런 경우 경쟁조건을 막기 위해 변경작업은 특정 스레드 한곳에서만 할 수 있도록 제한해야하고 읽이 작업이 가능한 다른 모든 스레드는 volatile 변수의 특성상 가장 최그넹 업데이트 된 값을 정확하게 읽어 갈 수 있다.
- 임시 방편적인 스레드 한정기법은 안전성을 완벽하게 보장 할 수 있는 방법은 아니기 때문에 꼭 필요한 곳에만 제한적으로 사용하는것이 좋다.

스택 한정

## 3.4 불변성

## 3.5 안전 공개

## 스터디 후 느낀점


## 참고
책 자바 병렬 프로그래밍 3장 