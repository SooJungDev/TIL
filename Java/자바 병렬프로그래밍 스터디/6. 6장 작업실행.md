## 6장 내용
- 6.1 스레드에서 작업 실행
- 6.2 Executor 프레임웍
- 6.3 병렬로 처리할 만한 작업

## 6.1 스레드에서 작업 실행
- 대부분 벙렬 애플리케이션은 작업(task) 을 실행하는 구조가 효율적으로 구성되어 있다.
- 작업이란 추상적이면서 명확하게 구분된 업무단위
- 프로그램이 해야 할 일을 작업이라는 단위로 분할하면 프로그램 구조를 간결하게 할수 있고, 트랜잭션의 범위를 지정함으로써 오류에 효과적으로 대응, 작업실행 부분의 벙렬성을 자연스럽게 극대화 할 수 있음


- 작업은 완전히 독립적인 동작을 말함
- 다른 작업의 상태, 결과 부수효과등에 영향을 받지 않아야한다.
- 독립성이 갖춰져 있어야 병렬성을 보장 할 수 있는데 독립적인 작업이라야 적절한 자원이 확보된 상태에서 병렬로 실행될 수 있다.
- 작업을 스케줄링하거나 부하 분산을 하고자 할 때 폭넓은 유연성을 얻으려면 각 작업이 어플리케이션의 전체적인 업무 내용가운데 충분히 작은 부분을 담당하도록 구성되어있어야한다.
- 어플리케이션에 부하가 가해지는 상황에서는 그냥 죽어버려서는 안되고 부하에 따라 성능이 점진적으로 떨어지도록 설계돼 있어야한다.
    - 위와 같이 하려면 작업의 단위의 범위를 적절하게 설정하고 작업을 싱행하는 정책을 면밀하게 구성해야함
- 가장 쉽게 생각 할 수 있는 작업의 단위
    - 클라이언트의 요청하나를 작업 하나로 볼수있음
- 클라이언트의 개별 요청 단위를 작업의 범위로 지정한다면 대략 독립성을 보장 받으면서 작업의 크기를 적절하게 설정하는것이라고 볼수 있음
    - ex) 메일서버에 메세지를 전송하고 결과값을 받는 작업 (다른 클라이언트와 상관 X)

###  작업을 순차적으로 실행
- 작업을 실행하는 가장 간단한 방법은 단일스레드에서 작업목록을 순차적으로 실행하는 방법
~~~java
class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        // 포트 80에 접속하는 클라이언트 요청을 순차적으로 처리하는 모습
        ServerSocket socket = new ServerSocket(80);
        while (true){
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
~~~
- 순차적으로 처리하는 웹서버
- 한번의 하나의 요청만을 처리 할 수 있음
    - 성능 매우 떨어짐
    - 웹서버가 이전 클라이언트 요청을 처리하는 도중이라면 다음요청한 클라이언트는 웹서버가 이전 작업을 끝나기만을 기다려야함
- 단일 스레드로 처리하는 도중에는 어떤 작업에건 대기상태에 들아간다는 의미
    - 단리 처리시간이 길어진다는 문제만 있는것은 아님
    - 다른요청을 전혀 처리하지 못한다는 문제
- 단일스레드에서 I/O 작업을 하는 동안 CPU가 대기하고 있어야하는등 서버 하드웨어 자원을 제대로 활용하지 못하는 문제점
- 순차적인 처리 방법을 사용했을때 높은 처리량과 빠른 반응속도 가운데 어느것도 제대로 만족하지 못할 가능성이 있다
- 예외 작업의 개수가 아주 적으면서 하나의 작업을 처리하는데 오래걸리는 경우나 한번에 하나의 요청만을 전송하는 클라이언트 하나만을 상대하는 경우 반응속도 잘나옴 대부분 서버에서는 이런 환경에서 사용하지 않는다
  
### 작업마다 스레드를 직접 생성
- 반응속도를 높일수 있는 방법가운데 하나의 요청이 들어올때마다 새로운 스레드를 하나씩 만들어 실행시키는 방법
~~~java
class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket();
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                @Override
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }
}
~~~
- 요청이 들어올때마다 스레드를 생성하는 웹서버
- 클래스 구조만 본다면 위와 크게 다르지 않음, 메인스레드에서 여전히 클라이언트 접속을 대기하다가 요청이 들어오면 적절하게 처리하는 과정을 반복
- 클라이언트 요청 내용을 메인스레드에서 직접 처리하지 않고 클라이언트가 접속할 떄마다 반복문에서 해당 클라이언트의 요청 처리를 담당하는 새로운 스레드를 매번 생성한다는 차이점

변경했을때 크게 3가지 결과
- 작업을 처리하는 기능이 메인스레드에서 떨어져나온다. 따라서 메인 반복문 다음 클라이언트 접속을 기다리는 부분 빨리 넘어갈수 있음 클라이언트는 이전 작업이 끝나기 이전에라도 언제든지 서버에 접속해 요청을 전송할수 있기 때문에 서버의 응답속도를 높여줌
- 동시에 여러 작업을 병렬로 처리 할 수 있기 떄문에 두개 이상의 요청을 받아 동시에 처리 할 수 잇다.
- 서버의 하드웨어에 여러개의 프로세서(CPU)가 장착되어 잇다면 전반적으로 처리 속도를 향상 할 수 있고 각 작업에서 I/O 기능이 실행되기를 기다리는 부분이 있거나 락을 확보하기 위해 대기하는 부분 또는 기타 특정자원을 사용하기위해 대기하는 부분이 있는 경우에 서버의 처리속도를 높여 줄 수 있다.
- 실제 작업을 처리하는 스레드의 프로그램은 여러 클라이언트가 접속하는 경우 동시에 동작할 가능성이 매우 높기 때문에 스레드 안전성을 확보해야한다.


- 작업별로 스레드를 생성해 처리하는 방법으로는 웬만한 부하까지는 견딜수 있으며, 순차적인 실행 방법에 비하면 크게 향상
- 다만 클라이언트가 접속해 요청을 전송하는 속도에 비해 요청을 처리해 응답을 넘겨주는 속도가 빨라야한다는 제약 제약이 지켜지면 괜찮은 응답 속도와 성능을 보여줌

### 스레드를 많이 생성할 때의 문제점
- 작업마다 스레드를 생성하는 정책은 상용서비스에서 사용하기는 무리
- 특정 상황에서 엄청나게 많은 대량의 스레드가 생성할 수 있는데 단점이 발생함

스레드 라이프 사이클 문제 
- 스레드를 생성하고 제거하는 작업에도 자원이 소모
- 스레드를 생성하는 과정에는 일정량의 시간이 필요 따라서 클라이언트 요청을 처리할때 딜레이가 발생
- 클라이언트 요청이 자주 발생하는 유형이면 요청이 들어올때마다 새로운 스레드를 생성하는 일이 상대적으로 전체작업에서 많은 부분을 차지 할 수 있다.
  
자원 낭비
- 실행중인 스레드는 시스템자원 특히 메모리 소모
- 하드웨어 실제로 장착되어있는 프로세서보다 많은 수의 스레드가 만들어져 동작중이라면, 실제로는 대부분의 스레드가 대기 상태에 머무른다.
- 대기상태에 머무르는 스레드가 많아지면 많아질수록 많은 메모리 필요로하며 JVM 가비지 콜렉터에 가해지는 부하가 늘어날 뿐만 아니라 CPU를 사용하기 위해 여러스레드가 경쟁하여 메모리 이외에도 많은자원 소모
- cpu 개수의 해당하는 스레드가 동작중이라면, 스레드를 더 만들어낸다해도 성능이 직접적으로 개선 되지 않을수 있으며, 악영향을 미칠 가능성도 있음

안전성 문제
- 모든 시스템에는 생성할 수 잇는 스레드의 개수가 제한
- 제한되어있는 개수 플랫폼과 운영체제마다 다름, jvm을 실행할떄 지정하는 인자나  Thread 클래스에 필요한 스택의 크기에 따라서 달라짐
- 만약 제한된 양을 모두 사용하고나면 OutOfMemoryError 가 발생 
    - 오류 바로잡을 방법 별로없으며 가능하다고해도 안정적으로 처리하기 어려움
    - 제한된 값 안에서 동작하도록 생성해 OutOfMemoryError 가 발생하지 않도록 방지하는 방법이 쉬움
- 32비트 시스템이라면 큰 제약요소는 스레드 스택에 적용되는 주소공간
    - 자바 코드와 네이티브 코드를 실행할수 있도록 모든 스레드는 두개의 스택 
  
- 스레드 추가로 만들어서 사용해서 성능상의 이점을 얻을 수 있지만 특정 수준을 넘어간다면 성능이 떨어짐
    - 계속 생성한다면 어플리케이션 다운됨
- 어플리케이션이 만들어 낼 수 있는 스레드 제한을 두는것이 현명한 방법
- 제한을 행을때 제한된 수의 스레드만으로 동작할때 용량이 넘치는 요청이  들어오는 상황에서도 자원이 고갈되어 멈추는경우가 발생하지 않는지 세심하게 테스트해야함
- 실제 개발하는 과정에서 문제 없을 수 있음 서버가 다운되고 이러한 문제는 엄청난 부하가 가해졌을때만 발생 
- 이런 문제가 발생한다면 성능이 점진적으로 떨어지도록 만들어야 할 서버 어플리케이션에서 치명적인 오류이다.
  

## 6.2 Executor 프레임웍
- 작업 task은 논리적인 업무의 단위 스레드는 특정 작업을 비동기적으로 동작 시킬 수 있는 방법을 제공
- 순차적인 방법은 응답속도외 전체적인 성능 크게 떨어지는 문제점이 있다.
- 작업별로 스레드를 만들어내는 방법은 자원 관리 측면에서 허점이 있다.
- 5장에서 크기가 제한된 큐 bounded queue 를 사용해 부하가 크게 걸리는 어플리케이션에서 메모리를 모두 소모해 버리지 않도록 통제하는 방법
- 스레드 풀은 스레드를 관리하는 측면에서 이와 같은 통제력을 갖출수 있게 해준다.
- java.util.concurrent 패키지에 보면 Executor 프레임웍의 일부분으로 유연하게 사용할 수 있는 스레드 풀이 만들어져 있다.
- 자바에서 작업을 실행하고자 할 때는 Thread 보다 Executor가 훨씬 추상화가 잘되어있으며 사용하기 좋다

~~~java
public interface Executor {
    void execute(Runnable command);
}
~~~
- Executor 인터페이스
- 다양한 여러가지 종류의 작업 실행 정책을 지원하는 유연하면서도 강력한 비동기적 작업 실행 프레임웍의 근간을 이루는 인터페이스
- 작업등록(task submission)과 작업실행(task execution)을 분리하는 표준적인 방법이며 각 작업은 Runnable 형태로 정의한다.
- 작업의 라이프 사이클을 관리하는 기능, 통계값을 뽑아내거나 어플리케이션에서 작업 실행과정을 관리하고 모니터링 하기 위한 기능도 가지고 있음
- 프로듀서-컨슈머 패턴에 기반하고 있으며, 작업을 생성해 등록하는 클래스가 프로듀서가되고 작업을 실제로 실행하는 스레드가 컨슈머가 되는 구조
- 일반적으로 프로듀서-컨슈머 패턴을 어플리케이션에서 적용해 구현 할 수 있는 가장 쉬운방법이 Executor 프레임워크를 사용하는 방법

### Executor 를 사용한 웹서버 
- 웹서버를 구현 할 때 Executor 를 적용하면 작업이 굉장히 간단해짐
~~~java
class TaskExecutionWebServer {
    private static final int NTHREADS = 100;
    private static final Executor exec = Executors.newFixedThreadPool(NTHREADS);// 백개의 고정된 스레드풀

    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                @Override
                public void run() {
                    handleRequest(connection);
                }
            };
            exec.execute(task);
        }
    }
}
~~~
- 스레드 풀을 사용한 웹서버 
- Executor 를 사용하면 Executor 설정을 변경하는것만으로 쉽게 변경된다
- Executor 에 필요한 설정은 대부분 초기에 한번 지정하는것이 보통이며 처음 실행하는 시점에 설정값을 지정하는 편이 좋다.
- 하지만 Executor 을 사용해 작업을 등록하는 코드는 전체 프로그램의 여기저기에 퍼져있는 경우가 많기 때문에 한눈에 보기 어려움
- 위의 구조를 그대로 유지하면서 들어오는 요청마다 새로운 스레드를 생성해 실행하도록 변경
    - Executor 를 상속받아 또다른 모양으로 동작하는 클래스를 쉽게 구현 할 수 있음

~~~java
public class ThreadPerTaskExecutor implements Executor {
    @Override
    public void execute(Runnable r) {
        new Thread(r).start();
    }
}
~~~
- 작업마다 스레드를 새로 생성시키는 Executor

TaskExecutionWebServer 가 작업을 순차적으로 처리하도록 만드는 일도 아주 간단하다
~~~java
public class WithInThreadExecutor implements Executor {
    @Override
    public void execute(Runnable r) {
        r.run();
    }
}
~~~
- 작업을 등록한 스레드에서 직접 동작시키는 Executor
- execute 메소드 안에서 요청에 대한 처리 작업을 모두 실행하고 처리가 끝나면 executor 에서 리턴되도록 구현하면 된다.

### 실행정책
- 작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 기타 여러가지 어려운 상황에 맞닥뜨리지 않으면서도 실행정책을 언제든 쉽게 변경 할 수 있다는 장점이 있다.
  
실행정책은 다음과 같이 무엇을 어디에서 언제 어떻게 실행하는지 지정할 수 있다.
- 작업을 어느 스레드에서 실행할 것인가
- 작업을 어떤 순서로 실행할것인가 (FIFO, LIFO, 기타 다양한 우선순위 정책)
- 동시에 몇개의 작업을 병렬로 실행할 것인가?
- 최대 몇개까지의 작업이 큐에서 실행을 대기 할 수 있게 할 것인가?
- 시스템에 부하가 많이 걸려서 작업을 거절해야하는경우 어떤 작업을 희생양으로 삼아야 할 것이며, 작업을 요청한 프로그램에 어떻게 알려야 할것인가
- 작업을 실행하기 직전이나 실행한 직후에 어떤 동작이 있어야 하는가?

- 실행정책은 일종의 자원관리 도구
- 최적화된 실행정책을 찾으려면 하드웨어나 소프트웨어적인 자원을 얼마나 확보 할 수 있는지 확인해야하고 어플리케이션의 성능과 반응속도가 요구사항에 얼마만큼 명시되어있는지도 알아야한다
- 병렬로 실행되는 스레드의 수를 제한한다면 아마도 어플리케이션에서 자원이 모잘라는 상황에 다다르거나 제한된 자원을 서로 사용하기 위해 각작업이 경쟁하느라 어플리케이션의 성능이 떨어지는 일은 별로 보기 어려울 것이다.
  - 트랜잭션 모니터가 담당하는 부분과 유사
  - 트랜잭션 모니터는 트랜잭션이 처리하는 속도에 제한을 가할수 있으며, 따라서 제한된 자원을 사용하면서 자원이 부족한 상황이나 부하에 시달리지 않도록 해준다.
- 실행정책과 작업 등록 부분을 명확하게 분리시켜두면 어플리케이션을 실제 상황에 적용하려 할 때 설치할 하드웨어와 기타 자원의 양에 따라 적절한 실행정책을 임의로 지정 할 수 있다.
  

~~~java
new Thread(runnable).start();
~~~
- 위와 같은 코드가 남아있다면 이런 부분에 유연한 실행정책을 적용할 준비를 해야할 것이며
- **나중을 위해 Executor 를 사용해 구현하는 방안을 심각하게 고려해봐야함**

### 스레드 풀
- Thread pool 은 이름 그대로 동일한 형태의 스레드를 풀의 형태로 관리한다.
- 일반적으로 스레드 풀은 풀 내부의 스레드로 처리할 작업을 쌓아둬야 되기 때문에 작업 큐와 굉장히 밀접한 관련이 있다.
- 작업스레드는 간단한 주기로 동작하는데 먼저 작업 큐에서 실행할 다음 다음작업을 가져오고 작업을 실행하고, 가져와 실행할 다음작업이 나타날때 까지 대기하는 일을 반복한다.
  
- 작업별로 스레드를 생성하는 대신에 이전 사용했던 스레드를 재사용하기 때문에 스레드를 계속해서 생성할 필요가 없고, 따라서 여러개의 요청을 처리하는데 필요한 시스템 자원이 줄어드는 효과가 있다.
- 클라이언트가 요청을 보냈을때 해당 요청을 처리할 스레드가 이미 만들어진 상태로 대기하고 있기 떄문에 작업을 실행하는데 딜레이가 발생하지 않아 전체적인 반응속도가 향상된다.
- 스레드 풀의 크기를 적절히 조절해두면 하드웨어 프로세서가 쉬지 않고 동작하도록 할 수 있으며, 하드웨어 프로세서가 바쁘게 동작하는 와중에도 메모리를 전부 소모하거나 여러 스레드가 한정된 자원을 두고 서로 경쟁하느라 성능을 까먹는 현상도 없앨 수 있다.

자바 클래스 라이브러리 스레드풀 제공
Executors 클래스에 만들어져있는 다음과 같은 메소드 호출

newFixedThreadPool 
- 처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성한다
- 생성할 수 있는 스레드의 최대 개수는 제한되어있으며 제한된 개수까지 스레드를 생성하고 나면 더이상 생성하지 않고 스레드 수를 유지한다.
  - (만약 스레드가 작업하는 도중에 예외가 발생해서 스레드가 종료되거나 하면 하나씩 더생상하기도 한다)

newCachedThreadPool
- 캐시 스레드 풀은 현재 풀에 갖고 있는 스레드의 수가 처리 할 작업의 수보다 많아서 쉬는 스레드가 많이 발생할때 쉬는 스레드를 종료시켜 훨씬 유연하게 대응 할 수 있으며, 처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성한다.
- 반면에 스레드의 수에는 제한을 하지 안흔다

newSingleThreadExecutor 
- 단일 스레드로 동작하는 Executor 로서 작업을 처리하는 스레드가 단 하나뿐이다.
- 만약 스레드가 작업하는 도중에 예외가 발생해서 비정상적으로 종료되면 새로운 스레드를 하나 생성해 나머지 작업을 실행한다.
- 등록된 작업은 설정된 큐에 지정하는 순서에 따라 반드시 순차적으로 처리된다.
- 단일 스레드로 실행되는 executor 역시 동기화 기법 적용하고 있으며 특정작업이 진행되는 동안 메모리에 남겨진 기록을 다음에 실행되는 작업에서 가져다가 사용 할 수 있다.
- 여러 작업이 모두 하나의 스레드에서 제한된 상태로 실행되기 때문에 가능하며,작업 실행 스레드가 종료되어 새로운 스레드를 만들어 실행하는 경우에도 똑같이 적용된다.

newScheduledThreadPool 
- 일정시간 이후에 실행하거나 주기적으로 작업을 실행 할 수 있으며, 스레드의 수가 고정되어 있는 형태의 Executor.Timer 클래스의 기능과 유사하다.

- newFixedThreadPool, newCachedThreadPool 팩토리 메소드는 일반화된 형태로 구현되어 있는 ThreadPoolExecutor 클래스의 인스턴스를 생성한다.
- 생성된 ThreadPoolExecutor 인스턴스에 대한 설정 값을 조절해 필요한 형태를 갖추고 사용 할 수도 있다(자세한건 8장에서 다룸)
- TaskExecutionWebServer 예제에서 구현 했던 웹서버는 제한된 개수의 스래드로 동작하는 Executor를 사용했었다.
- 처리할 작업을 execute 메소드로 등록해두면 Executor 내부의 큐에 샇이고 내부의 풀에 있는 스레드가 큐에 쌓여있는 작업을 하나씩 뽑아서 처리하게 되어있음
- 작업별로 스레드를 생성하는 전략 Thread-per-task 에서 풀을 기반으로하는 pool-based 전략으로 변경하면 안전성측면에서 장점을 얻을수있음
    - 웹서버에 부하가 걸리더라도 메모리가 부족해 죽는일이 발생하지 않는다는점
    - 부하에 따라 수천개의 스레드를 생성해 제한된양의 CPU와 메모리 자원을 서로 사용하려고 경쟁시키는 상황에 이르지 않기 때문에 성능이 덜어질떄도 점진적으로 서서히 덜어지는 특징
    - Executor을 사용하면 사용하지 않을때보다 성능을 튜닝하거나, 실행과정을 관리하거나 실행상태의 모니터링하거나 실행기록 로그를 남기거나 오류가 발생했을때 처리하고자 할떄 여러가지 방법을 동원해 쉽고 효과적으로 처리하기 쉽다.

### Executor 동작주기
Executor 종료
- Executor를 구현하는 클래스는 대부분 작업을 처리하기 위한 스레드를 생성하도록 되어있다.
- 하지만 Jvm은 모든 스레드가 종료되기전에 종료하지 않고 대기하기 때문에 Executor를 종료하지 않으면 
Jvm 자체가 종료하지 않고 대기하기도한다.
- Executor는 작업을 비동기적으로 실행하기 때문에 앞서 실행시켰던 작업의 상태를 특정시점에 정확하게 파악하기 어렵다 

Executor 종료절차를 밟아야됨
- 안전한 방법이던, 강제적인 방법이건 종료절차을 밟아야된다.
- 종료절차를 밟는 동안 실행중이거나 대깆중이던 작업을 어떻게 처리 했는지 작업을 맡겼던 어플리케이션에게 알려줄 의무가 있다.
- 서비스를 실행하는 동작 주기와 관련해 Executor 를 상속받은 ExecutorService 인터페이스에는 동작 주기를 관리 할 수 있는 여러가지 메소드가 추가되어있다.

~~~java
public interface ExecutorService extends Executor {
    /**
     * Initiates an orderly shutdown in which previously submitted
     * tasks are executed, but no new tasks will be accepted.
     * Invocation has no additional effect if already shut down.
     *
     * <p>This method does not wait for previously submitted tasks to
     * complete execution.  Use {@link #awaitTermination awaitTermination}
     * to do that.
     *
     * @throws SecurityException if a security manager exists and
     *         shutting down this ExecutorService may manipulate
     *         threads that the caller is not permitted to modify
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code ("modifyThread")},
     *         or the security manager's {@code checkAccess} method
     *         denies access.
     */
    void shutdown();

     /**
     * Attempts to stop all actively executing tasks, halts the
     * processing of waiting tasks, and returns a list of the tasks
     * that were awaiting execution.
     *
     * <p>This method does not wait for actively executing tasks to
     * terminate.  Use {@link #awaitTermination awaitTermination} to
     * do that.
     *
     * <p>There are no guarantees beyond best-effort attempts to stop
     * processing actively executing tasks.  For example, typical
     * implementations will cancel via {@link Thread#interrupt}, so any
     * task that fails to respond to interrupts may never terminate.
     *
     * @return list of tasks that never commenced execution
     * @throws SecurityException if a security manager exists and
     *         shutting down this ExecutorService may manipulate
     *         threads that the caller is not permitted to modify
     *         because it does not hold {@link
     *         java.lang.RuntimePermission}{@code ("modifyThread")},
     *         or the security manager's {@code checkAccess} method
     *         denies access.
     */
    List<Runnable> shutdownNow();


    /**
     * Returns {@code true} if this executor has been shut down.
     *
     * @return {@code true} if this executor has been shut down
     */
    boolean isShutdown();

    /**
     * Returns {@code true} if all tasks have completed following shut down.
     * Note that {@code isTerminated} is never {@code true} unless
     * either {@code shutdown} or {@code shutdownNow} was called first.
     *
     * @return {@code true} if all tasks have completed following shut down
     */
    boolean isTerminated();

        /**
     * Blocks until all tasks have completed execution after a shutdown
     * request, or the timeout occurs, or the current thread is
     * interrupted, whichever happens first.
     *
     * @param timeout the maximum time to wait
     * @param unit the time unit of the timeout argument
     * @return {@code true} if this executor terminated and
     *         {@code false} if the timeout elapsed before termination
     * @throws InterruptedException if interrupted while waiting
     */
    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

     //... 작업을 등록할 수 있는 몇가지 추가 메소드   

}
~~~
- ExecutorService 인터페이스의 동작주기 관리
- ExecutorService 동작주기에는 실행중 running, 종료중 shutting down , 종료 terminated 의 세가지 상태가 있다.
- ExecutorService 처음 생성했을때는 실행중 상태로 동작
- shutdown 메소드를 실행하면 안전한 종료 절차를 진행하며 종료중 상태로 들어감
    - 이 상태에서는 새로운 작업을 등록 X, 이전에 등록되어있던 작업까지는 모두 끝마칠수 있음
- ExecutorService 의 하위클래스인 ThreadPoolExecutor 는 이미 종료 절차가 시작되거나 종료이후에 새로운 작업을 등록하려 하면 실행 거절핸들러를 통해 오류로 처리한다(8.3.3참고)
- 실행 거절 핸들러에 따라 다르지만 등록했던 작업을 무시할수도 잇고 RejectedExecutionException을 발생시켜 오류로 처리하도록 할 수 있다.
- 종료절차가 시작된 이후 실행중이거나 대기중이던 작업을 모두 끝내고 나면 ExecutorService 는 종료상태로 들어간다.
- ExecutorService가 종료상태로 들어갈때까지 기다리고자 한다면 awaitTermination 메소드로 대기 할수도 있고 isTerminated 메소드를 주기적으로 호출해 종료상태로 들어갔는지 확인 할 수 있다.
- 일반적으로 shutdown 메소드를 실행한 이후 awaitTermination 을 실행하면 ExecutorService 를 직접 종료시키는것과 비슷한 효과를 얻을수있다(자세한건 7장)

~~~java
class LifecycleWebServer {
    private final ExecutorService exec = ...;
    
    public void start() throws IOException{
        ServerSocket socket = new ServerSocket(80);
        while (!exec.isShutdown()){
            try{
                final Socket conn = socket.accept();
                exec.execute(new Runnable() {
                    @Override
                    public void run() {
                        handleRequest(conn);
                    }
                });
            }catch (RejectedExecutionException e){
                if(!exec.isShutdown()){
                    log("task submmision rejected",e)
                }
            }
        }
    }

    // stop 메소드를 호출하여 종료
    public void stop(){
        exec.shutdown();
    }

    void handleRequest(Socket connection) {
        Request req = readRequest(connection);
        if(isShutdownRequest(req))
            stop(); // 클라이언트에서 특정한 형태의 HTTP 요청을 전송하여 종료
        else
            dispatchRequest(req);
    }
}
~~~
- 종료 기능을 추가한 웹서버
- LifecycleWebServer 앞서 작업했던 웹서버에 동작주기에 대한 지원 부분을 추가

### 지연작업, 주기적작업
- 자바 라이브러리에 포함된 Timer 클래스를 사용하면 특정 시간 이후 원하는 작업을 실행하는 지연작업이나 주기적인 작업을 실행 할 수 있다.
- Timer 단점이 있기 때문에 ScheduledThreadPoolExecutor 를 사용하는 방법이 좋음
    - **Timer 클래스는 시스템 하드웨어 시각을 변경시키면 Timer 스케쥴된 작업도 함께 변경된다**
- ScheduledThreadPoolExecutor 을 생성하려면 ScheduledThreadPoolExecutor 클래스의 생성 메소드를 호출해 생성하는 방법이있고, newScheduledThreadPool 팩토리 메소드를 사용해 생성하는 방법이 있다.
- Timer 클래스는 등록된 작업을 실행시키는 스레드를 하나만 생성해 사용한다
- Timer에 등록된 특정 작업이 너무 오래실행되면 등록된 다른 TimeTask 작업이 예정된 시각에 실행되지 못할 가능성이 높다.
- ScheduledThreadPoolExecutor 를 사용하면 지연작업과 주기적 작업마다 여러개의 스래드를 할당해 작업을 실행하느라 각자의 실행 예정 시각을 벗어나는 일이 없도록 조절해준다.
- Timer 클래스의 또다른 단점 TimerTask 가 동작하는 도중 Execption 을 던져버리는 경우에 예측하지 못하는 상태로 넘어 갈 수 있음
    - Timer 스레드는 예외 상황을 전혀 처리하지 않기 떄문에 TimerTask가 Execption을 던지면 Timer 스레드가 멈춰버릴 가능성도 있다
    - Timer 클래스는 오류가 발생해 스레드가 종료된 상황에서 새로운 스레드를 생성해주지 않는다.
    - 등록되어 있던 모든 작업이 취소된 상황, 등록됐던 TimerTask가 실행 X, 새로운 작업 등록 X
  
~~~java
class OutOfTime {
    public static void main(String[] args) throws Exception {
        Timer timer = new Timer();
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(1);
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(5);
    }

    static class ThrowTask extends TimerTask {

        @Override
        public void run() {
            throw new RuntimeException();
        }
    }
}
~~~
- Timer 를 사용할때 발생할 수 있는 오류 상황

- 1초만 실행되다가 Timer already cancelled. IllegalStateException 을 띄우면서 종료
~~~
Exception in thread "main" java.lang.IllegalStateException: Timer already cancelled.
	at java.base/java.util.Timer.sched(Timer.java:398)
	at java.base/java.util.Timer.schedule(Timer.java:194)
	at com.concurrency.OutOfTime.main(OutOfTime.java:13)
~~~
- ScheduledThreadPoolExecutor는 이와같이 오류가 발생하는 경우를 훨씬 안정적으로 처리해 주기 때문에 자바 5.0 이후버전을 사용하는 경우에는 Timer 사용 X
- 특별한 스케줄 방법을 지원하는 스케줄링 서비스를 구현해야 할 필요가 있다면 DelayQueue 클래스를 사용하는것이 좋음
- DelayQueue는 큐 내부에 여러개의 Delayed 객체로 작업을 관리하며 각각의 Delayed 객체는 저 마다의 시간을 갖고있다. Delayed 내부의 시각이 만료된 객체만 take 메소드로 가져갈 수 있다.
- DelayQueue에서 뽑아내는 객체는 객체마다 지정되어 있던 시각 순서로 정렬되어 뽑아진다.


## 6.3 병렬로 처리할 만한 작업
- Executor 프레임웍을 보면 실행 정책은 쉽게 지정할수록 되어있지만 Executor을 사용하려면 실행하려는 작업을 항상 Runnable 인터페이스에 맞춰 구현해야만 한다.
- 대부분 서버 어플리케이션에서는 일반적으로 작업의 범위를 일정하게 나눌수있음
    - ex) 클라이언트 요청 한건을 처리하는 작업
- 하지만 이런 내용이 모든 어플리케이션에 적절 할 수 없으며 그런예도 쉽게 찾을 수 있다.
- 서버 어플리케이션에서 클라이언트의 요청 한건을 처리하는 과정에서도 병렬화 처리하는 모습을 볼수있음
    - ex) 데이터베이스 서버같은 경우 이런 기법 많이 사용
- 병렬로 동작하는 버전의 컴포넌트 만들어볼예정

### 순차적 페이지 렌더링
- HTML 문서의 내용을 순차적으로 그려가는 방법 
- 사용자 입장에서는 HTML 페이지 내용이 전부 표시 될 댸까지 상대적으로 많은시간이 걸리기 떄문에 짜증남

~~~java
public class SingleThreadRenderer {
    void rednerPage(CharSequence source){
        renderText(source);
        List<ImageData> imageData = new ArrayList<ImageData>();
        for (ImageInfo imageInfo : scanForImageInfo(source) ) 
            imageData.add(imageInfo.downloadImage());
        for(ImageData data : imageData)
            renderImage(data);
    }
}
~~~
- 페이지 내용을 순차적으로 렌더링
- 똑같이 순차적으로 처리하지만 덜짜증나는 방법
    - 예를 들어 텍스트 부분 전부처리
    - 텍스트 사이에 들어있는 이미지 해당하는 부분 이미지 없이 네모난 박스로 표현
    - 텍스트를 먼저 그려내고 다음순서로 이미지를 차례로 다운받아 비워뒀던 공간에 그려 넣는다

- 이미지를 다운받는 작업은  I/O 작업이며, 요청한 데이터를 전송받을때까지 대기하는 시간이 걸리지만 실제로 CPU 가 하는 일은 별로없음
- 따라서 순차적인 방법은 CPU 능력을 제대로 활용하지 못하는 경우가 많으며, 사용자는 똑같은 내용을 보기위해 불필요하게 많은 시간을 기다려야함
- 처리해야할 큰작업을(HTML 페이지 렌더링)을 작은단위의 작업으로 쪼개서 동시에 실행할수 있도록 한다면 CPU도 훨씬 잘 활용하고 처리속도와 응답속도 역시 많이 개선할 수 있음

### 결과가 나올때까지 대기 Callable 과 Future
- Executor 프레임워크에서는 작업을 표현하는 방법으로 Runnable 인터페이스를 사용한다.
- Runnable 충분한 기능 제공하지 못함
    - run 메소드 실행이 끝난다음 결과값 리턴 X
        - 만약 결과값을 만들어 냈다면 어딘가 공유된 저장소에 저장해야됨
    - 예외가 발생했다고 throws 구문 표현 X
        - 오류가 발생했으면 로그파일에 오류내용을 기록하는 정도가 일반적임
- 결과를 받아올때까지 시간이 걸리는 작업이 꽤나 많음 시간이 걸리는 기능은 Runnable 대신 Callable 을 사용하는게 좋음
  
Callable
- Callable 인터페이스에서 핵심 메소드인 call 을 실행하고나면 결과값을 돌려 받을 수 있고 Exception도 발생시킬수 있도록 되어있다.
- Executor 에는 Callable 뿐만아니라 Runnable 이나 java.security.PrivilegedAction 등 여러가지 유형의 작업을 실행 할 수 있는 기능이 들어있다.
- Runnable, Callable 둘 다 작업을 추상화하기 위한 도구
- 작업은 지점이 명확하고 언젠가는 작업이 끝나게 되어있음
- Executor 에서 실행한 작업은 생성 created, 등록 submitted, 실행 started, 종료 completed 와 같은 네가지 상태를 통과한다.
- 작업은 상당한 시간동안 실행 되기 마련이므로 중간에 취소 할 수 있는 기능이 있어야 함
- Executor 프레임워크에서는 먼저 등록됬지만 시작되지 않은 작업은 언제든지 실행하지 않도록 취소 할 수 있다
- 이미 시작한 작업은 내부구조가 인터럽트를 처리하도록 잘 만들어진 경우에 한해 취소 시킬 수 있다 작업취소는 7장에서 잘다룸

Future
- 특정작업이 정상적으로 완료됐는지 취소됐는지 등에 대한 정보를 확인 할수 있도록 만들어진 클래스
- Future가 동작하는 사이클에서 염두할 점은 한번 지나간 상태를 되돌리수 없다는 점이다.
    - 사이클을 되돌릴 수 없다는점은 ExecutorService 와 동일
    - 완료된 작업은 완료 상태에 영원히 머무른다
- get 메소드는 작업이 진행되는상태에 따라 다른 유형으로 동작한다.
    - 작업이 완료된 상태에 들어가있다면 get 메소드를 호출했을때 즉시 결과값을 리턴하거나 Exception을 발생시킨다.
    - 작업을 시작하지 않았거나 작업이 실행되고 있는 상태라면 작업이 완료될 때 까지 대기한다
    - 작업실행이 끝난 상태에서 Exception 이 발생했었다면 get 메소드는 원래 발생했던 Exception 을 ExecutionException 이라는 예외클래스에 담아 던진다
    - 작업이 중간에 취소 됬다면 get 메소드에서 CancellationException 이 발생한다.
    - get 메소드에서 ExecutionException 발생한 경우 원래 발생한 오류는 ExecutionException 의 getCause 메소드로 확인 할 수 있다.

~~~java
public interface Callable<V>{
    V call() throws Exception;
}

public interface Future<V>{
   boolean cancel (boolean mayInterruptIfRunning);
   boolean isCancelled();
   boolean isDone();
   V get() throws InterruptedException, ExecutionException, CancellationException;
   V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, CancellationException, TimeoutException;
}
~~~
- Callable과 Future 인터페이스

- 실행하고자 하는 작업을 나타내는 Future 클래스는 여러가지 방법으로 만들어 낼 수 있다
- ExecutorService 클래스의 submit 메소드는 Future 인스턴스를 리턴한다.
따라서 Executor 에 Runnable 이나 Callable 을 등록하면 Future 인스턴스를 받을 수 있고 받은 Future 인스턴스를 사용해 작업의 결과를 확인하거나 실행 도중의 작업을 취소 할 수 있다
- Runnable 이나 Callable 을 사용해 직접 FutureTask 인스턴스를 생성하는 방법이 있다
- 자바 6부터는 ExecutorService 를 구현하는 클래스에서 AbstractExecutorService 에 정의된 
newTaskFor 이라는 메소드를 오버라이드 할 수 있도록 되어있으며, newTaskFor 를 오버라이드해 등록된 Runnable 이나 Callable 에 따라 Future 를 생성하는 기능에 직접 관여 할 수 있다
~~~java
protected <T> RunnableFuture<T> newTaskFor(Callable<T> task) {
    return new FutureTask<T>(task);
}
~~~
- ThreadPoolExecutor.newTaskFor 메소드의 기본 구현 내용

- Executor 에 Runnable 이나 Callable 넘겨 등록하는것은 Runnable 이나 Callable을 처음에 생성 했던 스레드에서 실제 작업을 실행 할 스레드로 안전하게 공개하는 과정을 거치도록 되어 있다.
- 이와 유사하게 Future 에 결과 값을 설정하는 부분 역시 작업스레드에서 get 메소드로 결과값을 가져가려는 스레드로 결과 객체를 안전하게 공개하도록 되어 있다.

## Future 를 사용해 페이지 렌더링 
작업을 둘로 나누자
1. 텍스트를 이미지로 그려내는 작업(cpu 를 많이사용)
2. HTML 페이지에서 사용한 이미지 파일을 다운로드 받는 작업(I/O 부분 많이 사용)
- 둘로 나누면 단일 CPU 를 사용하는 시스템에서도 성능을 향상 시킬 수 있다.

- Callable 과 Future 인터페이스를 사용하면 HTML 페이지를 렌더링하는 프로그램과 같이 여러스레드가 서로 상대방을 살펴가며 동작하는 논리 구조를 쉽게 설계 할 수 있다.
   
~~~java
public class FutureRenderer {
    private final ExecutorService executor = ...;

    void renderPage(CharSequence source){
        final List<IamgeInfo> imageInfos = scanForImageInfo(source);
        Callable<List<ImageData>> task = new Callable<List<ImageData>>() {
            @Override
            public List<ImageData> call() throws Exception {
                List<ImageData> result = new ArrayList<ImageData>();
                for (ImageInfo imageInfo : scanForImageInfo(source) )
                    imageData.add(imageInfo.downloadImage());
                return result;
            }
        };

        /*
        ExecutorService 에 Callable 등록시킴
        Callable 등록되는 즉시 해당 작업에 대한 Future 인스턴스를 받을 수 있다.
        */
        Future<List<ImageData>> future = executor.submit(task);
        renderText(source);
        
        try{
            /*이미지 파일을 확보한다. 
            낙관적으로보면 get 하는 순간 이미지를 모두 다운로드 메인스레드는 필요한 이미지를 즉시 사용할 수 있다.
            이상적이지 못해도 이미지를 다운로드 받는 기능이 이미 모두 시작된 상태이기 떄문에 순차적인 실행보다 효율적임
            */
            List<ImageData> imageData = future.get();
            for(ImageData data : imageData)
                renderImage(data);
            
        }catch (InterruptedException e){
            // 스레드의 인터럽트 상태를 재설정
            Thread.currentThread().interrupt();
            // 결과는 더이상 필요 없으니 해당 작업도 취소한다.
            future.cancel(true);
        }catch (ExecutionException e){
            throw launderThrowable(e.getCause());
        }
    }
}
~~~
- Future 를 사용해 이미지 파일 다운로드 작업을 기다림
- 작업결과를 기다리는 코드가 작업 진행 상태를 반드시 알아야 할 필요는 없다
- 작업을 등록할때 안전한 공개방법을 사용하고 결과를 받아 올 때 역시 안전한 공개 방법을 사용하기 때문에 Future 을 활요하는 작업이 스레드 안전성을 확보했다고 할 수 있다
- get 메소드를 감싸고 있는 오류 처리 구문은 2가지에 대응해야함
    - 첫번째는 Exception 이 발생한 경우
    - 두번째는 결과값을 얻기전에 get 메소드를 호출해 대기하던 메인 스레드가 인터럽트 되는 경우
- FutureRenderer 에서는 이미지 파일을 다운로드 하면서 그와 동시에 텍스트 본문을 이미지로 그려진다.
- 사용자 입장에서는 페이지 훨씬 빠르게 그려진다고 느낄수 있으며 병렬처리의 장점도 느낄수 있음
- 개선해야 될 부분 많음 

### 다양한 형태의 작업을 병렬로 처리하는 경우의 단점
- 순차적으로 동작하던 다양한 형태의 작업을 병렬로 처리해 성능상의 큰 이점을 얻고자한다면 편법을 써야함
- ex) 주방에서 접시 닦는 일 두명이서 처리 만약 주방에 일할사람이 여럿이 추가로 투입되는경우 작업방법을 재구성하지 않는 이상 모든 사람이 최대한 바쁘게 효과적으로 일하기 어려움
- 특정 스레드에 일정한 유형의 작업을 모두 맡겨버리는 정책은 확장성에 좋지 않음
- 유사한 작업 가운데 가운데 훨씬 세부적인 작업으로 병렬성을 높이지 못할 바에는 이런 방법은 전체적인 성능을 떨어뜨리는 결과를 가져 올 수 있음
- 다양한 종류의 작업을 여러 작업 스레드에서 나눠 처리하도록 할 떄는 나눠진 작업이 일정한 크기를 유지하지 못 할수 있다는 단점도 있다.
- 결과적으로 여러개의 작업 스레드가 하나의 작업을 나눠 실행 시킬 때는 항상 작업 스레드간에 필요한 내용을 조율하는데 일부 자원을 소모하게 된다.
- 따라서 작업을 잘게 쪼개는 의미를 찾으려면 병렬로 처리해서 얻을 수 있는 성능상의 이득이 이와 같은 부하를 훨씬 넘어서야 한다.

FutureRenderer 는 두 종류의 작업
- 텍스트를 그려넣는 작업 (훨씬 빨리처리)
- 이미지 파일을 다운로드 받는 작업(텍스트보다 상대적으로 느림)

 - 결과적으로 보면 전체적인 실행시간은 순차적으로 실행되는 버젼보다 그다지 빠르지 않고, 프로그램 구조만 복잡 해질 수 있다.
 - 스레드 두개를 갖고 본다해도 성능이 높아질수 있는 수준은 2배에 불과 
    - 노력에 비해 결과는 한계가 있음
 - **프로그램이 해야할 일은 작은 작업을 쪼개 실행 할 떄 실제적인 성능상의 이점을 얻으려면, 프로그램이 하는 일을 대량의 동일한 작업으로 재정의해 병렬로 처리할 수 있어야 한다.**

### CompletionService : Executor 와 BlockingQueue의 연합
- CompletionService는 Executor 의 기능과 BlockingQueue 의 기능을 하나로 모은 인터페이스
- 필요한 Callable 작업을 등록해 실행시킬 수 있고, take 나 poll 과 같은 큐 메소드를 사용해 작업이 완료되는 순간 완료된 작업의 Future 인스턴스를 받아 올 수 있다.
- CompletionService 구현한 클래스로는 ExecutorCompletationService 가 있는데 등록된 작업은 Executor 를 통해 실행한다.
- ExecutorCompletationService 구현내용 직관적
- 생성자에서 완료된 결과 값을 쌓아 둘 BlockingQueue 를 생성한다.
- FutureTask 에는 done 메소드가 있는데 FutureTask 의 작업이 완료되면 done 메소드가 한번씩 호출된다.
  
~~~java
private class QueueingFuture<V> extends FutureTask<V>{
    QueueingFuture(Callable<V> c){ super(c); }
    QueueingFuture(Runnable t , V r){ super(t,r); }

    protected void done(){
        completionQueue.add(this);
    }
}
~~~
- ExecutorCompletationService 에서 사용하는 QueueingFuture 클래스
  
- FutureTask를 상속받은 QueueingFuture 클래스로 변환하는데 QueueingFuture 의 done 메소드에서 결과를 BlockingQueue 에 추가하도록 되어있다.
- take, poll 메소드를 호출하면 그대로 BlockingQueue의 해당 메소드로 넘겨 처리한다.

### CompletionServcie 를 활용한 페이지 렌더링 
- CompletionServcie 활용하면 위에 나왔던 코드 성능을 두가지 측면에서 개선 할 수 있다
- 전체 실행되는 시간 줄이고 응답속도도 높일 수 있다.
- 각각의 이미지 파일을 다운로드 받는 작업을 생성하고 ,executor를 활용해 다운로드 작업을 실행한다.
    - 이전에 순서대로 다운로드 하던 부분 병렬화
    - 이미지 전체 다운로드 걸리는 시간을 줄일 수 있다.
- 다운 받은 이미지는 CompletionServcie 를 통해 찾아가도록 하면, 이미지 파일을 다운로드 받는 순간 해당 하는 위치에 그림을 그려넣을 수 있다.
- 사용자 입장에서는 페이지가 동적으로 최대한 빠르게 업데이트됨
~~~java
public class Renderer {
    private final ExecutorService executor;

    public Renderer(ExecutorService executor) {
        this.executor = executor;
    }

    void renderPage(CharSequence source) {
        final List<IamgeInfo> info = scanForImageInfo(source);
        CompletionService<ImageData> completionService = new ExecutorCompletionService<ImageData>(executor);
        for (ImageInfo imageInfo : info) {
            completionService.submit(new Callable<ImageData>() {
                @Override
                public ImageData call() throws Exception {
                    return imageInfo.downloadImage();
                }
            });
        }
        renderText(source);

        try {
            for (int t = 0; n = info.size(); t < n ;
            t++){
                Future<ImageData> f = completionService.take();
                ImageData imageData = f.get();
                renderImage(data);
            }

        } catch (InterruptedException e) {
            // 스레드의 인터럽트 상태를 재설정
            Thread.currentThread().interrupt();
        } catch (ExecutionException e) {
            throw launderThrowable(e.getCause());
        }
    }
}
~~~
- CompletionServcie를 사용해 페이지 구성요소를 받아오는 즉시 렌더링
  
- 여러개의 ExecutorCompletionService 에서 동일한 Executor 를 공유해 사용 할 수도 있다.
- 따라서 실행을 맡은 Executor는 하나만 두고 동일한 작업을 처리하는 여러가지 ExecutorCompletionService 를 생성해 사용하는 일도 충분히 가능하다
- Future 가 단일 작업 하나에 대한 진행과정을 관리한다고 할때 CompletionService 는 특정한 배치 작업을 관리하는 모습을 띤다고 볼 수 있다
- CompletionService 에 전체 몇개의 작업을 등록했는지와 그 가운데 몇개의 결과를 받아 왔는지를 관리한다면 해당 배치 작업이 모두 끝난지도 쉽게 확인할수 있다.

### 작업 실행 시간 제한
- 일정 한 시간 이내에만 작업을 처리하도록 만들고자 할 때 가장 중요한 부분은 지정된 시간이 지나면 더이상 기다려 줄 수 없다는 점이다.
    - 타임아웃을 지정할수 있는 Future.get 메소드를 사용하면 이와 같은 시간 제한 요구사항을 만족 할 수 있다.
    - 즉 결과가 나오는 즉시 리턴되는 것은 타임아웃을 지정하지 않은 경우와 같지만 지정한 시간이 지나도 결과를 만들어 내지 못하면 TimeoutException 을 던지면서 실행이 멈추게 되어 있다.
  
- 시간이 제한된 상태에서 작업을 실행할 때 발생하는 두번째 문제는 제한된 시간을 넘었을때 해당 작업을 실제로 멈추도록 해서 더이상 시스템의 자원을 소모하지 않도록 해야되는 점이다.
    - 해당 작업 내부에서 스스로 얼마의 시간안에 결과를 만들어 내야하는지 관리하고 제한된 시간이 되면 스스로 작동을 멈추도록 해야한다. 아니면 제한된 시간이 넘었을때 강제로 취소시키는 방법도 있다.
    - Future를 사용하면 된다. 시간 제한을 걸어둔 get 메소드에 TimeoutException 이 발생하면 해당 Future 작업을 직접 취소 시킬 수 잇다.
    - 애초에 작업을 구현할때 취소 할 수 있도록 만들엇다면 취소하는 즉시 더이상 시스템 자원을 잡아 먹지 않고 깔끔하게 멈춘다.

- 실행 시간이 제한된 Future.get 메소드를 사용하는 일반적인 예
- 제한된 시간안에 광고 가져오기
~~~java
      Page renderPageWithAd() throws InterruptedException {
        long endNonos = System.nanoTime() + TIME_BUDGET;
        Future<Ad> f = executor.submit(new FetchAdTesk());
        // 광고를 가져오는 작업을 등록했으니, 원래 페이지를 작업한다
        Page page = renderPageBody();
        Ad ad;
        try {
            // 남은 시간만큼 대기한다
            /* 받아와야 할 시간 - 현재시간 뺀 값
            음수로 나올 수 있지만 java.util.concurrent 패키지에 들어있는 모든 타임아웃 관련 메소드는 음수인 제한 시간을 0으로 간주하고 처리
            따로 해야될 일 없음
            */
            long timeLeft = endNonos - System.nanoTime();
            ad = f.get(timeLeft, NONOSECONDS);
        } catch (ExecutionException e) {
            ad = DEFAULT_AD;
        } catch (TimeoutException e) {
            ad = DEFAULT_AD;
            /* Future.cancel 메소드에 true 인자를 넘겨주면 해당작업이 현재 실행중일때 작업에 인터럽트를 걸어도 좋다는 의미 자세한건 7장*/
            f.cancel(true);
        }
        page.setAd(ad);
        return page;
    }
~~~
- 광고 내용을 가져오는 Executor 를 등록해두고 원래 페이지 내용을 처리한다.
- 원래 페이지를 가져오는 작업을 모두 끝나면 광고를 받아왔는지 확인하고 만약 광고를 가져오지 못하면 남은 시간만큼 대기한다
- 만약 제한 시간이 지나버리면 광고를 가져오는 작업을 취소 시키고 기본광고를 사용한다.

### 여행 예약 포털
- 여행 예약 포털 사이트 예
- 항공사 , 호텔, 렌트카등의 업체가 입력한 입찰 정보를 한군데 모아 보여준다.
- 이런 상황에서 입찰 정보 표시하는 페이지가 여러 업체 가운데 응답을 가장 늦게 보여주는 속도에 맞춰 뜨기보다는 일정 시간안에 입찰 정보를 넘겨주는 업체에 한해서 목록을 보여주는 방법이 효과적이다.
- 입찰 정보를 넘겨야 할 응답 시간을 맞추지 못한 업체는 해당내용을 아예 페이지에서 빼버리거나 아니면 응답을 받지 못했습니다. 라는 상태메세지를 보여주는것도 좋다.

- 업체별로 입찰 정보를 가져오는 작업은 업체를 단위로 완전히 독립적인 작업
- 입찰정보를 가져오는 작업 n개를 생성해 스레드 풀에 등록하고, 등록한 작업마다 Future 객체를 확보하고 타임아웃 지정한 get 메소드로 각각의 입찰정보를 가져오도록 할 수 있다.
- 게다가 이런작업을 쉽게 만들어 주는 기능이 있는데 invokeAll 메소드이다.
~~~java
private class QuoteTask implements Callable<TravelQuote> {
    private final TravelCompany company;
    private final TravelInfo travelInfo;

    @Override
    public TravelQuote call() throws Exception {
        return company.solicitQuote(travelInfo);
    }
}

public List<TravelQuote> getRankedTravelQuotes(TravelInfo travelInfo, Set<TravelCompany> compaines,
                                               Comparator<TravelQuote> ranking, long time, TimeUnit unit)
        throws InterruptedException {
    List<QuoteTask> tasks = new ArrayList<>();
    for (TravelCompany company : compaines) {
        tasks.add(new QuoteTask(company, travelInfo));
    }

    List<Future<TravelQuote>> futures = exec.invokeAll(tasks, time, unit);

    List<TravelQuote> quotes = new ArrayList<TravelQuote>(tasks.size());

    Iterator<QuoteTask> taskIter = tasks.iterator();
    for (Future<TravelQuote> f : futures) {
        QuoteTask task = taskIter.next();
        try {
            quotes.add(f.get());
        } catch (ExecutionException e) {
            quotes.add(task.getFailureQuote(e.getCause()));
        } catch (CancellationException e) {
            quotes.add(task.getTimeoutQuote(e));
        }
    }
    Collections.sort(quotes, ranking);
    return quotes;
}
~~~
- 제한된 시간안에 여행 관련 입찰 정보를 가져오도록 요청하는 코드
- ExecutorService 에 등록해 실행시키고 결과를 받아오는 부분에 타임아웃을 지정한 invokeAll 메소드를 활용하고 있다.
- invokeAll 메소드는 작업 객체가 담긴 컬렉션 객체를 넘겨받으며 그에 해당하는 Future 객체가 담긴 컬렉션 객체를 리턴한다. 인자로 넘긴 작업 컬렉션과 결과로 받은 Future 컬렉션은 그 구조가 같ㅇ다
- invokeAll 메소드는 넘겨주는 컬렉션의 iterator 뽑아주는 순서에 따라 결과 컬렉션 Future 에 결과를 쌓는다.
- 넘겨준 컬렉션과 받은 컬렉션의 구조가 동일하기 떄문에 작업을 등록한 모듈은 어떤 작업에서 어떤결과가 나오는지 알 수 있다.
- 시간 제한이 있는 invokeAll 메소드는 모든 작업이 완료됬거나 작업을 등록한 스레드에 인터럽트가 걸리거나 지정된 제한시간이 지날떄까지 대기하다가 리턴된다. 
- 제한시간이 지날떄 까지 실행중이던 작업은 모두 실행이 취소된다.
- invokeAll 메소드가 리턴되면 등록된 모든 작업은 완료되어 결과값을 가지고 있거나 취소되거나 두가지 상태 가운데 하나이다.
- 작업을 등록했던 스레드는 모든 작업을 대상으로 get 메소드를 호출하거나 isCacnelled 메소드를 사용해 작업이 완료되거나 취소된 상태를 확인 할 수 있다.

### 요약
- 어플리케이션을 작업이라는 단위로 구분해 실행 할 수 있도로고 구조를 잡으면 개발과정을 간소화하고 병렬성을 확보해 병렬성을 높일 수 있다.
- Executor 프레임웍을 사용하면 작업을 생성하는 부분과 작업을 실행하는 부분을 분리해 실행정책을 수립 할 수 있으며, 원하는 형태의 실행 정책을 쉽게 만들어 사용 할 수 있다.
- 작업을 처리하는 부분에서 스레드를 생성하도록 되어있다면 스레드 말고 Executor 을 사용해보자
- 어플리케이션이 하는일을 개별작업으로 구분해 처리할 떄는 작업의 범위를 적절하게 잡아야 한다.
    - 어플리케이션에서는 일반적인 작업범위가 잘 적용 되지만 일부 어플리케이션에서는 스레드를 사용해 병렬로 처리시킨 이득을 보려면 약간의 분석을 통해 병렬로 처리할 작업을 찾아 낼 필요가 있다.

## 참고
책 자바 병렬 프로그래밍 6장