## 8장 내용
8.1 작업과 실행 정책 간의 보이지 않은 연결 관계
8.2 스레드 풀 크기 조정
8.3 ThreadPoolExecutor 설정
8.4 ThreadPoolExecutor 상속
8.5 재귀 함수 병렬화

## 작업과 실행 정책 간의 보이지 않은 연결 관계
- 의존성이 있는 작업 
    - 다른 작업에 의존성을 갖는 작업을 스레드 풀에 올려 실행하려는 경우에는 실행정책에 보이지 않는 조거는 거는셈
    - 스레드 풀이 동작하는 동안 활동성문제 liveness problem 가 발생하지 않도록 하려면 실행정책에 대한 이와 같은 보이지 않는 조건을 면밀하게 조사하고 관리해야한다.

- 스레드 한정 기법을 사용하는 작업
    - 해당 작업을 실행하려면 Executor 프레임웍이 단일 스레드로 동작해아하는 조건이 생기기 때문에 작업과 실행정책간에 보이지 않는 연결고리가 걸려 있는상황
    - 이런 경우 단일 스레드를 사용하는 풀대신 여러개의 스레드를 사용하는 풀로 변경하면 스레드 안전성을 쉽게 잃을 수 있다.

- 응답시간이 민감한 작업
    - 단일 스레드로 동작하는 Executor에 오랫동안 실행될 작업을 등록하거나, 서너개의 스래드로 동작하는 풀에 실행시간이 긴작업을 몇개만 등록하더라도 해당 Executor를 중심으로 움직이는 화면 관련 부분은 응답 성능이 크게 떨어질수 밖에없다.
  
- ThreadLocal 을 사용한 작업
    - 스레드풀에 속한 스레드에서 ThreadLocal 을 사용할때에는 현재 실행중인 작업이 끝나면 더이상 사용하지 않을 값만 보관해야한다
    - ThreadLocal 을 편법으로 활용해 작업 간에 값을 전달하는 용도로 사용해서는 안된다.

- 스레드 풀은 동일하고 서로 독립적인 다수의 작업을 실행할때 가장 효과적이다.
- 실행 시간이 오래 걸리는 작업과 금방 끝나는 작업을 섞어서 실행하도록 하면 풀의 크기가 굉장히 크지 않는한 작업 실행을 방해하는것과 비슷한 상황이 발생한다.
- 또한 크게가 제한되어 있는 스레드 풀에 다른 작업의 내용에 의존성을 갖고 있는 작업 등록하면 데드락이 발생할 가능성이 높다. 
- 일반적인 네트웍 기반의 서비스어플리케이션은 작업이 서로 동일하면서 독립적이어야 한다는 조건을 대부분 만족한다.
- 다른 작업에 의존성이 있는 작업을 실행해야 할 떄는 스레드 풀의 크기를 충분히 크게 잡아서 작업이 큐에서 대기하거나 등록되지 못하는 상황이 없도록 해야한다. 스레드 한정기법을 사용하는 작업은 반드시 순차적으로 실행돼야한다.
- 작업을 구현 할 때는 나주엥 유지보수를 진행할대 해당 작업과 호환되지 않는 실행정책 아래에서 실행하도록 변경해 어플리케이션의 안전성을 해치거나 실행되지 않는 경우를 막을 수 있도록 실행정책과 관련된 내용을 문서로 남겨야된다.

### 스레드 부족 데드락
- 스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높다.
- 단일 스레드로 동작하는 Executor 에서 다른 작업을 큐에 등록하고 해당작업이 실행된 결과를 가져다 사용하는 작업을 실행하면, 데드락이 제대로 걸린다.
- 스레드 풀의 크기가 크더라도 실행되는 모든 스레드가 큐에 쌓여 아직 실행되지 않은 작업의 결과를 받으려고 대기중리라면 동일한 상황이 발생할 수 있다.
- 이런 현상을 스레드 부족 데드락 thread starvation deadlock 이라고 하며 특정 자원을 확보하고자 계속해서 대기하거나 풀 내부의 다른 작업이 실행돼야 알 수 있는 조건이 만족하기를 기다리는것처럼 끝없이 계속 대기할 가능성이 있는 가ㅣ능을 사용하는 작업이 풀에 등록 된 경우에는 언제든지 발생 할 수 있다.
- 필요한 작업을 데드락 없이 실행 시킬수 잇을만큼 풀의 크기가 충분히 크다면 물론 문제가 없을 수도 있다.

~~~java
public class ThreadDeadLock {
    ExecutorService exec = Executors.newSingleThreadExecutor();
    
    public class RenderPageTask implements Callable<String>{

        @Override
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            return header.get() + page + footer.get();
        }
    }
}
~~~
- 단일 스레드 Executor 에서 데드락이 발생하는 작업구조 이런 코드는 금물!
- Executor 에서 스레드를 하나만 쓰도록 구현한다면 ThreadDeadLock 클래스는 항상 데드락에 걸린다.
- 이것처럼 배리어 barrier 를 사용해 서로 동작을 조율하는 작업 역시 풀의 크기가 충분히 크지 않다면 스레드 부족 데드락이 발생 할 수 있다.
- **완전히 독립적이지 않은 작업을 Executor에 등록할때 항상 스레드 부족 데드락이 발생할 수 있다는 사실을 염두에 둬야하며, 작업을 구현한 코드나 Executor를 설정하는 설정파일등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야 한다.**
- 스레드 풀의 크기를 직접적으로 지정하는것 이외에도 스레드 풀에서 필요하는 자원이 제한되어 원하는 크기보다 작은 수준에서 동작하는 경우도 있다.
    - ex) JDBC 풀

### 오래 실행 되는 작업
- 특정 작업이 예상보다 긴 시간동안 종료되지 않고 실행된다면 스레드 풀의 응답속도에 문제점이 생긴다.
- 오래 실행될 것이라고 예상되는 작업이 대략 몇개인지를 알고 있을때 그 개수에 비해 스레드 풀의 크기가 상당히 작은 수준이라면 시간이 지나면서 스레드풀에 속한 스레드 가운데 상당수가 오래 실행되는 작업에 잡혀있을 가능성이 크다. 이러한 상황에 다다르면 스레드풀의 응답 속도가 크게 느려진다.
- 제한이 없이 계속해서 대기하는 기능 대신 일정시간동안만 대기하는 메소드를 사용 할 수 있다면 오래 실행되는 작업이 주는 악영향을 줄일 수 있는 하나의 방법으로 볼 수 있다.
- 자바 플랫폼 라이브러리에서 제공하는 대부분의 블로킹 메소드는 시간이 제한되지 않은것과 시간이 제한된것이 함께 만들어져있다.   
    - ex) Thread.join 메소드, BlockingQueue.put 메소드, CountDownLatch.awit, Select.select 메소드등
- 대기하는 도중에 지정한 시간이 지나면 해당 작업이 제대로 실행되지 못했다고 기록해두고 일단 종료시킨 다음 큐의 맨 뒤에 다시 추가하는등의 대책을 세울수 있다.
    - 큐에 쌓여있던 금방 끝내는 작업을 실행 할 수 있도록 스레드를 비워주는 효과가 있다
- 스레드 풀을 사용하는 도중에 모든 스레드에서 실행중인 작업이 대기상태에 빠지는 경우가 자주 발생한다면, 스레드풀의 크기가 작다는것으로 이해 할 수 도 있겠다.

## 스레드 풀 크기 조정
- 스레드풀의 가장 이상적인 크기는 스레드풀에서 실행할 작업의 종류와 스레드 풀을 활용할 애플리케이션의 특성에 따라 결정된다.
- 하드코딩하는 방법 좋지않음, 동적으로 지정되는 방법이 좋다
- 스레드풀의 크기는 설정 파일이나 Runtime.availableProcessors 등의 메소드 결과값에 따라 동적으로 지정되도록 해야한다.
- 스레드풀의 크기를 결정하는데 특별한 공식 X , 다만 너무크다, 너무작다 극단적인 크기만 아니면됨
- 스레드 풀이 너무크게 설정되어있으면 스레드는 CPU 나 메모리등의 자원을 조금이라도 더 확보하기 위해 경쟁하게되고 그러다보면 CPU에는 부하가 걸리고 메모리는 모자라 금방 자원부족에 시달릴 것이다.
- 반대로 스레드 풀의 크기가 너무 작다면 작업량은 계속해서 쌇이는데 CPU나 메모리는 남아돌면서 작업 철이 속도가 떨어질 수 있다.
- 스레드 풀의 크기를 적절하게 산정하려면 현재 컴퓨터환경이 어느정도인지 확인해야하고, 확보하고 있는 자원의양도 알아야하며 할작업이 어떻게 동작해야하는지도 정확하게 알아야한다.
- CPU 을 많이 사용하는 작업의 경우 N개의 CPU 을 탑재하고 있는 하드웨어에서 스레드풀을 사용할때는 스레드의 개수를 N+1로 맞추면 최적의 성능을 발휘한다고 알려져있다.
- I/O 작업이 많거나 기타 다른 블로킹 작업을 해야하는 경우라면 어느 순간에 모든 스레드가 대기 상태에 들어가 전체적인 진행이 멈출 수 있기 때문에 스레드풀의 크기를 훨씬 크게 작아야할 필요가 있다.

CPU 가 원하는 활용도를 유지할수 있는 스레드풀의 크기는 다음 수식으로 구할수 잇음
~~~
Nthread = Ncpu * Ucpu * (1+W/C)
~~~
- cpu 의 개수는 Runtime availableProcessors 메소드로 다음과 같이 알아 낼 수 있다.
~~~java
int N_CPUS = Runtime.getRuntime().availableProcessors();
~~~

- CPU가 아닌 자원을 대상으로 하는 스레드풀의 크기를 정하는것은 CPU때보다 훨씬 시움
- 각작업에서 실제로 필요한 자원의 양을 모두 더한 값을 자원의 전체개수로 나눠주면된다 
    - 이값이 스레드풀의 최대 크기에 해당
- 스레드 풀에 동작하는 작업 내부에서 데이터베이스 연결과 같은 자원을 사용해야한다면 스레드풀의 크기와 자원풀의 크기가 서로에게 영향을 미친다
    - 각 작업하나가 데이터베이스 연결 하나를 사용한다고 가정하면 스레드 풀의 실제 크기는 데이터 베이스연결 풀의 크기로 제한되는 셈이다.
- 이와 반대로 데이터 베이스 연결 풀을 특정 스레드 풀에서만 사용한다고 하면 데이터베이스 연결풀에 확보된 여러 가운데 실제로 스레드 풀의 크기에 해당하는 연결만 사용될 것이다.

## ThreadPoolExecutor 설정
~~~java
~~~
### 스레드 생성과 제거

### 큐에 쌓인 작업 관리

### 집중 대응 정책

### 스레드 팩토리

### ThreadPoolExecutor 생성 이후 설정 변경

## ThreadPoolExecutor 상속
### 스레드 풀에 통계 확인 기능 추가 

## 재귀 함수 병렬화
### 예제 퍼즐 프레임워크

## 요약
- Executor 프레임웍은 작업을 병렬로 동작시킬 수 있는 강력함과 유연성으 고루 갖추고 있다.
- 스레드를 생성하거나 제거하는 정책이나 큐에 쌓인 작업을 처리하는 방법, 작업이 밀려 잇을때 밀린작업을 처리하는 방법등의 조건을 설정해 입맛에 맞게 튜닝 할 수 있는 옵션도 제공하고 있으며 어러가지의 훅 메소드를 사용해 필요한 기능을 확장해 사용 할 수 있다.
- 여러가지 설정 가운데 서로 잘 맞지 않는 설정이 있을 수 도 있다.
    - ex) 특정 종류의 작업은 일정한 실행정책 아래에서만 제대로 동작하기도 하고, 특이한 조합을 사용하면 예측 할 수 없는 이상한 형태로 작업이 실행되기도 한다는점을 주의 하자.

## 참고
책 자바 병렬 프로그래밍 8장