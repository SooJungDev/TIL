## 인프런 대세는 쿠버네티스 강의 듣고 정리
- 인프런 대세는 쿠버네티스 강의 듣고 정리함
- [대세는 쿠버네티스 ^o^](https://www.inflearn.com/course/%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EA%B8%B0%EC%B4%88/dashboard)

## why kubernetes
- 접속량이 다를 경우 , 아침,점심,저녁 다다름 
 - 이 상황에서 쿠버네티스를 사용할 경우 오토스케일링이 되기때문에 더 적은 서버로 가능됨
- 오토 힐링, 디플로이먼트 제공 
- 서비스 효율이 증가하게 됨

## VM vs Container
- VM : 하이퍼바이저 위에 Gest OS 올린다음에 서비스 구성
- Container: 컨네이너에서 개발한다음에 버전차이 문제가 생길수있음 도커를 설치하고 컨테이너 이미지를 만들수있음
 - 이미지 안에는 라이브러리가 들어있음
 - 도커 여러컨테이너 분리해주도록 해준다. 컨테이너 가상화가 깔려있는 OS 에서는 개발환경에대한 걱정없이 배포가능하게됨
 - 마이크로 서비스 모듈별로 쪼개서 만든다. 큰 효과를 얻을수 있
 
- 쿠버네티스 pod 로 묶을 수 있음 pod 는 하나의 배포단위 쿠버네티스가 쉽게해줌

 
## Getting started
- node.js 로 된 간단한 어플리케이션이 있다고 가정
Docker

- Dockerfile
~~~
FROM node:slim
EXPOSE 8000
COPY hello.js .
CMD node hello.js
~~~

- [Docker Hub Site](https://hub.docker.com/)

- Docker Container Run
~~~
docker build -t kubetm/hello .
-t : 레파지토리/이미지명: 버전

docker images
docker run -d -p 8100:8000 kubetm/hello
-d : 백그라운드 모드
-p : 포트변경

docker ps
docker exec it id값 /bin/bash
~~~

- Docker Image Push
~~~
docker login
docker push kubetm/hello
~~~

Kubernetes
- pod
~~~
apiVersion: v1
kind: Pod
metadata:
  name: hello-pod
  labels:
    app: hello
spec
  containers:
  - name: hello-container
    images: kubetm/hello
    ports:
    - containerPort: 8000
~~~
- Service
~~~
apiVersion: v1
kind: Service
metadata:
  name: hello-svc
spec:
  selector:
    app: hello
  ports:
    - port: 8200
      targetPort: 8000
  externalIps:
  - 192.168.0.30
~~~

## Kubernetes Overview
- 한 마스터에 여러 노드가 연결이됨 이것이 하나의 쿠버네티스 클러스터
- 마스터는 전반적인것을 컨트롤 노드는 자원, 자원을 늘리고싶다면 노드를 추가해주면됨
- 클러스터 안에 네임스페이스가 독립된 공간으로 해줌 
- 네임스페이스에는 pod 
    - 제한시킬수있음 limitRange
    - ConfigMap/Secret
- pod 안에는 여러 컨테이너
- pod 에 문제가 생겨서 재생성이되면 데이터가 날라감 
- 데이터가 유실되는 문제 해결하려면 volume 을 만들어줘야함
- 컨트롤러가 파드를 관리함

컨트롤러
- Replication Controller, ReplicaSet
- Deployment
- DaemonSet
- CronJob
- Job

#### 쿠버네티스 설치개요
구글 클라우드 플랫폼
- 구글클라우드 가입
- 클라우드 Jdk 설정
- Dashboard 설치

## Object- Pod
- pod 안에는 하나의 독립적인 서비스를 할수있는 컨테이너
- 컨테이너 안에는 하나이상 포트를 가질수있지만 한 pod 안에서는 중복되는 포트를 가질수없다

Label
- 키와 벨류가 한쌍
- 사용목적에 따라 label 을 등록하면 원하는 pod를 선택해서 사용할수 있음

Node Schedule
- node 마다 점수를 매겨서 높은 점수에 할당을해줌
- 자원량으로 판단함 적게 쓰는 곳에 자동으로 노드를 생성해줌

## Object - Service
- Pod 는 언제든지 죽을 수있고 죽으면 재생성 재생성이 되면 ip 가 변경됨
- 서비스는 사용자가 지우지 않는한 재생성되거나 삭제되지 않음 ip 고정

ClusterIp
- 기본적인 방식인 ClusterIp **쿠버네티스 클러스터 내에서만 접근이 가능함** 외부에서는 접근 불가능
- pod는 여러개 연결가능
- 안써주면 기본적으로 선택하는 타입
사용 용도
- 인가된 사용자(운영자)
- 내부 대쉬보드
- Pod의 서비스 상태 디버깅

NodePort
- 모든 Node 에 Port 할당 외부로 부터 어느 노드인간에 그포트로 연결되면 서비스로 연결이됨
- **모든노드에 할당이됨**
- 각 노드에 파드가 하나씩 할당되어있음 어떤노드에게 온 pod 인거와 상관없이 트래픽을 줌 , 분산이됨
- externalTrafficPolicy 옵션값을 주면 해당 노드에 트래픽을 주도록함 , 주의해서 사용해야됨 해당옵션 노드에 pod 가없는 경우 
사용 용도
- 내부망 연결
- 데모나 임시연결

LoadBalancer
- 노드포트의 성격을 그대로 가지고있음
- 각각의 노드에 트래픽을 분산해줌 
- 외부 접속 아이피주소를 할당해주는 플러그인을 설치를 해줘야지 됨
- 만약에 LoadBalancer External Ip 지원 Plugin (GCP,AWS,Azure, OpenStack)
사용 용도
- 외부시스템 노출용

## Object - Volume
emptyDir
- Pod 생성시 만들어지고 삭제시 없어짐

HostPath
- 각 Node의 path 사용
HostPath Type
- DirectoryOrCreate : 실제 경로가 없다면 생성
- Directory: 실제 경로가 있어야 됨
- FileOrCreate: 실제 경로에 파일에 없다면 생성
- File : 실제 파일이 있어야함 

PVC / PV
- PV 정의생성
- PVC 생성
- PV 연결
- Pod 생성시 PVC 마운팅






## 참고
- [강의자료](https://kubetm.github.io/practice/beginner/gettingstarted-kubernetes/)
