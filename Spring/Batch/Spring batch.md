## 배치 어플리케이션이란?
- 배치는 일괄처리란 뜻을 가지고 있음   
배치 어플리케이션은 다음 조건을 만족
- 대용량 데이터 : 배치 어플리케이션은 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리
- 자동화 : 배치 어플리케이션은 심각한 문제 해결을 제외하고는 사용자 개입없이 실행되어야 함
- 견고성 : 배치 어플리케이션은 잘못된 데이터를 충돌/중단 없이 처리 할 수 있음
- 신뢰성 : 배치 어플리케이션은 무엇이 잘못되었는지 추적 할 수 있어야함 (로깅,알림) 
- 신뢰성 : 배치 어플리케이션은 지정한 시간 안에 처리를 완료, 동시에 실행되는 다른 어플리케이션을 방해 하지 않도록 수행

## Batch VS Quartz
- 둘은 역할이 완전히 다름 
- Quartz 는 스케쥴러 역할 , Batch와 같이 대용량 데이터 배치 처리에 대한 기능을 지원하지 않음
- Batch 역시 스케줄 기능 지원하지 않음
- Quartz + Batch 를 조합해서 사용

## 스케쥴링이란??
 - 어떤 프로젝트에서, 특정 시간이나 일정시간 간격으로 job이 실행되어야 하는 경우 
 - 매일 혹은 매월 통계 데이터를 만들어야 되는 배치성 업무나일정 주기별로 서비스의 상태나 변경 사항을 관리자에게 알려줘야 되는경우
 = 일반적으로 Java Timer API, Crontab, Quartz로 구현(그외에도 job scheduler lib 많음)

## Batch 사례
- 일매출 집계 : 실시간 집계 쿼리로 해결하기에는 조회 시간이나 서버 부하가 심함   
  그래서 매일 새벽 전날 매출 집계 데이터를 만들어 외부요청이 올경우 미리 만들어준 집계 데이터를 바로전달
- 정해진 시간마다 데이터 가공이 필요한 경우 batch 사용 될 수 있음 

## Spring Batch 주요 개념
- Job : 하나의 배치 작업을 정의   
  ex) API 서버의 사용로그 테이블의 데이터를 로그 분석 시스템으로 옮기는 배치
- Job Instance : 배치가 실제 실행되면 각각의 실행을 instance 라고 함.  
  ex) Batch Job이 매주 한번씩 수행된다고 할때 각 수행되는 batch job을 batch instance라고 함  
- Job Execution : 배치가 실행될때, 각 배치의 실행시, 실제 수행된 Execution 을 정의
  ex) Batch Job이 월요일 오전에 수행 되었을때 첫번째 실패, 두번째 Retry에 의해 성공되었다면 
  각각은 다른 job execution이 되고 같은 작업을 시도하였기 때문에 같은 Job instance가 됨
- Job parameter: 매번 배치 작업이 수행될때마다 전달되는 parameter  
  ex) 매주 수행되는 배치가 있을때, 시작 시간, 데이터를 읽을 범위 등을 지정하여 batch job instance를 생성한다면 
    이렇게 넘어가는 인자가 Job Parameter임

## Spring에서 Batch job의 구성 
- Step: Spring에서 배치 잡은 step의 모음으로 구성됨 job은 Step이 순차적으로 수행하게됨
- Tasklet : Tasklet은 각 Step에서 수행되는 로직, 개발자가 Custom Logic을 만들 수 있고 또는 보통 batch의 경우 데이터를 
  ETL(Extract, Transform, Loading)하는 형태이기 때문에 Spring Batch 에서 미리 정의해 놓음
    1. itemReader : 데이터를 읽는 컴포넌트
    2. itemProcessor : 읽은 데이터를 처리 
    3. itemWriter : 처리한 데이터를 저장
    
## Simple Job 생성하기 
~~~java
@Slf4j
@RequiredArgsConstructor
@Configuration
public class SimpleJobConfiguration {
    private final JobBuilderFactory jobBuilderFactory;
    private final StepBuilderFactory stepBuilderFactory;

    @Bean
    public Job simpleJob() {
        return jobBuilderFactory.get("simpleJob").start(simpleStep1()).build();
    }

    @Bean
    public Step simpleStep1() {
        return stepBuilderFactory.get("simpleStep1").tasklet((contribution, chunkContext) -> {
            log.info(">>>>>>>>>>> this is step1");
            return RepeatStatus.FINISHED;
        }).build();

    }
}
~~~
- @Configuration 
   - Spring Batch의 모든 Job은 @Configuration 으로 등록해서 사용
- jobBuilderFactory.get("simpleJob")
  - simpleJob 이란 Batch Job을 생성함
  - job의 이름은 별도로 지정하지 않고, 이렇게 Builder을 통해 지정함
- stepBuilderFactory.get("simpleStep1")
   - Step 안에서 수행 될 기능들을 명시 
   - jobBuilderFactory.get("simpleJob")와 마찬가지로 Builder 를 통해 이름을 지정
- .taklet((contribution, chunckContext))
  - Step 안에서 수행 될 기능을 명시 
  - Tasklet은 **Step안에 단일로 수행될 커스텀한 기능** 들을 선언할때 사용
  - 여기서 Batch가 수행되면 log.info("">>>>>>>>>>> this is step1") 가 출력 
  
 - Job 은 하나의 배치 작업 단위
 - Job 안에는 아래처럼 여러 Step 이존재 
 - Step 안에는 Reader & Processor & Writer 묶음이 존재
 - Tasklet 하나와 Reader & Processor & Writer 한 묶음이 같은 레벨
 - Reader & Processor 가 끝나고 Tasklet으로 마무리 짓는 등으로 만들 수 없음 
 
 ## Mysql 환경에서 Spring batch 실행 
 Sprinb Batch 메타 데이터 테이블들이 필요   
 메타 데이터란 데이터를 설명하는 데이터
 Spring Batch의 메타 데이터는 다음과 같은 내용을 가지고 있음 
 - 이전에 실행한 Job이 어떤 것들이 있는지
 - 최근 실패한 Batch Parameter 가 어떤 것들 이 있고 성공한 Job은 어떤것들인지
 - 다시 실행한다면 어디서부터 시작할건지
 - 어떤 Job에서 어떤 Step 들이 있었고 , Step들 중 성공한 Step과 실패한 Step 들은 어떤것들이 있는지 
 
 schema-mysql.sql를 검색한뒤 local mysql에서 실행함
 ~~~
 -- Autogenerated: do not edit this file
 
 CREATE TABLE BATCH_JOB_INSTANCE  (
 	JOB_INSTANCE_ID BIGINT  NOT NULL PRIMARY KEY ,
 	VERSION BIGINT ,
 	JOB_NAME VARCHAR(100) NOT NULL,
 	JOB_KEY VARCHAR(32) NOT NULL,
 	constraint JOB_INST_UN unique (JOB_NAME, JOB_KEY)
 ) ENGINE=InnoDB;
 
 CREATE TABLE BATCH_JOB_EXECUTION  (
 	JOB_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
 	VERSION BIGINT  ,
 	JOB_INSTANCE_ID BIGINT NOT NULL,
 	CREATE_TIME DATETIME NOT NULL,
 	START_TIME DATETIME DEFAULT NULL ,
 	END_TIME DATETIME DEFAULT NULL ,
 	STATUS VARCHAR(10) ,
 	EXIT_CODE VARCHAR(2500) ,
 	EXIT_MESSAGE VARCHAR(2500) ,
 	LAST_UPDATED DATETIME,
 	JOB_CONFIGURATION_LOCATION VARCHAR(2500) NULL,
 	constraint JOB_INST_EXEC_FK foreign key (JOB_INSTANCE_ID)
 	references BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)
 ) ENGINE=InnoDB;
 
 CREATE TABLE BATCH_JOB_EXECUTION_PARAMS  (
 	JOB_EXECUTION_ID BIGINT NOT NULL ,
 	TYPE_CD VARCHAR(6) NOT NULL ,
 	KEY_NAME VARCHAR(100) NOT NULL ,
 	STRING_VAL VARCHAR(250) ,
 	DATE_VAL DATETIME DEFAULT NULL ,
 	LONG_VAL BIGINT ,
 	DOUBLE_VAL DOUBLE PRECISION ,
 	IDENTIFYING CHAR(1) NOT NULL ,
 	constraint JOB_EXEC_PARAMS_FK foreign key (JOB_EXECUTION_ID)
 	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
 ) ENGINE=InnoDB;
 
 CREATE TABLE BATCH_STEP_EXECUTION  (
 	STEP_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
 	VERSION BIGINT NOT NULL,
 	STEP_NAME VARCHAR(100) NOT NULL,
 	JOB_EXECUTION_ID BIGINT NOT NULL,
 	START_TIME DATETIME NOT NULL ,
 	END_TIME DATETIME DEFAULT NULL ,
 	STATUS VARCHAR(10) ,
 	COMMIT_COUNT BIGINT ,
 	READ_COUNT BIGINT ,
 	FILTER_COUNT BIGINT ,
 	WRITE_COUNT BIGINT ,
 	READ_SKIP_COUNT BIGINT ,
 	WRITE_SKIP_COUNT BIGINT ,
 	PROCESS_SKIP_COUNT BIGINT ,
 	ROLLBACK_COUNT BIGINT ,
 	EXIT_CODE VARCHAR(2500) ,
 	EXIT_MESSAGE VARCHAR(2500) ,
 	LAST_UPDATED DATETIME,
 	constraint JOB_EXEC_STEP_FK foreign key (JOB_EXECUTION_ID)
 	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
 ) ENGINE=InnoDB;
 
 CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT  (
 	STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
 	SHORT_CONTEXT VARCHAR(2500) NOT NULL,
 	SERIALIZED_CONTEXT TEXT ,
 	constraint STEP_EXEC_CTX_FK foreign key (STEP_EXECUTION_ID)
 	references BATCH_STEP_EXECUTION(STEP_EXECUTION_ID)
 ) ENGINE=InnoDB;
 
 CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT  (
 	JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
 	SHORT_CONTEXT VARCHAR(2500) NOT NULL,
 	SERIALIZED_CONTEXT TEXT ,
 	constraint JOB_EXEC_CTX_FK foreign key (JOB_EXECUTION_ID)
 	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
 ) ENGINE=InnoDB;
 
 CREATE TABLE BATCH_STEP_EXECUTION_SEQ (
 	ID BIGINT NOT NULL,
 	UNIQUE_KEY CHAR(1) NOT NULL,
 	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
 ) ENGINE=InnoDB;
 
 INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_STEP_EXECUTION_SEQ);
 
 CREATE TABLE BATCH_JOB_EXECUTION_SEQ (
 	ID BIGINT NOT NULL,
 	UNIQUE_KEY CHAR(1) NOT NULL,
 	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
 ) ENGINE=InnoDB;
 
 INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_EXECUTION_SEQ);
 
 CREATE TABLE BATCH_JOB_SEQ (
 	ID BIGINT NOT NULL,
 	UNIQUE_KEY CHAR(1) NOT NULL,
 	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
 ) ENGINE=InnoDB;
 
 INSERT INTO BATCH_JOB_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_SEQ);
 ~~~
 
## 스프링 부트 배치 이해하기
1. 읽기(read): 데이터 저장소(일반적으로 데이터베이스)에서 특정 데이터 레코드를 읽습니다.
2. 처리(processing): 원하는 방식으로 데이터 가공/처리 합니다.
3. 쓰기(write): 수정된 데이터를 다시 저장소(데이터베이스)에 저장합니다.

- Job과 Step은 1:M
- Step 과 ItemReader, ItemProcessor, ItemWriter 1:1
- Job 이라는 하나의 큰 일감(Job)에 여러단계(Step)을 두고 각 단계를 배치의 기본 흐름대로 구성함

## Job
- Job은 배치 처리 과정의 하나의 단위로 만들어 표현한 객체, 또한 전체 배치 처리에 있어 항상 최상단 계층에 있음
- 위에서 하나의 Job안에는 여러 Step(단계)가 있다고 설명 했떤 바와 같이 스프링 배치에서 Job 객체는 여러 Step 의 인스턴스를 포함하는 컨테이너 
- Job 객체를 만드는 빌더는 여러개 있습니다. 여러 빌더를 통합한 처리하는 공장인 JobBuilderFactory 로 원하는 Job을 쉽게 만들수 있음

~~~java
public class JobBuilderFactory{
   private JobRepository jobRepository;
   
   public JobBuilderFactory(JobRepository jobRepository){
        this.jobRepository=jobRepository;
   }
   
   public JobBuilder get(String name){
      JobBuilder builder = new JobBuilder(name).repository(jobRepository);
      return builder;
   }
~~~
- JobBuilderFactory는 JobBuilder를 생성 할 수 있는 get() 메서드를 포함하고 있음. get() 메서드는 새로운 JobBuilder 를 생성해서 반환하는 것을 확인
- JobBuilderFactory에서 생성되는 모든 JobBuilder 가 레포지토리를 사용합니다.
- JobBuilderFactory 는 JobBuilder 를 생성하는 역할만 수행. 이렇게 생성된 JobBuilder 를 이용해서 Job을 생성해야함
- JobBuilder는 직접적으로 Job을 생성하는 것이 아니라 별도의 구체적 빌더를 생성하여 변환하여 경우에 따라 job 생성 방법이 모두 다를 수 있는 점을 유연하게 처리할 수있음



## ItemReader
- ItemReader 는 Step 의 대상이 되는 배치 데이터를 읽어오는 인터페이스
- File, Xml, DB 등 여러 타입의 데이터를 읽어 올수 있음

## ItemProcessor
- ItemProcessor 는 ItemReader로 읽어온 배치 데이터를 변환하는 역할을 수행합니다. 이것을 분리하는 이유는 다음과 같음
- 비지니스 로직 분리: ItemWriter는 저장만 수행, ItemProcessor 는 로직 처리만 수행해 역할을 명확하게 분리
- 읽어온 배치 데이터와 씌여질 데이터의 타입이 다를 경우에 대응 할 수 있기 때문이다.

## ItemWriter
- ItemWriter는 배치 데이터를 저장합니다. 일반적으로 DB나 파일에 저장합니다.
- ItemWriter도 ItemReader와 비슷한 방식을 구현합니다. 제너릭으로 원하는 타입을 받고 write() 메서드는 List를 사용해서 저장한 타입의 리스트를 매개변수로 받음

    
## 참고사이트
  - [Spring Batch 가이드](https://jojoldu.tistory.com/324?category=635883)
  - [Spring Batch 가이드- Bath Job 실행해보기](https://jojoldu.tistory.com/325?category=635883)
  - [Spring Batch 개념정리](http://bcho.tistory.com/763)
  - [자바기반 스케줄링 프로그래밍](https://www.slideshare.net/redrebel/ss-42209509)
  - [Spring Batch 간단 정리](https://cheese10yun.github.io/spring-batch-basic/)
