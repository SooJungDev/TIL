## Netflix OSS, Spring Cloud 를 활용한 MSA 기초 강의 듣고 정리
## 모놀리틱 아키텍처 이해
- HA(High Avaliability)구성: 지속적으로 구동되는 시스템
- 로드 밸런서를 두고 톰캣을 여러대 두는 형태
- Load Balancer L4 switch(hardware), L7(Nginx, HAProxy)
- LB Out -> tomcat stop -> delivery -> tomcat start -> LB In

서비스가 흥해서!!!
서버 3대 추가구입
- LB설정 변경, 배포방식 변경(Jenkins, Ansible, Chef, etc..)

조직개편 상품팀, 주문팀으로 분리
- 단일 Repository 일 경우에 많은 문제가 생김
- 레파지토리를 나눠도 Share.jar 생김 공통으로 접근해야됨

- 팀별 Repository 분리, 각 코드 commit 시 팀별 배포가능
- 공통적인 부분들을 Share Repository 에 넣음
- 각 프로젝트에서 compile 'kr.co.12st:share:1.0.0-SNAPSHOT'
- **여전히 정기배포 필요**

콘웨이의 법칙
- 광범위하게 정의하면 모든 조직은 조직의 의사소통구조와 똑같은 구조를 갖는 시스템을 설계한다
- 콘웨이 법칙은 조직도에 초점을 두지 않고 실질적인 소통관계에 관심을 둔다. 너무 많은 통신관계를 갖는것은 프로젝트에 대한 진정한 위험이 된다.

모놀리틱 아키텍처 정리
- 대부분 IT회사의 시작은 모놀리틱
장점
 - 개발이 단순하다 repository 하나 체크아웃 받아서 띄우면 됨
 - 배포가 단순하다 (war 하나만 배포하면 되니까)
 - Scale-out 이 단순하다(서버 하나 복사하면 되니까)
  - 하지만 DB 성능으로 인한 한계가 있다
단점
 - 무겁다 IDE 가 못받쳐줌
 - 어플리케이션 시작이 오래걸린다
 - 기술 스택 바꾸기가 어렵다
 - 높은 결합도
 - 코드베이스의 작업한계와 소유권이 불투명
 
 ## 마이크로서비스 아키텍처 이해
 - MSA 란 시스템을 여러개의 **독립된 서비스**로 나눠서 이 **서비스를 조합**함으로서 **기능을 제공**하는 아키텍처 디자인 패턴
 
아마존의 선택
- 인터페이스로 연결시켜라 모든 커뮤니케이션은 네트워크를 통한 서비스 인터페이스로 이루어져야 한다
- 어떤 기술을 쓰든 상관없음
- 모든 서비스 인터페이스는 예외없이 외부에서 이용가능하게 되어야한다 -> aws 탄생

넷플릭스 선택
- 데이터베이스에 심각한 문제 발생 고객에게 dvd 보낼 수 업슨ㄴ 사태 
    - Scale - Up 확장만 가능한 인프라 스트럭처와 단일 장애 지점이라는 한꼐에서 벗어나길 선언
    - 그 시작 아파치 카산드라
- 2009년 aws 로 이관
    - 세가지 목표에 집중 확장성, 성능, 가용성
  
MSA 란?
- 공식적인 정의는 없음, 다음 공감대가 있을뿐
- 각 서비스간 네트워크를 통해 , 보통 HTTP 통해
- 독립된 배포단위
- 각 서비스는 쉽게 교체가능
- 각 서비스는 기능 중심으로 구성됨
- 각 서비스에 적합한 프로그래밍언어, 데이터베이스 환경으로 만들어진다
- 서비스는 크기가 작고, 상황에 따라 경계를 정하고, 자율적으로 개발되고, 독립적으로 배포되고, 분산되고 자동화 된
프로세스를 구축되고 배포된다.

## Cloud Native 이해
Cloud Native 란
- 클라우드 네이티브 핵심은 애플리케이션을 어덯게 만들고 배포하는지에 있으며 위치는 중요하지 않다
- 클라우드 서비스를 활용한다는 것은 컨테이너와 같이 **민첩**하고 **확장가능**한 구성요소를 사용해 **재사용가능**한 개발적인 기능을 제공한다는것을 의미한다
이러한 기능은 멀티클라우드와 같은 여러 기술 경계간에 매끄럽게 통합되므로 제공팀이 반복가능한 자동화와 오케스트레이션을 사용하여 빠르게 작업 과정을 반복 할 수 있다
- 신축성(Resiliency)
- 민첩성(Agility)
- 확장가능성(Scalable)
- 자동화(Automation)
- 무상태(State-less)

### Twelve-Factors
- 12 Factors
- Heroku 클라우드 플랫폼 창시자들이 정립한 애플리케이션 개발 원칙 중 유익한것을 모아서 정리한것
- **탄력적**(elastic)하고 **이식성** 이있는(portability)**배포**를 위한 **베스트 프랙티스**(Best Practices)
핵심사상
- **선언적** 형식으로 설정을 자동화해서 프로젝트에 새로 참여하는 동료가 적응하는데 필요한 시간과 비용을 최소화한다.
- 운영체제에 구애받지 않는 투명한 계약을 통해 다양한 실행환경에서 작동 할 수 있도록 **이식성을 극대화**한다
- 현대적인 **클라우드 플랫폼 기반 개발**을 통해 서버와 시스템관리에 대한 부담을 줄인다.
- 개발과 운영의 **간극을 최소화해서 지속적배포**를 가능하게 하고 애자일성을 최대화 한다.
- 도구, 아키텍처, 개발 관행을 크게 바꾸지 않아도 서비스 규모 **수직적 확장**이 가능하다.

### Twelve-Factors - 코드베이스
- 버젼 관리되는 하나의 코드베이스가 여러번 배포된다
- 코드베이스와 앱 사이에는 항상 1대1 관계가 성립된다.

### Twelve-Factors - 의존성
- 어플리케이션의 의존관계(dependencies)는 명시적으로 선언되어야 한다
- 모든 의존 라이브러리는 아파치,메이븐,그레이들 등의 의존관계 관리 도구를 써서 라이브러리 저장소에서 내려받을 수 있어야 한다.

### Twelve-Factors - 설정
- 설정 정보는 실행 환경에 저장한다
- 설정정보(configuration)는 어플리케이션 코드와 엄격하게 분리
- 설정은 배포(스테이징,프로덕션, 개발환경등) 마다 달라질 수 있는 모든것(DB정보, 외부서비스 인증,호스트이름등)
- 설정을 환경변수(env)에 저장한다.

### Twelve-Factors - 백엔드(지원) 서비스
- 지원 서비스(backing service)는 필요에 따라 추가되는 자원으로 취급한다.
- 자원서비스는 데이터베이스 API기반 RESTFul 웹서비스, SMTP 서버, FTP 서버등
- 지원서비스는 애플리케이션의 자원으로 간주한다.
- 테스트 환경에서 사용하던 임베디드 SQL을 스테이징 환경에서 MySQL 로 교체 할 수 있어야 한다.

### Twelve-Factors - 빌드,릴리즈, 실행
- 철저하게 분리된 빌드와 실행단계
- 코드베이스는 3단계를 거쳐(개발용이 아닌) 배포로 변환된다.
 - 빌드 단계 : 소스코드를 가져와 컴파일 후 하나의 퍀키지를 만든다
 - 릴리즈 단계 : 빌드에 환경설정 정보를 조합한다. 릴리스 버젼은 실행 환경에서 운영될 수 있는 준비가 완료되어있다.
  시맨틱 비저닝등 식별자가 부여됨. 이버젼은 롤백하는데 사용
 - 실행단계: 보통 런타임이라 불림, 릴리스 버젼중 하나를 선택해 실행환경 위에 애플리케이션을 실행

### Twelve-Factors - 포트바인딩
- 서비스는 포트에 연결해서 외부에 공개한다
- 실행 환경에 웹서버를 따로 추가해줄 필요 없이 스스로 웹서버를 포함하고 있어서 완전히 자기완비적(self-contained)이다

### Twelve-Factors - 동시성(concurrency)
- 프로세스 모델을 통해 수평적으로 확장한다
- 애플리케이션은 필요 할때마다 프로세스나 스레드를 수평적으로 확장해서 병렬로 실행 할 수 있어야 한다.
- 장시간 소요되는 데이터 프로세싱 작업은 스레드풀에 할당해서 스레드 실행기(executor)를 통해 수행되어야 한다
- 예를 들어 HTTP 요청을 서블릿 스레드가 처리하고, 시간이 오래 걸리는 작업은 워커스레드가 처리해야 한다

### Twelve-Factors - 처분성(Disposability)
- 빠른 시작과 그레이스풀 셧다운(graceful shutdown)을 통한 안정성 극대화
- 애플리케이션은 푸로세스 실행중에 언제든지 중지 될 수 있고, 중지될때 처리되어야 하는 작업을 모두 수행한 다음 깔금하게 종료 될 수 있다
- 가능한 한 짧은 시간내에 시작되어야 한다.

### Twelve-Factors - dev/prod 일치
- development, staging, production 환경을 최대한 비슷하게 유지
- 개발환경과 운영환경을 가능한 동일하게 유지하는 짝맞춤(parity)을 통해 분기(divergence)를 예방 할 수 있어야 한다
- 유념해야 할 세가지 차이
 - 시간 차이: 개발자는 변경 사항을 운영환경에 빨리 배포해야한다
 - 개인 차이: 코드 변경을 맡은 개발자는 운영환경으로 배포 작업까지 할 수 있어야하고, 모니터링도 할 수 있어야 한다
 - 도구 차이: 각 실행 환경에 사용된 기술이나 프레임워크는 동일하게 구성되어야 한다.
 
 ### Twelve-Factors - 로그
- 로그는 이벤트 스트림으로 취급한다
- 로그는 stdout 에 남긴다
- 애플리케이션은 로그 파일 저장에 관여하지 말아야 한다
- 로그집계와 저장은 애플리케이션이 아니라 실행 환경에 의해 처리되어야 한다
 
### Twelve-Factors - Admin 프로세스
- admin/maintenance 작업을 일회성 프로세스로 실행
- 실행되는 프로세스와 동일한 환경에서 실행
- admin 코드는 애플리케이션 코드와 함께 배포되어야 한다.
 
### HTTP, REST API
- 클라이언트의 상태를 갖지 않음(stateless)
- 각 요청은 자기 완비적(self-contained)

- REST vs 그외(EJB, SOAP, etc)

- REST API
- 2000년 로이필딩 박사가 소개(HTTP 명세 writer)
- 원격자원(resource)와 엔티티(Entity)를 다루는데 초점
- 동사대신 명사를 , 행위대신 엔티티에 집중
- REST는 기술 표준이 아닌 아키텍처 제약사항
- 상태가 없고 요청이 자기 완비적이기 때문에 서비스도 수평적으로 쉽게 확장 될 수 있다.

## 강의
- [Netflix OSS, Spring Cloud 를 활용한 MSA 기초](https://www.youtube.com/playlist?list=PL9mhQYIlKEhdtYdxxZ6hZeb0va2Gm17A5)
