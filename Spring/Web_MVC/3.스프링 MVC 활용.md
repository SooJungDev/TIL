## 스프링 MVC 핵심 기술 소개

애노에티션 기반의 스프링 MVC
- 요청 맵핑하기
- 핸들러 메소드
- 모델과 뷰
- 데이터 바인더
- 예외처리
- 글로벌 컨트롤러

사용할 기술
- 스프링부트
- 스프링 프레임워크 웹 MVC
- 타임리프

학습할 애노테이션
- @RequestMapping
    - @GetMapping, @PostMapping, @PutMapping, ...
- @ModelAttribute
- @RequestParam, @RequestHeader
- @PathVariable, @MatrixVariable
- @SessionAttribute , @RequestAttribute, @CookieValue
- @Valid
- @RequestBody, @ResponseBody
- @ExceptionHandler
- @ControllerAdvice

- 참고 
    - [mvc-controller](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-controller)

## HTTP 요청 맵핑하기 1부 : 요청 메소드
HTTP Method
- GET, POST, PUT, PATCH, DELETE, ...

GET 요청
- 클라이언트가 서버의 리소스를 요청할떄 사용한다.
- 캐싱할 수있다.(조건적인 GET으로 바뀔수 있다.)
- 브라우저 기록에 남는다.
- 북마크 할 수 있다.
- 민감한 데이터를 보낼때 사용하지 말것(URL 에 다 보이니까)

POST 요청
- 클라이언트가 서버의 리소스를 수정하거나 새로만들떄 사용한다.
- 서버에 보내는 데이터를 POST 요청 본문에 담는다.
- 캐시 할 수 없다.
- 브라우저 기록에 남지 않는다.
- 북마크 할 수 없다.
- 데이터 길이 제한 없다.

PUT 요청
- URI 에 해당하는 데이터를 새로 만들거나 수정할떄 사용한다.
- POST 와 다른점은 "URI" 에 대한 의미가다르다.
    - POST의 URI 보내는 데이터를 처리할 리소스를 지칭하며
    - PUT 의 URI 보내는 데이터에 해당하는 리소스를 지칭한다.
- Idempotent

PATCH 요청
- PUT 과 비슷하지만, 기존 엔티티와 새데이터의 차이점만 보낸다는 차이가 있다.
- Idempotent

DELETE 요청
- URI 에 해당하는 리소스를 삭제 할떄 사용한다.
- Idempotent

스프링 웹 MVC 에서 HTTP Method 맵핑하기
- @RequestMapping(method = RequestMethod.GET)
- @RequestMapping(method ={RequestMethod.GET, RequestMethod.POST})
- @GetMapping , @PostMapping

참고
- [HTTP Request Methods](https://www.w3schools.com/tags/ref_httpmethods.asp)
- [HTTP GET](https://tools.ietf.org/html/rfc2616#section-9.3)
- [Hypertext Transfer Protocol -- HTTP/1.1](https://tools.ietf.org/html/rfc2068)


## HTTP 요청 맵핑하기 URI 패턴 맵핑
- URI, URL, URN 헷갈린다.
- [What is the difference between a URI, a URL and a URN?](https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn)

요청식별자로 맵핑하기
- @RequestMapping 은 다음의 패턴을 지원합니다.
- ?: 한글자("/author/???" => "/author/123")
- * : 여러글자("/author/*" => "/author/keesun")
- ** : 여러패스("/author/**" => "/author/keesun/book")

클래스에 선언한 @RequestMapping과 조합
- 클래스에 선언한 URI 패턴뒤에서 이어 붙여서 맵핑합니다.

정규표현식으로 맵핑할 수 도있습니다.
- /{name: 정규식}

패턴이 중복되는 경우에는?
- 가장 구체적으로 맵핑되는 핸들러를 선택합니다.

URI 확장자 맵핑 지원
- 이기능을 권장하지 않습니다.(스프링 부트에서는 기본적으로 이기능을 사용하지 않도록 설정해줌)
    - 보안 이슈(RFD Attack)
    - URI 변수, Path 매개변수 , URI 인코딩을 사용할때 할떄 불명확함
    
RFD Attack
- [Reflected File Download - A New Web Attack Vector](https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/reflected-file-download-a-new-web-attack-vector/)
- [Reflected File Download](https://www.owasp.org/index.php/Reflected_File_Download)
- [CVE-2015-5211 RFD Attack in Spring Framework](https://pivotal.io/security/cve-2015-5211)

## HTTP 요청맵핑하기: 미디어 타입 맵핑
특정한 타입의 데이터를 담고 있는 요청만 처리하는 핸들러
- @RequestMapping(consumes=MediaType.APPLICATION_JSON_UTF8_VALUE)
- Content-Type 헤더로 필터링
- 매치 되지 않는 경우에는 415 Unsupported Media Type 으로 응답

특정한 타입의 응답을 만드는 핸들러
- @RequestMapping(produce="application/json")
- Accept 헤더로 필터링(하지만 살짝 ...오묘함)
- 매치되지 않는 경우에 406 Not Acceptable 응답

- 문자열을 입력하는 대신 Media Type 을 사용하면 상수를(IDE에서) 자동 완성으로 사용할 수 있다.

- 클래스에 선언한 @RequestMapping 에 사용한것과 조합이 되지않고 메소드에 사용한 @RequestMapping 설정으로 덮어ㅡㅆㄴ다.

- Not(!)을 사용해서 특정 미디어 타입이 아닌 경우로 맵핑 할 수도 있다.

## HTTP 요청 맵핑하기 : 헤더와 매개변수
- 특정한 헤더가 있는 요청을 처리하고 싶은 경우
    - @RequestMapping(headers="key")
    
- 특정한 헤더가 없는 요청을 처리하고 싶은 경우
    - @RequestMapping(headers="!key")
    
- 특정한 헤더 키/값 이 있는 요청을 처리하고 싶은 경우
    - @RequestMapping(headers="key = value")
    
- 특정한 요청 매개변수 키를 가지고 있는 요청을 처리하고 싶은 경우
    - @RequestMapping(params="a")
    
- 특정한 요청 매개변수가 없는 요청을 처리하고 싶은 경우
    - @RequestMapping(params="!a")
 
- 특정한 요청 매개변수 키/값을 가지고 있는 요청을 처리하고 싶은 경우
    - @RequestMapping(params ="a=b")
