## Vue CLI 프로젝트를 초기화 하는 기본명령어
~~~
vue init <template-name> <project-name>
~~~
Vue CLI 정의하는 옵션 6개중 하나를 입력
- webpack : webpack 빌드 도구와 vue-loader 를 이용하는 풀옵션으로서 선택에 따라 linter, router, css 전처리 테스팅 도구들을 사용할 수 있다
- webpack-simple : webpack 빌드도구와 vue-loader 를 이용하는 옵션으로서 작은 어플리케이션을 구축하는데 용이
- browserify: browserify와 vueify 를 이용하는 풀옵션으로서, 선택에 따라 linter 와 단위 테스팅 도구를 사용 할 수있다
- browserify-simple : browserify와 vueify 를 이용하는 간단한 옵션, 작은 어플리케이션을 구축하는데 용이
- pwa-webpack : 빌드 도구를 이용하는 PWA 기반의 어플리케이션을 만드는데 용이하다
- simple: 하나의 HTML 파일안에서 vue 컴포넌트로 개발하기에 용이하다
  
  템플릿을 출력하는 명령어
  ~~~
  vue list
  ~~~

## Vue의 필수요소
### Vue 인스턴스
- Vue 어플리케이션은 Vue 함수를 사용하여 새로운 Vue 인스턴스를 만드는것부터 시작
  ~~~
  import Vue from 'vue'
  import App from './App.vue'

  new Vue({
      el: '#app',
      components: {App},
      template: '<App/>'
  })
  ~~~

  - Vue 어플리케이션의 루트는 이러한 인스턴스로 구성되고 루트를 기반으로 Vue 컴포넌트들이 트리형태로 위치하게됨
  - Vue 컴포넌트는 Vue 인스턴스가 확장된 형태이므로 Vue 컴포넌트 또한 vue 인스턴스가 제공해주는 모든 기능을 전부 가지고있음
  
### Vue 인스턴스의 옵션
data : 반응형 모델을 선언할때 사용한다. 
반응형 모델이란 어떤 액션으로 인해 값이 변경되었을때 자바스크립트와 사용자가 보는 뷰에서 보이는 값도 같이 연동되어 변경되는것을 의미
인스턴스가 생성된후 this.$data 로 접근할수있다. 
또한 Vue 인스턴스는 데이터 객체의 내부의 값을 프락싱하므로 this.$data.a 와 this.a 는 같은 값
~~~
// 뷰인스턴스
const data = { a: 1};
new Vue({
    data : data
})

// 뷰 컴포넌트
const myComponent = Vue.extend({
    name: 'MyComponent',
    data (){
        return { a:1 };
    }
})
~~~

props : 부모컴포넌트로부터 데이터를 받아올수있게 노출된 속성들이다. 이렇게 노출된 속성들은 HTML 요소의 어트리뷰트처럼 작성하여 값을 할당 할 수 있다
자식 컴포넌트에서 props 속성을 직접 변경할수는 있지만 브라우저의 개발자 콘솔에서 경고를 띄움
emit 을 통해 부모 컴포넌트의 데이터를 변경해줘야함
~~~
Vue.component('MyComponent',{
    // 단순한 구문으로 표현하기
    props: ['size','myMessage']
})

Vue.component('MyComponent2',{
    props:{
        //타입만 체크할 경우
        height: Number,
        // 타입체크와 유효성 검사, 기본값 등 추가로 지정할 경우
        width:{
            type: Number,
            required: true.
            default: 1,
            validator (value){
                return value > 0
            }
        }
    }
})
~~~

props 속성 사용예시
~~~
<my-component :width="3" :height="3"></<my-component>
~~~

computed : 계산된 데이터, computed 내부에서 사용된 데이터가 변경되면 자동으로 computed 값도 갱신됨
가장큰 장점은 한번 계산이되고나면 캐싱된다는점
내부에서 사용되는 데이터가 갱신되기전에는 다시 계산되지 않으므로 함수를 선언해서 호출하는 방법보다 효율적이다
computed 는 인자를 받지 않는 함수로 선언하여 사용한다
기본적으로 computed 함수는 getter 함수를 가지고있어 읽기에 특화되어 있지만 setter 함수를 통해 값을 쓰기 기능을 지원

~~~
Vue.component('MyComponent',{
    template : '<div>{{ doubleAge }}</div>',
    data() {
        return { age: 28}
    },
    computed:{
        doubleAge: {
          get: function(){
            return this.age * 2 //56이 반환됨
          },
          set: function(newAge){
              this.age=newAge;
          }
        }
    }
})
~~~

methods
- methods 는 인스턴스에 추가되는 메소드다
  methods 에 선언된 메소드를 실행시킬때는 this 를 통해 직접 접근하여 실행시키거나 디렉티브 표현식을 통해 사용 할 수 있다
  선언된 모든 메소드는 this 컨텍스트를 Vue 인스턴스에 바인딩한다.
  그렇기 때문에 만약 화살표 함수(Arrow function)를 사용하여 메소드를 정의하면 this 가 현재 인스턴스가 아닌 부모 컨텍스트를 의미하게 되므로
  메소드 내부에서 현재 인스턴스의 data 나 props에 접근 할 수 없게 된다는 점 주의

~~~
Vue.component('MyComponent',{
    data(){
        return { age : 28}
    },
    methods: {
        plusNumber(){
            this.age++;
        }
    }
})
~~~

watch
watch는 뷰 인스턴스내의 데이터의 변화를 감지
특정 로직은 수행해야 할때 주로 사용하는 감시자 속성 
watch에 사용되는 메소드의 이름은 감시하는 데이터의 이름이며 해당 데이터가 변경되었을때 메소드 내부에 작성한 코드가 실행하는 방식으로 동작

~~~
Vue.component('MyComponent',{
  data(){
      return { a: 'Hello World', b:1}
  },
  watch:{
      a(nextValue, prevValue){
          console.log(`new: ${nextValue}, old:${preValue}`)
      }
  }
})
~~~
watch 속성을 선언할때 함수의 인자로는 첫번쨰 인자는 새로운 값, 두번째 인자로는 변경되기전에 상태와 같이 총 2개의 인자를 받을 수 있음
watch 속성은 비동기처리등과 같이 특정 로직을 처리하는데 걸리는 소요시간이 많을 경우 사용한다
예를들어 게시판 페이징 기능과 같은 곳에서 사용 가능

~~~
Vue.component('Board',{
    data(){
        return { contents: [], paging: 1}
    },
    watch:{
        paging(page){
            // paging 데이터가 변경될때마다 API 호출하여, contents 데이터를 갱신한다
            fetchBoard(`/api/board?page=${page}`)
                .then(res =>{
                    this.contents = red.data
                })
        }
    }
})
~~~
만약 감시하고자 하는 데이터가 Object 속성이라면 deep 이나 handler 와 같은 옵션을 사용하여 해당 데이터의 내부속성까지 감시

~~~
Vue.component('MyComponent',{
    data (){
        return {
            a: {
                b:1
            }
        }
    },
    watch:{
        a:{
            handler (nextValue, preValue){
                 console.log(`new: ${nextValue}, old:${preValue}`)
            },
            deep: true,
        }
    }
})
~~~

watch 와 computed 차이점
- computed 는 메소드 내부에서 사용된 변수들을 감시하며 한번 저장된 값은 캐싱되므로 어떤 변수들을 사용해서 값을 계산하는데 적합
- watch 는 캐싱되지 않고 변수가 Obejct 라고 해도 deep 옵션을 사용해서 내부를 깊게 감시할 수 있기 때문에 어떤값이 변경되었을때
  그 값을 사용해서 API 통신을 수행해서 모델을 서버로 부터 다시 받아와야 한다든가 하는 특정한 로직을 수행할때 적합하다고 볼수있음
**computed 도 watch 와 비슷한 방식으로 사용 할 수 있지만 값이 캐싱되어 메소드가 호출되지 않을 경우가 있으므로 그때 상황에 맞게 알맞은 속성을 사용해야함**

## Vue 인스턴스의 생명주기
### beforeCreate
~~~
new Vue({
    el:'#app',
    beforeCreate(){
        console.log('beforeCreate Hook 이 실행됩니다');
    }
})
~~~
- beforeCreate 훅은 인스턴스가 생성될때 가장 처음으로 실행되는 훅 
- 아직 데이터와 이벤트는 생성되지 않아 접근 할 수 없음

### created
~~~
new Vue({
    el:'#app',
    created(){
        console.log('created Hook이 실행됩니다.');
    }
})
~~~
created 훅은 beforeCreate 훅의 다음단계로서 beforeCreate 훅이 호출된 직후 데이터와 이벤트가 초기화 되어
created 훅에서는 데이터와 이벤트에 접근 할 수 있음
그러나 아직 DOM 이 마운트 되지 않았으므로 인스턴스의 DOM에 접근하는 $el 속성 사용 X
**주로 API 서버의 요청을 통해 애플리케이션에서 필요한 데이터를 받아올때 해당 훅으로 받아옴**

### beforeMount
~~~
new Vue({
    el:'#app',
    beforeMount(){
        console.log('beforeMount Hook이 실행됩니다');
    }
})
~~~
beforeMount 훅 이후부터는 컴포넌트에 접근 할 수 있음 beforeMount 훅은 말그대로 DOM 이 마운트 되지 않은 상태이기 때문에
아직은 $el 속성을 통해 인스턴스 돔에 접근 할 수 없는 단계

### mounted
~~~
new Vue({
    el:'#app',
    mounted(){
        console.log('mounted Hook이 실행됩니다');
    }
})
~~~
mounted 훅에서는 인스턴스 렌더와 DOM 마운트가 끝난 상태 $el 속성을 사용하여 인스턴스 DOM 에 접근 할 수 있게된다
**만약 그래프와 같은 DOM 관련 라이브러리를 사용하는 경우 해당 훅에서 DOME 을 랜더하면됨**
현재의 인스턴스의 마운트가 끝났다는 의미
현재 인스턴스가 가지고있는 자식 컴포넌트들까지 마운트가 끝난 상태를 의미하는것은 아니다
**만약 모든 자식컴포넌트들까지 마운트가 끝난 상태를 알고 싶다면 vm.$nextTick 메소드를 사용하여 전체 컴포넌트가 렌더된 상태를 보장 할 수 있다.**

### beforeUpdate
~~~
new Vue({
    el: '#app',
    beforeUpdate(){
        console.log('beforeUpdate Hook이 실행됩니다.');
    }
})
~~~
컴포넌트가 마운트가 다된후 데이터의 변화가 감지 됐을때 해당하는 데이터와 관련있는 DOM 을 업데이트하기전에 호출된다
가상돔과 연관이 깊은 훅
vue.js 는 데이터가 변경됨에 따라 변경된 데이터를 가상돔에 적용한다.
가상돔에 적용된 돔을 랜더링하기전에 호출되는 훅으로서 이과정에서 데이터가 변경되더라도 다시 렌더링 되지 않ㄴ는다

### updated
~~~
new Vue({
    el:'#app',
    updated(){
        console.log('updated Hook 이 실행됩니다.');
    }
})
~~~
updated 훅은 가상 DOM이 재랜더링 되어 실제 DOM이 되었을때 호출된다. 데이터가 변경된후 DOM 까지 모두 업데이트가 완료된 상태이므로
DOM 에 접근하여 특정 로직을 수행하는 일이 가능하다.
**mounted 와 마찬가지로 모든 자식 컴포넌트가 재랜더링 된 상태를 보장해 주지 않으므로 전체 컴포넌트가 재랜더링된 상태를 원한다면 vm.$nextTick 메소드를 사용**

주의
updated 훅은 데이터가 업데이트 되고 돔이 다시 렌더링되고 난 후 호출되기 때문에 updated 훅에서 뷰와 관련된 데이터를 다시 변경하는 코드를 작성해버리면
DOM 이 다시 렌더링되고 또다시 updated 훅이 호출되면서 무한루프에 빠짐

### beforeDestory
~~~
new Vue({
   el:'#app',
   beforeDestory(){
       console.log('beforeDestory Hook 이 실행됩니다');
   }
})
~~~
beforeDestroy 훅은 vue 인스턴스가 제거되기 전에 호출되는 훅이다
아직 인스턴스가 제거되지 않은 상태이므로 this 를 사용하여 해당 인스턴스에 접근하는것이 가능하다
주로 인스턴스가 제거되기전에 인스턴스에 접근해서 수행하는 코드를 작성할때 beforeDestory 훅에서 해당하는 로직을 작성한다
예를 들어 document.body 에 특정 이벤트를 걸어두고 이벤트를 해제시켜주지 않으면 계속해서 이벤트가 실행될것이다
이러한 특정이벤트를 초기화 시켜줄때 beforeDestory 훅 안에서 이벤트를 초기화 시켜준다면 그러한 문제를 피할수 있다.

### destroyed
~~~
new Vue({
     el:'#app',
     destroyed(){
       console.log('destroyed Hook이 실행됩니다.');
     } 
})
~~~
- destory 훅은 Vue 인스턴스가 제거된 후에 실행되는 훅이다. 인스턴스는 이미 제거 되었기 때문에 this를 사용하여 접근 불가능
- 컴포넌트의 걸려있는 모든 이벤트가 해제됨

## Vue 템플릿 문법
텍스트 보간
자바스크립트 내의 데이터를 DOM 에 바인딩하기 위해서는 이중 중괄호{{}} 문법을 상요한다

msg 변수가 바인딩된 DOM 의 모습
~~~
<p>{{msg}}</p>
~~~

일회성 보간을 위해 v-once 디렉티브를 사용한 모습
~~~
<p v-once>{{msg}}</p>
~~~

### HTML 보간
텍스트 보간 문법을 사용하여 HTML 렌더ㄹ하려고하면 화면에는 문자열 그대로 나오게됨
이런 경우에는 v-html 디렉티브를 사용하여 HTML 코드를 문자열이 아닌 실제 HTML 로 인식하도록 바인딩
~~~
<div>
    <span v-html="rawHTML"></span>
</div>
<script>
export default {
    data(){
        return { rawHTML: '<span style="color: red">Hello</span>' }
    }
}
</script>
~~~
v-html 디렉티브는 굉장히 편한 기능이지만 반대로 위험함
신뢰할 수없는 값을 v-html 통해 렌더하면 XSS 공격을 할수있게됨 그렇기 때문에 신뢰할 수 잇는 값만 HTML로 보간으로 할수 있도록 해야함

### HTML 속성
vue 는 HTML 속성 또한 변수를 사용하여 보간 할 수있게 지원해준다
v-bind 디렉티브를 사용함
~~~
<div v-bind:id="dynamicId"></div>
<select v-bind:disabled="isDisabled"></select>
~~~

### 자바스크립트 표현식 사용
여러가지 자바스크립트 표현식 종류
~~~
{{ 1+1 }}
{{ isFinish ? '수고하셨습니다.' : '아직 끝나지 않았습니다.' }}
{{ userName.split('').reverse().join('')}}

// 자바스크립트에서 제공해주는 전역 객체에도 접근이 가능하다
{{ Math.random() }}
~~~

v-bind 디렉티브와 자바스크립트 표현식을 함께 사용하는 모습
~~~
<div v-bind:id="'element-'+ UserId"></div>
~~~